import "./chunk-BUSYA2B4.js";

// node_modules/astronomia/src/base.js
var K = 0.01720209895;
var AU = 149597870;
var SOblJ2000 = 0.397777156;
var COblJ2000 = 0.917482062;
function lightTime(dist) {
  return 0.0057755183 * dist;
}
var JMod = 24000005e-1;
var J2000 = 2451545;
var J1900 = 2415020;
var B1900 = 24150203135e-4;
var B1950 = 24332824235e-4;
var JulianYear = 365.25;
var JulianCentury = 36525;
var BesselianYear = 365.2421988;
var meanSiderealYear = 365.25636;
function JulianYearToJDE(jy) {
  return J2000 + JulianYear * (jy - 2e3);
}
function JDEToJulianYear(jde) {
  return 2e3 + (jde - J2000) / JulianYear;
}
function BesselianYearToJDE(by) {
  return B1900 + BesselianYear * (by - 1900);
}
function JDEToBesselianYear(jde) {
  return 1900 + (jde - B1900) / BesselianYear;
}
function J2000Century(jde) {
  return (jde - J2000) / JulianCentury;
}
function illuminated(i) {
  return (1 + Math.cos(i)) * 0.5;
}
var Coord = class {
  /**
   * celestial coordinates in right ascension and declination
   * or ecliptic coordinates in longitude and latitude
   *
   * @param {number} ra - right ascension (or longitude)
   * @param {number} dec - declination (or latitude)
   * @param {number} [range] - distance
   * @param {number} [elongation] - elongation
   */
  constructor(ra, dec, range, elongation) {
    this._ra = ra || 0;
    this._dec = dec || 0;
    this.range = range;
    this.elongation = elongation;
  }
  /**
   * right ascension
   * @return {number}
   */
  get ra() {
    return this._ra;
  }
  set ra(ra) {
    this._ra = ra;
  }
  /**
   * declination
   * @return {number}
   */
  get dec() {
    return this._dec;
  }
  set dec(dec) {
    this._dec = dec;
  }
  /**
   * right ascension (or longitude)
   * @return {number}
   */
  get lon() {
    return this._ra;
  }
  set lon(ra) {
    this._ra = ra;
  }
  /**
   * declination (or latitude)
   * @return {number}
   */
  get lat() {
    return this._dec;
  }
  set lat(dec) {
    this._dec = dec;
  }
};
function limb(equ, appSun) {
  const α = equ.ra;
  const δ = equ.dec;
  const α0 = appSun.ra;
  const δ0 = appSun.dec;
  const sδ = Math.sin(δ);
  const cδ = Math.cos(δ);
  const sδ0 = Math.sin(δ0);
  const cδ0 = Math.cos(δ0);
  const sα0α = Math.sin(α0 - α);
  const cα0α = Math.cos(α0 - α);
  let χ = Math.atan2(cδ0 * sα0α, sδ0 * cδ - cδ0 * sδ * cα0α);
  if (χ < 0) {
    χ += 2 * Math.PI;
  }
  return χ;
}
var SmallAngle = 10 * Math.PI / 180 / 60;
var CosSmallAngle = Math.cos(SmallAngle);
function pmod(x, y) {
  let r = x % y;
  if (r < 0) {
    r += y;
  }
  return r;
}
function horner(x, ...c3) {
  if (Array.isArray(c3[0])) {
    c3 = c3[0];
  }
  let i = c3.length - 1;
  let y = c3[i];
  while (i > 0) {
    i--;
    y = y * x + c3[i];
  }
  return y;
}
function floorDiv(x, y) {
  const q = x / y;
  return Math.floor(q);
}
function cmp(a, b) {
  if (a < b) return -1;
  if (a > b) return 1;
  return 0;
}
function sincos(ε) {
  return [Math.sin(ε), Math.cos(ε)];
}
function toRad(deg) {
  return Math.PI / 180 * deg;
}
function toDeg(rad) {
  return 180 / Math.PI * rad;
}
function modf(float) {
  const i = Math.trunc(float);
  const f = Math.abs(float - i);
  return [i, f];
}
function round(float, precision = 14) {
  return parseFloat(float.toFixed(precision));
}
function errorCode(msg, code) {
  const err = new Error(msg);
  err.code = code;
  return err;
}
var base_default = {
  K,
  AU,
  SOblJ2000,
  COblJ2000,
  lightTime,
  JMod,
  J2000,
  J1900,
  B1900,
  B1950,
  JulianYear,
  JulianCentury,
  BesselianYear,
  meanSiderealYear,
  JulianYearToJDE,
  JDEToJulianYear,
  BesselianYearToJDE,
  JDEToBesselianYear,
  J2000Century,
  illuminated,
  Coord,
  limb,
  SmallAngle,
  CosSmallAngle,
  pmod,
  horner,
  floorDiv,
  cmp,
  sincos,
  toRad,
  toDeg,
  modf,
  round,
  errorCode
};

// node_modules/astronomia/src/interpolation.js
var int = Math.trunc;
var errorNot3 = new Error("Argument y must be length 3");
var errorNot4 = new Error("Argument y must be length 4");
var errorNot5 = new Error("Argument y must be length 5");
var errorNoXRange = new Error("Argument x3 (or x5) cannot equal x1");
var errorNOutOfRange = new Error("Interpolating factor n must be in range -1 to 1");
var errorNoExtremum = new Error("No extremum in table");
var errorExtremumOutside = new Error("Extremum falls outside of table");
var errorZeroOutside = new Error("Zero falls outside of table");
var errorNoConverge = new Error("Failure to converge");
var Len3 = class {
  /**
   * NewLen3 prepares a Len3 object from a table of three rows of x and y values.
   *
   * X values must be equally spaced, so only the first and last are supplied.
   * X1 must not equal to x3.  Y must be a slice of three y values.
   *
   * @throws Error
   * @param {Number} x1 - is the x value corresponding to the first y value of the table.
   * @param {Number} x3 - is the x value corresponding to the last y value of the table.
   * @param {Number[]} y - is all y values in the table. y.length should be >= 3.0
   */
  constructor(x1, x3, y) {
    if (y.length !== 3) {
      throw errorNot3;
    }
    if (x3 === x1) {
      throw errorNoXRange;
    }
    this.x1 = x1;
    this.x3 = x3;
    this.y = y;
    this.a = y[1] - y[0];
    this.b = y[2] - y[1];
    this.c = this.b - this.a;
    this.abSum = this.a + this.b;
    this.xSum = x3 + x1;
    this.xDiff = x3 - x1;
  }
  /**
   * InterpolateX interpolates for a given x value.
   */
  interpolateX(x) {
    const n = (2 * x - this.xSum) / this.xDiff;
    return this.interpolateN(n);
  }
  /**
   * InterpolateXStrict interpolates for a given x value,
   * restricting x to the range x1 to x3 given to the constructor NewLen3.
   */
  interpolateXStrict(x) {
    const n = (2 * x - this.xSum) / this.xDiff;
    const y = this.interpolateNStrict(n);
    return y;
  }
  /**
   * InterpolateN interpolates for (a given interpolating factor n.
   *
   * This is interpolation formula (3.3)
   *
   * @param n - The interpolation factor n is x-x2 in units of the tabular x interval.
   * (See Meeus p. 24.)
   * @return {number} interpolation value
   */
  interpolateN(n) {
    return this.y[1] + n * 0.5 * (this.abSum + n * this.c);
  }
  /**
   * InterpolateNStrict interpolates for (a given interpolating factor n.
   *
   * @param {number} n - n is restricted to the range [-1..1] corresponding to the range x1 to x3
   * given to the constructor of Len3.
   * @return {number} interpolation value
   */
  interpolateNStrict(n) {
    if (n < -1 || n > 1) {
      throw errorNOutOfRange;
    }
    return this.interpolateN(n);
  }
  /**
   * Extremum returns the x and y values at the extremum.
   *
   * Results are restricted to the range of the table given to the constructor
   * new Len3.
   */
  extremum() {
    if (this.c === 0) {
      throw errorNoExtremum;
    }
    const n = this.abSum / (-2 * this.c);
    if (n < -1 || n > 1) {
      throw errorExtremumOutside;
    }
    const x = 0.5 * (this.xSum + this.xDiff * n);
    const y = this.y[1] - this.abSum * this.abSum / (8 * this.c);
    return [x, y];
  }
  /**
   * Len3Zero finds a zero of the quadratic function represented by the table.
   *
   * That is, it returns an x value that yields y=0.
   *
   * Argument strong switches between two strategies for the estimation step.
   * when iterating to converge on the zero.
   *
   * Strong=false specifies a quick and dirty estimate that works well
   * for gentle curves, but can work poorly or fail on more dramatic curves.
   *
   * Strong=true specifies a more sophisticated and thus somewhat more
   * expensive estimate.  However, if the curve has quick changes, This estimate
   * will converge more reliably and in fewer steps, making it a better choice.
   *
   * Results are restricted to the range of the table given to the constructor
   * NewLen3.
   */
  zero(strong) {
    let f;
    if (strong) {
      f = (n02) => {
        return n02 - (2 * this.y[1] + n02 * (this.abSum + this.c * n02)) / (this.abSum + 2 * this.c * n02);
      };
    } else {
      f = (n02) => {
        return -2 * this.y[1] / (this.abSum + this.c * n02);
      };
    }
    const [n0, ok] = iterate(0, f);
    if (!ok) {
      throw errorNoConverge;
    }
    if (n0 > 1 || n0 < -1) {
      throw errorZeroOutside;
    }
    return 0.5 * (this.xSum + this.xDiff * n0);
  }
};
function len3ForInterpolateX(x, x1, xN, y) {
  let y3 = y;
  if (y.length > 3) {
    const interval = (xN - x1) / (y.length - 1);
    if (interval === 0) {
      throw errorNoXRange;
    }
    let nearestX = int((x - x1) / interval + 0.5);
    if (nearestX < 1) {
      nearestX = 1;
    } else if (nearestX > y.length - 2) {
      nearestX = y.length - 2;
    }
    y3 = y.slice(nearestX - 1, nearestX + 2);
    xN = x1 + (nearestX + 1) * interval;
    x1 = x1 + (nearestX - 1) * interval;
  }
  return new Len3(x1, xN, y3);
}
var iterate = function(n0, f) {
  for (let limit = 0; limit < 50; limit++) {
    const n1 = f(n0);
    if (!isFinite(n1) || isNaN(n1)) {
      break;
    }
    if (Math.abs((n1 - n0) / n0) < 1e-15) {
      return [n1, true];
    }
    n0 = n1;
  }
  return [0, false];
};
function len4Half(y) {
  if (y.length !== 4) {
    throw errorNot4;
  }
  return (9 * (y[1] + y[2]) - y[0] - y[3]) / 16;
}
var Len5 = class {
  /**
   * NewLen5 prepares a Len5 object from a table of five rows of x and y values.
   *
   * X values must be equally spaced, so only the first and last are suppliethis.
   * X1 must not equal x5.  Y must be a slice of five y values.
   */
  constructor(x1, x5, y) {
    if (y.length !== 5) {
      throw errorNot5;
    }
    if (x5 === x1) {
      throw errorNoXRange;
    }
    this.x1 = x1;
    this.x5 = x5;
    this.y = y;
    this.y3 = y[2];
    this.a = y[1] - y[0];
    this.b = y[2] - y[1];
    this.c = y[3] - y[2];
    this.d = y[4] - y[3];
    this.e = this.b - this.a;
    this.f = this.c - this.b;
    this.g = this.d - this.c;
    this.h = this.f - this.e;
    this.j = this.g - this.f;
    this.k = this.j - this.h;
    this.xSum = x5 + x1;
    this.xDiff = x5 - x1;
    this.interpCoeff = [
      // (3.8) p. 28
      this.y3,
      (this.b + this.c) / 2 - (this.h + this.j) / 12,
      this.f / 2 - this.k / 24,
      (this.h + this.j) / 12,
      this.k / 24
    ];
  }
  /**
   * InterpolateX interpolates for (a given x value.
   */
  interpolateX(x) {
    const n = (4 * x - 2 * this.xSum) / this.xDiff;
    return this.interpolateN(n);
  }
  /**
   * InterpolateXStrict interpolates for a given x value,
   * restricting x to the range x1 to x5 given to the the constructor NewLen5.
   */
  interpolateXStrict(x) {
    const n = (4 * x - 2 * this.xSum) / this.xDiff;
    const y = this.interpolateNStrict(n);
    return y;
  }
  /**
   * InterpolateN interpolates for (a given interpolating factor n.
   *
   * The interpolation factor n is x-x3 in units of the tabular x interval.
   * (See Meeus p. 28.)
   */
  interpolateN(n) {
    return base_default.horner(n, ...this.interpCoeff);
  }
  /**
   * InterpolateNStrict interpolates for (a given interpolating factor n.
   *
   * N is restricted to the range [-1..1].  This is only half the range given
   * to the constructor NewLen5, but is the recommendation given on p. 31.0
   */
  interpolateNStrict(n) {
    if (n < -1 || n > 1) {
      throw errorNOutOfRange;
    }
    return base_default.horner(n, ...this.interpCoeff);
  }
  /**
   * Extremum returns the x and y values at the extremum.
   *
   * Results are restricted to the range of the table given to the constructor
   * NewLen5.  (Meeus actually recommends restricting the range to one unit of
   * the tabular interval, but that seems a little harsh.)
   */
  extremum() {
    const nCoeff = [
      6 * (this.b + this.c) - this.h - this.j,
      0,
      3 * (this.h + this.j),
      2 * this.k
    ];
    const den = this.k - 12 * this.f;
    if (den === 0) {
      throw errorExtremumOutside;
    }
    const [n0, ok] = iterate(0, function(n02) {
      return base_default.horner(n02, ...nCoeff) / den;
    });
    if (!ok) {
      throw errorNoConverge;
    }
    if (n0 < -2 || n0 > 2) {
      throw errorExtremumOutside;
    }
    const x = 0.5 * this.xSum + 0.25 * this.xDiff * n0;
    const y = base_default.horner(n0, ...this.interpCoeff);
    return [x, y];
  }
  /**
   * Len5Zero finds a zero of the quartic function represented by the table.
   *
   * That is, it returns an x value that yields y=0.
   *
   * Argument strong switches between two strategies for the estimation step.
   * when iterating to converge on the zero.
   *
   * Strong=false specifies a quick and dirty estimate that works well
   * for gentle curves, but can work poorly or fail on more dramatic curves.
   *
   * Strong=true specifies a more sophisticated and thus somewhat more
   * expensive estimate.  However, if the curve has quick changes, This estimate
   * will converge more reliably and in fewer steps, making it a better choice.
   *
   * Results are restricted to the range of the table given to the constructor
   * NewLen5.
   */
  zero(strong) {
    let f;
    if (strong) {
      const M = this.k / 24;
      const N = (this.h + this.j) / 12;
      const P = this.f / 2 - M;
      const Q = (this.b + this.c) / 2 - N;
      const numCoeff = [this.y3, Q, P, N, M];
      const denCoeff = [Q, 2 * P, 3 * N, 4 * M];
      f = function(n02) {
        return n02 - base_default.horner(n02, ...numCoeff) / base_default.horner(n02, ...denCoeff);
      };
    } else {
      const numCoeff = [
        -24 * this.y3,
        0,
        this.k - 12 * this.f,
        -2 * (this.h + this.j),
        -this.k
      ];
      const den = 12 * (this.b + this.c) - 2 * (this.h + this.j);
      f = function(n02) {
        return base_default.horner(n02, ...numCoeff) / den;
      };
    }
    const [n0, ok] = iterate(0, f);
    if (!ok) {
      throw errorNoConverge;
    }
    if (n0 > 2 || n0 < -2) {
      throw errorZeroOutside;
    }
    const x = 0.5 * this.xSum + 0.25 * this.xDiff * n0;
    return x;
  }
};
function lagrange(x, table) {
  let sum5 = 0;
  table.forEach((ti, i) => {
    const xi = ti[0];
    let prod = 1;
    table.forEach((tj, j) => {
      if (i !== j) {
        const xj = tj[0];
        prod *= (x - xj) / (xi - xj);
      }
    });
    sum5 += ti[1] * prod;
  });
  return sum5;
}
function lagrangePoly(table) {
  const sum5 = new Array(table.length).fill(0);
  const prod = new Array(table.length).fill(0);
  const last2 = table.length - 1;
  for (let i = 0; i < table.length; i++) {
    const xi = table[i][0] || table[i].x || 0;
    const yi = table[i][1] || table[i].y || 0;
    prod[last2] = 1;
    let den = 1;
    let n = last2;
    for (let j = 0; j < table.length; j++) {
      if (i !== j) {
        const xj = table[j][0] || table[j].x || 0;
        prod[n - 1] = prod[n] * -xj;
        for (let k3 = n; k3 < last2; k3++) {
          prod[k3] -= prod[k3 + 1] * xj;
        }
        n--;
        den *= xi - xj;
      }
    }
    prod.forEach((pj, j) => {
      sum5[j] += yi * pj / den;
    });
  }
  return sum5;
}
function linear(x, x1, xN, y) {
  const interval = (xN - x1) / (y.length - 1);
  if (interval === 0) {
    throw errorNoXRange;
  }
  let nearestX = Math.floor((x - x1) / interval);
  if (nearestX < 0) {
    nearestX = 0;
  } else if (nearestX > y.length - 2) {
    nearestX = y.length - 2;
  }
  const y2 = y.slice(nearestX, nearestX + 2);
  const x01 = x1 + nearestX * interval;
  return y2[0] + (y[1] - y[0]) * (x - x01) / interval;
}
var interpolation_default = {
  errorNot3,
  errorNot4,
  errorNot5,
  errorNoXRange,
  errorNOutOfRange,
  errorNoExtremum,
  errorExtremumOutside,
  errorZeroOutside,
  errorNoConverge,
  Len3,
  len3ForInterpolateX,
  iterate,
  len4Half,
  Len5,
  lagrange,
  lagrangePoly,
  linear
};

// node_modules/astronomia/src/angle.js
var { abs, acos, asin, atan2, cos, hypot, sin, sqrt, tan } = Math;
function sep(c1, c22) {
  const [sind1, cosd1] = base_default.sincos(c1.dec);
  const [sind2, cosd2] = base_default.sincos(c22.dec);
  const cd = sind1 * sind2 + cosd1 * cosd2 * cos(c1.ra - c22.ra);
  if (cd < base_default.CosSmallAngle) {
    return acos(cd);
  } else {
    const cosd = cos((c22.dec + c1.dec) / 2);
    return hypot((c22.ra - c1.ra) * cosd, c22.dec - c1.dec);
  }
}
function minSep(jd1, jd3, cs1, cs2, fnSep) {
  fnSep = fnSep || sep;
  if (cs1.length !== 3 || cs2.length !== 3) {
    throw interpolation_default.errorNot3;
  }
  const y = new Array(3);
  cs1.forEach((c3, x) => {
    y[x] = sep(cs1[x], cs2[x]);
  });
  const d3 = new interpolation_default.Len3(jd1, jd3, y);
  const dMin = d3.extremum()[1];
  return dMin;
}
function minSepRect(jd1, jd3, cs1, cs2) {
  if (cs1.length !== 3 || cs2.length !== 3) {
    throw interpolation_default.ErrorNot3;
  }
  const uv = function(c1, c22) {
    const [sind1, cosd1] = base_default.sincos(c1.dec);
    const Δr = c22.ra - c1.ra;
    const tanΔr = tan(Δr);
    const tanhΔr = tan(Δr / 2);
    const K2 = 1 / (1 + sind1 * sind1 * tanΔr * tanhΔr);
    const sinΔd = sin(c22.dec - c1.dec);
    const u2 = -K2 * (1 - sind1 / cosd1 * sinΔd) * cosd1 * tanΔr;
    const v2 = K2 * (sinΔd + sind1 * cosd1 * tanΔr * tanhΔr);
    return [u2, v2];
  };
  const us = new Array(3).fill(0);
  const vs = new Array(3).fill(0);
  cs1.forEach((c3, x) => {
    [us[x], vs[x]] = uv(cs1[x], cs2[x]);
  });
  const u3 = new interpolation_default.Len3(-1, 1, us);
  const v3 = new interpolation_default.Len3(-1, 1, vs);
  const up0 = (us[2] - us[0]) / 2;
  const vp0 = (vs[2] - vs[0]) / 2;
  const up1 = us[0] + us[2] - 2 * us[1];
  const vp1 = vs[0] + vs[2] - 2 * vs[1];
  const up = up0;
  const vp = vp0;
  let dn = -(us[1] * up + vs[1] * vp) / (up * up + vp * vp);
  let n = dn;
  let u;
  let v;
  for (let limit = 0; limit < 10; limit++) {
    u = u3.interpolateN(n);
    v = v3.interpolateN(n);
    if (abs(dn) < 1e-5) {
      return hypot(u, v);
    }
    const up2 = up0 + n * up1;
    const vp2 = vp0 + n * vp1;
    dn = -(u * up2 + v * vp2) / (up2 * up2 + vp2 * vp2);
    n += dn;
  }
  throw new Error("minSepRect: failure to converge");
}
function hav(a) {
  return 0.5 * (1 - Math.cos(a));
}
function sepHav(c1, c22) {
  return 2 * asin(sqrt(hav(c22.dec - c1.dec) + cos(c1.dec) * cos(c22.dec) * hav(c22.ra - c1.ra)));
}
function minSepHav(jd1, jd3, cs1, cs2) {
  return minSep(jd1, jd3, cs1, cs2, sepHav);
}
function sepPauwels(c1, c22) {
  const [sind1, cosd1] = base_default.sincos(c1.dec);
  const [sind2, cosd2] = base_default.sincos(c22.dec);
  const cosdr = cos(c22.ra - c1.ra);
  const x = cosd1 * sind2 - sind1 * cosd2 * cosdr;
  const y = cosd2 * sin(c22.ra - c1.ra);
  const z = sind1 * sind2 + cosd1 * cosd2 * cosdr;
  return atan2(hypot(x, y), z);
}
function minSepPauwels(jd1, jd3, cs1, cs2) {
  return minSep(jd1, jd3, cs1, cs2, sepPauwels);
}
function relativePosition(c1, c22) {
  const [sinΔr, cosΔr] = base_default.sincos(c1.ra - c22.ra);
  const [sind2, cosd2] = base_default.sincos(c22.dec);
  const p2 = atan2(sinΔr, cosd2 * tan(c1.dec) - sind2 * cosΔr);
  return p2;
}
var angle_default = {
  sep,
  minSep,
  minSepRect,
  hav,
  sepHav,
  minSepHav,
  sepPauwels,
  minSepPauwels,
  relativePosition
};

// node_modules/astronomia/src/sexagesimal.js
var Angle = class {
  /**
  * constructs a new Angle value from sign, degree, minute, and second
  * components.
  * @param {Number|Boolean} angleOrNeg - angle in radians or sign, true if negative (required to attribute -0°30')
  * __Four arguments__
  * @param {Number} [d] - (int) degree
  * @param {Number} [m] - (int) minute
  * @param {Number} [s] - (float) second
  */
  constructor(angleOrNeg, d3, m3, s2) {
    if (arguments.length === 1) {
      this.angle = Number(angleOrNeg);
    } else {
      this.setDMS(!!angleOrNeg, d3, m3, s2);
    }
  }
  /**
   * SetDMS sets the value of an FAngle from sign, degree, minute, and second
   * components.
   * The receiver is returned as a convenience.
   * @param {Boolean} neg - sign, true if negative
   * @param {Number} d - (int) degree
   * @param {Number} m - (int) minute
   * @param {Number} s - (float) second
   * @returns {Angle}
   */
  setDMS(neg = false, d3 = 0, m3 = 0, s2 = 0) {
    this.angle = DMSToDeg(neg, d3, m3, s2) * Math.PI / 180;
    return this;
  }
  /**
   * sets angle
   * @param {Number} angle - (float) angle in radians
   * @returns {Angle}
   */
  setAngle(angle2) {
    this.angle = angle2;
    return this;
  }
  /**
   * Rad returns the angle in radians.
   * @returns {Number} angle in radians
   */
  rad() {
    return this.angle;
  }
  /**
   * Deg returns the angle in degrees.
   * @returns {Number} angle in degree
   */
  deg() {
    return this.angle * 180 / Math.PI;
  }
  /**
   * toDMS converts to parsed sexagesimal angle component.
   */
  toDMS() {
    return degToDMS(this.deg());
  }
  /**
   * Print angle in degree using `d°m´s.ss″`
   * @param {Number} [precision] - precision of `s.ss`
   * @returns {String}
   */
  toString(precision) {
    let [neg, d3, m3, s2] = this.toDMS();
    s2 = round2(s2, precision).toString().replace(/^0\./, ".");
    const str = (neg ? "-" : "") + (d3 + "°") + (m3 + "′") + (s2 + "″");
    return str;
  }
  /**
   * Print angle in degree using `d°.ff`
   * @param {Number} [precision] - precision of `.ff`
   * @returns {String}
   */
  toDegString(precision) {
    let [i, s2] = modf2(this.deg());
    s2 = round2(s2, precision).toString().replace(/^0\./, ".");
    const str = i + "°" + s2;
    return str;
  }
};
var HourAngle = class extends Angle {
  /**
   * NewHourAngle constructs a new HourAngle value from sign, hour, minute,
   * and second components.
   * @param {Boolean} neg
   * @param {Number} h - (int)
   * @param {Number} m - (int)
   * @param {Number} s - (float)
   * @constructor
   */
  /**
   * SetDMS sets the value of an FAngle from sign, degree, minute, and second
   * components.
   * The receiver is returned as a convenience.
   * @param {Boolean} neg - sign, true if negative
   * @param {Number} h - (int) hour
   * @param {Number} m - (int) minute
   * @param {Number} s - (float) second
   * @returns {Angle}
   */
  setDMS(neg = false, h = 0, m3 = 0, s2 = 0) {
    this.angle = DMSToDeg(neg, h, m3, s2) * 15 * Math.PI / 180;
    return this;
  }
  /**
   * Hour returns the hour angle as hours of time.
   * @returns hour angle
   */
  hour() {
    return this.angle * 12 / Math.PI;
  }
  deg() {
    return this.hour();
  }
  /**
   * Print angle in `HʰMᵐs.ssˢ`
   * @param {Number} precision - precision of `s.ss`
   * @returns {String}
   */
  toString(precision) {
    let [neg, h, m3, s2] = this.toDMS();
    s2 = round2(s2, precision).toString().replace(/^0\./, ".");
    const str = (neg ? "-" : "") + (h + "ʰ") + (m3 + "ᵐ") + (s2 + "ˢ");
    return str;
  }
};
function DMSToDeg(neg, d3, m3, s2) {
  s2 = ((d3 * 60 + m3) * 60 + s2) / 3600;
  if (neg) {
    return -s2;
  }
  return s2;
}
function degToDMS(deg) {
  const neg = deg < 0;
  deg = Math.abs(deg);
  let [d3, s2] = modf2(deg % 360);
  const [m3, s1] = modf2(s2 * 60);
  s2 = round2(s1 * 60);
  return [neg, d3, m3, s2];
}
var RA = class extends HourAngle {
  /**
   * constructs a new RA value from hour, minute, and second components.
   * Negative values are not supported, RA wraps values larger than 24
   * to the range [0,24) hours.
   * @param {Number} h - (int) hour
   * @param {Number} m - (int) minute
   * @param {Number} s - (float) second
   */
  constructor(h = 0, m3 = 0, s2 = 0) {
    super(false, h, m3, s2);
    const args = [].slice.call(arguments);
    if (args.length === 1) {
      this.angle = h;
    } else {
      const hr = DMSToDeg(false, h, m3, s2) % 24;
      this.angle = hr * 15 * Math.PI / 180;
    }
  }
  hour() {
    const h = this.angle * 12 / Math.PI;
    return (24 + h % 24) % 24;
  }
};
var Time = class {
  /**
   * @param {boolean|number} negOrTimeInSecs - set `true` if negative; if type is number than time in seconds
   * @param {number} [h] - (int) hour
   * @param {number} [m] - (int) minute
   * @param {number} [s] - (float) second
   * @example
   * new sexa.Time(SECS_OF_DAY)
   * new sexa.Time(false, 15, 22, 7)
   */
  constructor(negOrTimeInSecs, h, m3, s2) {
    if (typeof negOrTimeInSecs === "number") {
      this.time = negOrTimeInSecs;
    } else {
      this.setHMS(negOrTimeInSecs, h, m3, s2);
    }
  }
  setHMS(neg = false, h = 0, m3 = 0, s2 = 0) {
    s2 += (h * 60 + m3) * 60;
    if (neg) {
      s2 = -s2;
    }
    this.time = s2;
  }
  /**
   * @returns {Number} time in seconds.
   */
  sec() {
    return this.time;
  }
  /**
   * @returns {Number} time in minutes.
   */
  min() {
    return this.time / 60;
  }
  /**
   * @returns {Number} time in hours.
   */
  hour() {
    return this.time / 3600;
  }
  /**
   * @returns {Number} time in days.
   */
  day() {
    return this.time / 3600 / 24;
  }
  /**
   * @returns {Number} time in radians, where 1 day = 2 Pi radians.
   */
  rad() {
    return this.time * Math.PI / 12 / 3600;
  }
  /**
   * convert time to HMS
   * @returns {Array} [neg, h, m, s]
   *  {Boolean} neg - sign, true if negative
   *  {Number} h - (int) hour
   *  {Number} m - (int) minute
   *  {Number} s - (float) second
   */
  toHMS() {
    let t = this.time;
    const neg = t < 0;
    t = neg ? -t : t;
    const h = Math.trunc(t / 3600);
    t = t - h * 3600;
    const m3 = Math.trunc(t / 60);
    const s2 = t - m3 * 60;
    return [neg, h, m3, s2];
  }
  /**
   * Print time using `HʰMᵐsˢ.ss`
   * @param {Number} precision - precision of `.ss`
   * @returns {String}
   */
  toString(precision) {
    const [neg, h, m3, s2] = this.toHMS();
    let [si, sf] = modf2(s2);
    if (precision === 0) {
      si = round2(s2, 0);
      sf = 0;
    } else {
      sf = round2(sf, precision).toString().substr(1);
    }
    const str = (neg ? "-" : "") + (h + "ʰ") + (m3 + "ᵐ") + (si + "ˢ") + (sf || "");
    return str;
  }
};
var angleFromDeg = (deg) => deg * Math.PI / 180;
var angleFromMin = (min) => min / 60 * Math.PI / 180;
var angleFromSec = (sec) => sec / 3600 * Math.PI / 180;
var degFromAngle = (angle2) => angle2 * 180 / Math.PI;
var secFromAngle = (angle2) => angle2 * 3600 * 180 / Math.PI;
var secFromHourAngle = (ha) => ha * 240 * 180 / Math.PI;
function modf2(float) {
  const i = Math.trunc(float);
  const f = Math.abs(float - i);
  return [i, f];
}
function round2(float, precision = 10) {
  return parseFloat(float.toFixed(precision));
}
var sexagesimal_default = {
  Angle,
  HourAngle,
  DMSToDeg,
  degToDMS,
  RA,
  Time,
  angleFromDeg,
  angleFromMin,
  angleFromSec,
  degFromAngle,
  secFromAngle,
  secFromHourAngle
};

// node_modules/astronomia/src/globe.js
var Ellipsoid = class {
  /**
   * @param {number} radius - equatorial radius
   * @param {number} flat - ellipsiod flattening
   */
  constructor(radius3, flat) {
    this.radius = radius3;
    this.flat = flat;
  }
  /** A is a common identifier for equatorial radius. */
  A() {
    return this.radius;
  }
  /** B is a common identifier for polar radius. */
  B() {
    return this.radius * (1 - this.flat);
  }
  /** eccentricity of a meridian. */
  eccentricity() {
    return Math.sqrt((2 - this.flat) * this.flat);
  }
  /**
   * parallaxConstants computes parallax constants ρ sin φ′ and ρ cos φ′.
   *
   * Arguments are geographic latitude φ in radians and height h
   * in meters above the ellipsoid.
   *
   * @param {number} φ - geographic latitude in radians
   * @param {number} h - height in meters above the ellipsoid
   * @return {number[]} [ρ sin φ′, ρ cos φ] parallax constants [ρsφ, ρcφ]
   */
  parallaxConstants(φ, h) {
    const boa = 1 - this.flat;
    const su = Math.sin(Math.atan(boa * Math.tan(φ)));
    const cu = Math.cos(Math.atan(boa * Math.tan(φ)));
    const s2 = Math.sin(φ);
    const c3 = Math.cos(φ);
    const hoa = h * 1e-3 / this.radius;
    const ρsφ = su * boa + hoa * s2;
    const ρcφ = cu + hoa * c3;
    return [ρsφ, ρcφ];
  }
  /**
   * rho is distance from Earth center to a point on the ellipsoid.
   *
   * Result unit is fraction of the equatorial radius.
   * @param {number} φ - geographic latitude in radians
   * @returns {number} // TODO
   */
  rho(φ) {
    return 0.9983271 + 16764e-7 * Math.cos(2 * φ) - 35e-7 * Math.cos(4 * φ);
  }
  /**
   * radiusAtLatitude returns the radius of the circle that is the parallel of
   * latitude at φ.
   *
   * Result unit is Km.
   *
   * @param {number} φ
   * @return {number} radius in km
   */
  radiusAtLatitude(φ) {
    const s2 = Math.sin(φ);
    const c3 = Math.cos(φ);
    return this.A() * c3 / Math.sqrt(1 - (2 - this.flat) * this.flat * s2 * s2);
  }
  /**
   * radiusOfCurvature of meridian at latitude φ.
   *
   * Result unit is Km.
   *
   * @param {number} φ
   * @return {number} radius in km
   */
  radiusOfCurvature(φ) {
    const s2 = Math.sin(φ);
    const e2 = (2 - this.flat) * this.flat;
    return this.A() * (1 - e2) / Math.pow(1 - e2 * s2 * s2, 1.5);
  }
  /**
   * distance is distance between two points measured along the surface
   * of an ellipsoid.
   *
   * Accuracy is much better than that of approxAngularDistance or
   * approxLinearDistance.
   *
   * Result unit is Km.
   *
   * @param {Coord} c1
   * @param {Coord} c2
   * @return {number} radius in km
   */
  distance(c1, c22) {
    const [s2f, c2f] = sincos2((c1.lat + c22.lat) / 2);
    const [s2g, c2g] = sincos2((c1.lat - c22.lat) / 2);
    const [s2λ, c2λ] = sincos2((c1.lon - c22.lon) / 2);
    const s2 = s2g * c2λ + c2f * s2λ;
    const c3 = c2g * c2λ + s2f * s2λ;
    const ω = Math.atan(Math.sqrt(s2 / c3));
    const r = Math.sqrt(s2 * c3) / ω;
    const d3 = 2 * ω * this.radius;
    const h1 = (3 * r - 1) / (2 * c3);
    const h2 = (3 * r + 1) / (2 * s2);
    return d3 * (1 + this.flat * (h1 * s2f * c2g - h2 * c2f * s2g));
  }
};
var Earth76 = new Ellipsoid(6378.14, 1 / 298.257);
var RotationRate1996_5 = 7292114992e-14;
function oneDegreeOfLongitude(rp) {
  return rp * Math.PI / 180;
}
function oneDegreeOfLatitude(rm) {
  return rm * Math.PI / 180;
}
function geocentricLatitudeDifference(φ) {
  return (692.73 * Math.sin(2 * φ) - 1.16 * Math.sin(4 * φ)) * Math.PI / (180 * 3600);
}
var Coord2 = class {
  /**
   * @param {number} lat - latitude (φ) in radians
   * @param {number} lon - longitude (ψ, or L) in radians (measured positively westward)
   */
  constructor(lat = 0, lon = 0) {
    this.lat = lat;
    this.lon = lon;
  }
};
function approxAngularDistance(p1, p2) {
  const s1 = Math.sin(p1.lat);
  const c1 = Math.cos(p1.lat);
  const s2 = Math.sin(p2.lat);
  const c22 = Math.cos(p2.lat);
  return s1 * s2 + c1 * c22 * Math.cos(p1.lon - p2.lon);
}
function approxLinearDistance(d3) {
  return 6371 * d3;
}
function sincos2(x) {
  const s2 = Math.sin(x);
  const c3 = Math.cos(x);
  return [s2 * s2, c3 * c3];
}
var globe_default = {
  Ellipsoid,
  Earth76,
  // eslint-disable-next-line camelcase
  RotationRate1996_5,
  oneDegreeOfLongitude,
  oneDegreeOfLatitude,
  geocentricLatitudeDifference,
  Coord: Coord2,
  approxAngularDistance,
  approxLinearDistance
};

// node_modules/astronomia/src/coord.js
var Ecliptic = class {
  /**
   * IMPORTANT: Longitudes are measured *positively* westwards
   * e.g. Washington D.C. +77°04; Vienna -16°23'
   * @param {Number|LonLat} [lon] - Longitude (λ) in radians
   * @param {Number} [lat] - Latitude (β) in radians
   */
  constructor(lon, lat) {
    if (typeof lon === "object") {
      lat = lon.lat;
      lon = lon.lon;
    }
    this.lon = lon || 0;
    this.lat = lat || 0;
  }
  /**
   * converts ecliptic coordinates to equatorial coordinates.
   * @param {Number} ε - Obliquity
   * @returns {Equatorial}
   */
  toEquatorial(ε) {
    const [εsin, εcos] = base_default.sincos(ε);
    const [sβ, cβ] = base_default.sincos(this.lat);
    const [sλ, cλ] = base_default.sincos(this.lon);
    let ra = Math.atan2(sλ * εcos - sβ / cβ * εsin, cλ);
    if (ra < 0) {
      ra += 2 * Math.PI;
    }
    const dec = Math.asin(sβ * εcos + cβ * εsin * sλ);
    return new Equatorial(ra, dec);
  }
};
var Equatorial = class {
  /**
   * @param {Number} ra - (float) Right ascension (α) in radians
   * @param {Number} dec - (float) Declination (δ) in radians
   */
  constructor(ra = 0, dec = 0) {
    this.ra = ra;
    this.dec = dec;
  }
  /**
   * EqToEcl converts equatorial coordinates to ecliptic coordinates.
   * @param {Number} ε - Obliquity
   * @returns {Ecliptic}
   */
  toEcliptic(ε) {
    const [εsin, εcos] = base_default.sincos(ε);
    const [sα, cα] = base_default.sincos(this.ra);
    const [sδ, cδ] = base_default.sincos(this.dec);
    const lon = Math.atan2(sα * εcos + sδ / cδ * εsin, cα);
    const lat = Math.asin(sδ * εcos - cδ * εsin * sα);
    return new Ecliptic(lon, lat);
  }
  /**
   * EqToHz computes Horizontal coordinates from equatorial coordinates.
   *
   * Argument g is the location of the observer on the Earth.  Argument st
   * is the sidereal time at Greenwich.
   *
   * Sidereal time must be consistent with the equatorial coordinates.
   * If coordinates are apparent, sidereal time must be apparent as well.
   *
   * @param {GlobeCoord} g - coordinates of observer on Earth
   * @param {Number} st - sidereal time at Greenwich at time of observation
   * @returns {Horizontal}
   */
  toHorizontal(g2, st) {
    const H = new sexagesimal_default.Time(st).rad() - g2.lon - this.ra;
    const [sH, cH] = base_default.sincos(H);
    const [sφ, cφ] = base_default.sincos(g2.lat);
    const [sδ, cδ] = base_default.sincos(this.dec);
    const azimuth = Math.atan2(sH, cH * sφ - sδ / cδ * cφ);
    const altitude = Math.asin(sφ * sδ + cφ * cδ * cH);
    return new Horizontal(azimuth, altitude);
  }
  /**
   * EqToGal converts equatorial coordinates to galactic coordinates.
   *
   * Equatorial coordinates must be referred to the standard equinox of B1950.0.
   * For conversion to B1950, see package precess and utility functions in
   * package "common".
   *
   * @returns {Galactic}
   */
  toGalactic() {
    const [sdα, cdα] = base_default.sincos(galacticNorth1950.ra - this.ra);
    const [sgδ, cgδ] = base_default.sincos(galacticNorth1950.dec);
    const [sδ, cδ] = base_default.sincos(this.dec);
    const x = Math.atan2(sdα, cdα * sgδ - sδ / cδ * cgδ);
    const lon = (galactic0Lon1950 + 1.5 * Math.PI - x) % (2 * Math.PI);
    const lat = Math.asin(sδ * sgδ + cδ * cgδ * cdα);
    return new Galactic(lon, lat);
  }
};
var Horizontal = class {
  constructor(az = 0, alt = 0) {
    this.az = az;
    this.alt = alt;
  }
  /**
   * transforms horizontal coordinates to equatorial coordinates.
   *
   * Sidereal time must be consistent with the equatorial coordinates.
   * If coordinates are apparent, sidereal time must be apparent as well.
   * @param {GlobeCoord} g - coordinates of observer on Earth (lat, lon)
   * @param {Number} st - sidereal time at Greenwich at time of observation.
   * @returns {Equatorial} (right ascension, declination)
   */
  toEquatorial(g2, st) {
    const [sA, cA] = base_default.sincos(this.az);
    const [sh, ch] = base_default.sincos(this.alt);
    const [sφ, cφ] = base_default.sincos(g2.lat);
    const H = Math.atan2(sA, cA * sφ + sh / ch * cφ);
    const ra = base_default.pmod(new sexagesimal_default.Time(st).rad() - g2.lon - H, 2 * Math.PI);
    const dec = Math.asin(sφ * sh - cφ * ch * cA);
    return new Equatorial(ra, dec);
  }
};
var Galactic = class {
  constructor(lon = 0, lat = 0) {
    this.lon = lon;
    this.lat = lat;
  }
  /**
   * GalToEq converts galactic coordinates to equatorial coordinates.
   *
   * Resulting equatorial coordinates will be referred to the standard equinox of
   * B1950.0.  For subsequent conversion to other epochs, see package precess and
   * utility functions in package meeus.
   *
   * @returns {Equatorial} (right ascension, declination)
   */
  toEquatorial() {
    const [sdLon, cdLon] = base_default.sincos(this.lon - galactic0Lon1950 - Math.PI / 2);
    const [sgδ, cgδ] = base_default.sincos(galacticNorth1950.dec);
    const [sb, cb] = base_default.sincos(this.lat);
    const y = Math.atan2(sdLon, cdLon * sgδ - sb / cb * cgδ);
    const ra = base_default.pmod(y + galacticNorth1950.ra - Math.PI, 2 * Math.PI);
    const dec = Math.asin(sb * sgδ + cb * cgδ * cdLon);
    return new Equatorial(ra, dec);
  }
};
var galacticNorth = new Equatorial(
  new sexagesimal_default.RA(12, 49, 0).rad(),
  27.4 * Math.PI / 180
);
var galacticNorth1950 = galacticNorth;
var galacticLon0 = 33 * Math.PI / 180;
var galactic0Lon1950 = galacticLon0;
var coord_default = {
  Ecliptic,
  Equatorial,
  Horizontal,
  Galactic,
  galacticNorth,
  galacticNorth1950,
  galacticLon0,
  galactic0Lon1950
};

// node_modules/astronomia/src/nutation.js
function nutation(jde) {
  const T = base_default.J2000Century(jde);
  const D = base_default.horner(
    T,
    297.85036,
    445267.11148,
    -19142e-7,
    1 / 189474
  ) * Math.PI / 180;
  const M = base_default.horner(
    T,
    357.52772,
    35999.05034,
    -1603e-7,
    -1 / 3e5
  ) * Math.PI / 180;
  const N = base_default.horner(
    T,
    134.96298,
    477198.867398,
    86972e-7,
    1 / 56250
  ) * Math.PI / 180;
  const F = base_default.horner(
    T,
    93.27191,
    483202.017538,
    -36825e-7,
    1 / 327270
  ) * Math.PI / 180;
  const Ω = base_default.horner(
    T,
    125.04452,
    -1934.136261,
    20708e-7,
    1 / 45e4
  ) * Math.PI / 180;
  let Δψ = 0;
  let Δε = 0;
  for (let i = table22A.length - 1; i >= 0; i--) {
    const row = table22A[i];
    const arg = row.d * D + row.m * M + row.n * N + row.f * F + row.ω * Ω;
    const [s2, c3] = base_default.sincos(arg);
    Δψ += s2 * (row.s0 + row.s1 * T);
    Δε += c3 * (row.c0 + row.c1 * T);
  }
  Δψ *= 1e-4 / 3600 * (Math.PI / 180);
  Δε *= 1e-4 / 3600 * (Math.PI / 180);
  return [Δψ, Δε];
}
function approxNutation(jde) {
  const T = (jde - base_default.J2000) / 36525;
  const Ω = (125.04452 - 1934.136261 * T) * Math.PI / 180;
  const L2 = (280.4665 + 36000.7698 * T) * Math.PI / 180;
  const N = (218.3165 + 481267.8813 * T) * Math.PI / 180;
  const [sΩ, cΩ] = base_default.sincos(Ω);
  const [s2L, c2L] = base_default.sincos(2 * L2);
  const [s2N, c2N] = base_default.sincos(2 * N);
  const [s2Ω, c2Ω] = base_default.sincos(2 * Ω);
  const Δψ = (-17.2 * sΩ - 1.32 * s2L - 0.23 * s2N + 0.21 * s2Ω) / 3600 * (Math.PI / 180);
  const Δε = (9.2 * cΩ + 0.57 * c2L + 0.1 * c2N - 0.09 * c2Ω) / 3600 * (Math.PI / 180);
  return [Δψ, Δε];
}
function meanObliquity(jde) {
  return base_default.horner(
    base_default.J2000Century(jde),
    new sexagesimal_default.Angle(false, 23, 26, 21.448).rad(),
    -46.815 / 3600 * (Math.PI / 180),
    -59e-5 / 3600 * (Math.PI / 180),
    1813e-6 / 3600 * (Math.PI / 180)
  );
}
function meanObliquityLaskar(jde) {
  return base_default.horner(
    base_default.J2000Century(jde) * 0.01,
    new sexagesimal_default.Angle(false, 23, 26, 21.448).rad(),
    -4680.93 / 3600 * (Math.PI / 180),
    -1.55 / 3600 * (Math.PI / 180),
    1999.25 / 3600 * (Math.PI / 180),
    -51.38 / 3600 * (Math.PI / 180),
    -249.67 / 3600 * (Math.PI / 180),
    -39.05 / 3600 * (Math.PI / 180),
    7.12 / 3600 * (Math.PI / 180),
    27.87 / 3600 * (Math.PI / 180),
    5.79 / 3600 * (Math.PI / 180),
    2.45 / 3600 * (Math.PI / 180)
  );
}
function nutationInRA(jde) {
  const [Δψ, Δε] = nutation(jde);
  const ε0 = meanObliquity(jde);
  return Δψ * Math.cos(ε0 + Δε);
}
var table22A = function() {
  const PROPS = "d,m,n,f,ω,s0,s1,c0,c1".split(",");
  const tab = [
    [0, 0, 0, 0, 1, -171996, -174.2, 92025, 8.9],
    [-2, 0, 0, 2, 2, -13187, -1.6, 5736, -3.1],
    [0, 0, 0, 2, 2, -2274, -0.2, 977, -0.5],
    [0, 0, 0, 0, 2, 2062, 0.2, -895, 0.5],
    [0, 1, 0, 0, 0, 1426, -3.4, 54, -0.1],
    [0, 0, 1, 0, 0, 712, 0.1, -7, 0],
    [-2, 1, 0, 2, 2, -517, 1.2, 224, -0.6],
    [0, 0, 0, 2, 1, -386, -0.4, 200, 0],
    [0, 0, 1, 2, 2, -301, 0, 129, -0.1],
    [-2, -1, 0, 2, 2, 217, -0.5, -95, 0.3],
    [-2, 0, 1, 0, 0, -158, 0, 0, 0],
    [-2, 0, 0, 2, 1, 129, 0.1, -70, 0],
    [0, 0, -1, 2, 2, 123, 0, -53, 0],
    [2, 0, 0, 0, 0, 63, 0, 0, 0],
    [0, 0, 1, 0, 1, 63, 0.1, -33, 0],
    [2, 0, -1, 2, 2, -59, 0, 26, 0],
    [0, 0, -1, 0, 1, -58, -0.1, 32, 0],
    [0, 0, 1, 2, 1, -51, 0, 27, 0],
    [-2, 0, 2, 0, 0, 48, 0, 0, 0],
    [0, 0, -2, 2, 1, 46, 0, -24, 0],
    [2, 0, 0, 2, 2, -38, 0, 16, 0],
    [0, 0, 2, 2, 2, -31, 0, 13, 0],
    [0, 0, 2, 0, 0, 29, 0, 0, 0],
    [-2, 0, 1, 2, 2, 29, 0, -12, 0],
    [0, 0, 0, 2, 0, 26, 0, 0, 0],
    [-2, 0, 0, 2, 0, -22, 0, 0, 0],
    [0, 0, -1, 2, 1, 21, 0, -10, 0],
    [0, 2, 0, 0, 0, 17, -0.1, 0, 0],
    [2, 0, -1, 0, 1, 16, 0, -8, 0],
    [-2, 2, 0, 2, 2, -16, 0.1, 7, 0],
    [0, 1, 0, 0, 1, -15, 0, 9, 0],
    [-2, 0, 1, 0, 1, -13, 0, 7, 0],
    [0, -1, 0, 0, 1, -12, 0, 6, 0],
    [0, 0, 2, -2, 0, 11, 0, 0, 0],
    [2, 0, -1, 2, 1, -10, 0, 5, 0],
    [2, 0, 1, 2, 2, -8, 0, 3, 0],
    [0, 1, 0, 2, 2, 7, 0, -3, 0],
    [-2, 1, 1, 0, 0, -7, 0, 0, 0],
    [0, -1, 0, 2, 2, -7, 0, 3, 0],
    [2, 0, 0, 2, 1, -7, 0, 3, 0],
    [2, 0, 1, 0, 0, 6, 0, 0, 0],
    [-2, 0, 2, 2, 2, 6, 0, -3, 0],
    [-2, 0, 1, 2, 1, 6, 0, -3, 0],
    [2, 0, -2, 0, 1, -6, 0, 3, 0],
    [2, 0, 0, 0, 1, -6, 0, 3, 0],
    [0, -1, 1, 0, 0, 5, 0, 0, 0],
    [-2, -1, 0, 2, 1, -5, 0, 3, 0],
    [-2, 0, 0, 0, 1, -5, 0, 3, 0],
    [0, 0, 2, 2, 1, -5, 0, 3, 0],
    [-2, 0, 2, 0, 1, 4, 0, 0, 0],
    [-2, 1, 0, 2, 1, 4, 0, 0, 0],
    [0, 0, 1, -2, 0, 4, 0, 0, 0],
    [-1, 0, 1, 0, 0, -4, 0, 0, 0],
    [-2, 1, 0, 0, 0, -4, 0, 0, 0],
    [1, 0, 0, 0, 0, -4, 0, 0, 0],
    [0, 0, 1, 2, 0, 3, 0, 0, 0],
    [0, 0, -2, 2, 2, -3, 0, 0, 0],
    [-1, -1, 1, 0, 0, -3, 0, 0, 0],
    [0, 1, 1, 0, 0, -3, 0, 0, 0],
    [0, -1, 1, 2, 2, -3, 0, 0, 0],
    [2, -1, -1, 2, 2, -3, 0, 0, 0],
    [0, 0, 3, 2, 2, -3, 0, 0, 0],
    [2, -1, 0, 2, 2, -3, 0, 0, 0]
  ];
  return tab.map((row) => {
    const o = {};
    PROPS.forEach((p2, i) => {
      o[p2] = row[i];
    });
    return o;
  });
}();
var nutation_default = {
  nutation,
  approxNutation,
  meanObliquity,
  meanObliquityLaskar,
  nutationInRA
};

// node_modules/astronomia/src/elementequinox.js
var Elements = class {
  constructor(inc2, node5, peri) {
    if (typeof inc2 === "object") {
      node5 = inc2.pode;
      peri = inc2.peri;
      inc2 = inc2.inc;
    }
    this.inc = inc2 || 0;
    this.node = node5 || 0;
    this.peri = peri || 0;
  }
};
var S = 1139788e-10;
var C = 0.9999999935;
function reduceB1950ToJ2000(eFrom) {
  const W = eFrom.node - 174.298782 * Math.PI / 180;
  const [si, ci] = base_default.sincos(eFrom.inc);
  const [sW, cW] = base_default.sincos(W);
  const A = si * sW;
  const B = C * si * cW - S * ci;
  const eTo = new Elements();
  eTo.inc = Math.asin(Math.hypot(A, B));
  eTo.node = base_default.pmod(
    174.997194 * Math.PI / 180 + Math.atan2(A, B),
    2 * Math.PI
  );
  eTo.peri = base_default.pmod(
    eFrom.peri + Math.atan2(-S * sW, C * si - S * ci * cW),
    2 * Math.PI
  );
  return eTo;
}
var Lp = 4.50001688 * Math.PI / 180;
var L = 5.19856209 * Math.PI / 180;
var J = 651966e-8 * Math.PI / 180;
function reduceB1950FK4ToJ2000FK5(eFrom) {
  const W = L + eFrom.node;
  const [si, ci] = base_default.sincos(eFrom.inc);
  const [sJ, cJ] = base_default.sincos(J);
  const [sW, cW] = base_default.sincos(W);
  const eTo = new Elements();
  eTo.inc = Math.acos(ci * cJ - si * sJ * cW);
  eTo.node = base_default.pmod(
    Math.atan2(si * sW, ci * sJ + si * cJ * cW) - Lp,
    2 * Math.PI
  );
  eTo.peri = base_default.pmod(
    eFrom.peri + Math.atan2(sJ * sW, si * cJ + ci * sJ * cW),
    2 * Math.PI
  );
  return eTo;
}
var elementequinox_default = {
  Elements,
  reduceB1950ToJ2000,
  reduceB1950FK4ToJ2000FK5
};

// node_modules/astronomia/src/precess.js
function approxAnnualPrecession(eqFrom, epochFrom, epochTo) {
  const [m3, na, nd] = mn(epochFrom, epochTo);
  const [sa, ca] = base_default.sincos(eqFrom.ra);
  const Δαs = m3 + na * sa * Math.tan(eqFrom.dec);
  const Δδs = nd * ca;
  const ra = new HourAngle(false, 0, 0, Δαs).rad();
  const dec = new Angle(false, 0, 0, Δδs).rad();
  return { ra, dec };
}
function mn(epochFrom, epochTo) {
  const T = (epochTo - epochFrom) * 0.01;
  const m3 = 3.07496 + 186e-5 * T;
  const na = 1.33621 - 57e-5 * T;
  const nd = 20.0431 - 85e-4 * T;
  return [m3, na, nd];
}
function approxPosition(eqFrom, epochFrom, epochTo, mα, mδ) {
  const { ra, dec } = approxAnnualPrecession(eqFrom, epochFrom, epochTo);
  const dy = epochTo - epochFrom;
  const eqTo = new Equatorial();
  eqTo.ra = eqFrom.ra + (ra + mα) * dy;
  eqTo.dec = eqFrom.dec + (dec + mδ) * dy;
  return eqTo;
}
var d = Math.PI / 180;
var s = d / 3600;
var ζT = [2306.2181 * s, 1.39656 * s, -139e-6 * s];
var zT = [2306.2181 * s, 1.39656 * s, -139e-6 * s];
var θT = [2004.3109 * s, -0.8533 * s, -217e-6 * s];
var ζt = [2306.2181 * s, 0.30188 * s, 0.017998 * s];
var zt = [2306.2181 * s, 1.09468 * s, 0.018203 * s];
var θt = [2004.3109 * s, -0.42665 * s, -0.041833 * s];
var Precessor = class {
  /**
   * constructs a Precessor object and initializes it to precess
   * coordinates from epochFrom to epochTo.
   * @param {Number} epochFrom
   * @param {Number} epochTo
   */
  constructor(epochFrom, epochTo) {
    let ζCoeff = ζt;
    let zCoeff = zt;
    let θCoeff = θt;
    if (epochFrom !== 2e3) {
      const T = (epochFrom - 2e3) * 0.01;
      ζCoeff = [
        base_default.horner(T, ...ζT),
        0.30188 * s - 344e-6 * s * T,
        0.017998 * s
      ];
      zCoeff = [
        base_default.horner(T, ...zT),
        1.09468 * s + 66e-6 * s * T,
        0.018203 * s
      ];
      θCoeff = [
        base_default.horner(T, ...θT),
        -0.42665 * s - 217e-6 * s * T,
        -0.041833 * s
      ];
    }
    const t = (epochTo - epochFrom) * 0.01;
    this.ζ = base_default.horner(t, ...ζCoeff) * t;
    this.z = base_default.horner(t, ...zCoeff) * t;
    const θ = base_default.horner(t, ...θCoeff) * t;
    this.sθ = Math.sin(θ);
    this.cθ = Math.cos(θ);
  }
  /**
   * Precess precesses coordinates eqFrom, leaving result in eqTo.
   *
   * @param {Equatorial} eqFrom
   * @returns {Equatorial} eqTo
   */
  precess(eqFrom) {
    const [sδ, cδ] = base_default.sincos(eqFrom.dec);
    const [sαζ, cαζ] = base_default.sincos(eqFrom.ra + this.ζ);
    const A = cδ * sαζ;
    const B = this.cθ * cδ * cαζ - this.sθ * sδ;
    const C2 = this.sθ * cδ * cαζ + this.cθ * sδ;
    const eqTo = new Equatorial();
    eqTo.ra = Math.atan2(A, B) + this.z;
    if (C2 < base_default.CosSmallAngle) {
      eqTo.dec = Math.asin(C2);
    } else {
      eqTo.dec = Math.acos(Math.hypot(A, B));
    }
    return eqTo;
  }
};
function position(eqFrom, epochFrom, epochTo, mα, mδ) {
  const p2 = new Precessor(epochFrom, epochTo);
  const t = epochTo - epochFrom;
  const eqTo = new Equatorial();
  eqTo.ra = eqFrom.ra + mα * t;
  eqTo.dec = eqFrom.dec + mδ * t;
  return p2.precess(eqTo);
}
var ηT = [47.0029 * s, -0.06603 * s, 598e-6 * s];
var πT = [174.876384 * d, 3289.4789 * s, 0.60622 * s];
var pT = [5029.0966 * s, 2.22226 * s, -42e-6 * s];
var ηt = [47.0029 * s, -0.03302 * s, 6e-5 * s];
var πt = [174.876384 * d, -869.8089 * s, 0.03536 * s];
var pt = [5029.0966 * s, 1.11113 * s, -6e-6 * s];
var EclipticPrecessor = class {
  /**
   * constructs an EclipticPrecessor object and initializes
   * it to precess coordinates from epochFrom to epochTo.
   * @param {Number} epochFrom
   * @param {Number} epochTo
   */
  constructor(epochFrom, epochTo) {
    let ηCoeff = ηt;
    let πCoeff = πt;
    let pCoeff = pt;
    if (epochFrom !== 2e3) {
      const T = (epochFrom - 2e3) * 0.01;
      ηCoeff = [
        base_default.horner(T, ...ηT),
        -0.03302 * s + 598e-6 * s * T,
        6e-5 * s
      ];
      πCoeff = [
        base_default.horner(T, ...πT),
        -869.8089 * s - 0.50491 * s * T,
        0.03536 * s
      ];
      pCoeff = [
        base_default.horner(T, ...pT),
        1.11113 * s - 42e-6 * s * T,
        -6e-6 * s
      ];
    }
    const t = (epochTo - epochFrom) * 0.01;
    this.π = base_default.horner(t, ...πCoeff);
    this.p = base_default.horner(t, ...pCoeff) * t;
    const η = base_default.horner(t, ...ηCoeff) * t;
    this.sη = Math.sin(η);
    this.cη = Math.cos(η);
  }
  /**
   * EclipticPrecess precesses coordinates eclFrom, leaving result in eclTo.
   *
   * The same struct may be used for eclFrom and eclTo.
   * EclTo is returned for convenience.
   * @param {Ecliptic} eclFrom
   * @returns {Ecliptic} [eclTo]
   */
  precess(eclFrom) {
    const [sβ, cβ] = base_default.sincos(eclFrom.lat);
    const [sd, cd] = base_default.sincos(this.π - eclFrom.lon);
    const A = this.cη * cβ * sd - this.sη * sβ;
    const B = cβ * cd;
    const C2 = this.cη * sβ + this.sη * cβ * sd;
    const eclTo = new Ecliptic(this.p + this.π - Math.atan2(A, B));
    if (C2 < base_default.CosSmallAngle) {
      eclTo.lat = Math.asin(C2);
    } else {
      eclTo.lat = Math.acos(Math.hypot(A, B));
    }
    return eclTo;
  }
  /**
   * ReduceElements reduces orbital elements of a solar system body from one
   * equinox to another.
   *
   * This function is described in chapter 24, but is located in this
   * package so it can be a method of EclipticPrecessor.
   *
   * @param {Elements} eFrom
   * @returns {Elements} eTo
   */
  reduceElements(eFrom) {
    const ψ = this.π + this.p;
    const [si, ci] = base_default.sincos(eFrom.inc);
    const [snp, cnp] = base_default.sincos(eFrom.node - this.π);
    const eTo = new Elements();
    eTo.inc = Math.acos(ci * this.cη + si * this.sη * cnp);
    eTo.node = Math.atan2(si * snp, this.cη * si * cnp - this.sη * ci) + ψ;
    eTo.peri = Math.atan2(-this.sη * snp, si * this.cη - ci * this.sη * cnp) + eFrom.peri;
    return eTo;
  }
};
function eclipticPosition(eclFrom, epochFrom, epochTo, mα, mδ) {
  const p2 = new EclipticPrecessor(epochFrom, epochTo);
  if (mα && mδ && (mα.rad() !== 0 || mδ.rad() !== 0)) {
    const { lon, lat } = properMotion(mα.rad(), mδ.rad(), epochFrom, eclFrom);
    const t = epochTo - epochFrom;
    eclFrom.lon += lon * t;
    eclFrom.lat += lat * t;
  }
  return p2.precess(eclFrom);
}
function properMotion(mα, mδ, epoch, ecl) {
  const ε = nutation_default.meanObliquity(base_default.JulianYearToJDE(epoch));
  const [εsin, εcos] = base_default.sincos(ε);
  const { ra, dec } = ecl.toEquatorial(ε);
  const [sα, cα] = base_default.sincos(ra);
  const [sδ, cδ] = base_default.sincos(dec);
  const cβ = Math.cos(ecl.lat);
  const lon = (mδ * εsin * cα + mα * cδ * (εcos * cδ + εsin * sδ * sα)) / (cβ * cβ);
  const lat = (mδ * (εcos * cδ + εsin * sδ * sα) - mα * εsin * cα * cδ) / cβ;
  return new Ecliptic(lon, lat);
}
function properMotion3D(eqFrom, epochFrom, epochTo, r, mr, mα, mδ) {
  const [sα, cα] = base_default.sincos(eqFrom.ra);
  const [sδ, cδ] = base_default.sincos(eqFrom.dec);
  const x = r * cδ * cα;
  const y = r * cδ * sα;
  const z = r * sδ;
  const mrr = mr / r;
  const zmδ = z * mδ.rad();
  const mx = x * mrr - zmδ * cα - y * mα.rad();
  const my = y * mrr - zmδ * sα + x * mα.rad();
  const mz = z * mrr + r * mδ.rad() * cδ;
  const t = epochTo - epochFrom;
  const xp = x + t * mx;
  const yp = y + t * my;
  const zp = z + t * mz;
  const eqTo = new Equatorial();
  eqTo.ra = Math.atan2(yp, xp);
  eqTo.dec = Math.atan2(zp, Math.hypot(xp, yp));
  return eqTo;
}
var precess_default = {
  approxAnnualPrecession,
  mn,
  approxPosition,
  Precessor,
  position,
  EclipticPrecessor,
  eclipticPosition,
  properMotion,
  properMotion3D
};

// node_modules/astronomia/src/planetposition.js
function sum(t, series) {
  const coeffs = [];
  Object.keys(series).forEach((x) => {
    coeffs[x] = 0;
    let y = series[x].length - 1;
    for (y; y >= 0; y--) {
      const term = {
        a: series[x][y][0],
        b: series[x][y][1],
        c: series[x][y][2]
      };
      coeffs[x] += term.a * Math.cos(term.b + term.c * t);
    }
  });
  const res = base_default.horner(t, ...coeffs);
  return res;
}
var Planet = class {
  /**
   * VSOP87 representation of a Planet
   * @constructs Planet
   * @param {object} planet - planet data series
   * @example
   * ```js
   * // for use in browser
   * import {data} from 'astronomia'
   * const earth = new planetposition.Planet(data.vsop87Bearth)
   * ```
   */
  constructor(planet) {
    if (typeof planet !== "object") throw new TypeError("need planet vsop87 data");
    this.name = planet.name;
    this.type = planet.type || "B";
    this.series = planet;
  }
  /**
   * Position2000 returns ecliptic position of planets by full VSOP87 theory.
   *
   * @param {Number} jde - the date for which positions are desired.
   * @returns {Coord} Results are for the dynamical equinox and ecliptic J2000.
   *  {Number} lon - heliocentric longitude in radians.
   *  {Number} lat - heliocentric latitude in radians.
   *  {Number} range - heliocentric range in AU.
   */
  position2000(jde) {
    const T = base_default.J2000Century(jde);
    const τ = T * 0.1;
    const lon = base_default.pmod(sum(τ, this.series.L), 2 * Math.PI);
    const lat = sum(τ, this.series.B);
    const range = sum(τ, this.series.R);
    switch (this.type) {
      case "B":
        return new base_default.Coord(lon, lat, range);
      case "D": {
        const eclFrom = new coord_default.Ecliptic(lon, lat);
        const epochFrom = base_default.JDEToJulianYear(jde);
        const epochTo = 2e3;
        const eclTo = precess_default.eclipticPosition(eclFrom, epochFrom, epochTo);
        return new base_default.Coord(eclTo.lon, eclTo.lat, range);
      }
    }
  }
  /**
   * Position returns ecliptic position of planets at equinox and ecliptic of date.
   *
   * @param {Number} jde - the date for which positions are desired.
   * @returns {Coord} Results are positions consistent with those from Meeus's
   * Apendix III, that is, at equinox and ecliptic of date.
   *  {Number} lon - heliocentric longitude in radians.
   *  {Number} lat - heliocentric latitude in radians.
   *  {Number} range - heliocentric range in AU.
   */
  position(jde) {
    const T = base_default.J2000Century(jde);
    const τ = T * 0.1;
    const lon = base_default.pmod(sum(τ, this.series.L), 2 * Math.PI);
    const lat = sum(τ, this.series.B);
    const range = sum(τ, this.series.R);
    switch (this.type) {
      case "B": {
        const eclFrom = new coord_default.Ecliptic(lon, lat);
        const epochFrom = 2e3;
        const epochTo = base_default.JDEToJulianYear(jde);
        const eclTo = precess_default.eclipticPosition(eclFrom, epochFrom, epochTo);
        return new base_default.Coord(eclTo.lon, eclTo.lat, range);
      }
      case "D":
        return new base_default.Coord(lon, lat, range);
    }
  }
};
function toFK5(lon, lat, jde) {
  const T = base_default.J2000Century(jde);
  const Lp2 = lon - sexagesimal_default.angleFromDeg((1.397 + 31e-5 * T) * T);
  const [sLp, cLp] = base_default.sincos(Lp2);
  const L5 = lon + sexagesimal_default.angleFromSec(-0.09033 + 0.03916 * (cLp + sLp) * Math.tan(lat));
  const B5 = lat + sexagesimal_default.angleFromSec(0.03916 * (cLp - sLp));
  return new base_default.Coord(L5, B5);
}
var planetposition_default = {
  Planet,
  toFK5
};

// node_modules/astronomia/src/solar.js
function trueLongitude(T) {
  const L0 = base_default.horner(T, 280.46646, 36000.76983, 3032e-7) * Math.PI / 180;
  const m3 = meanAnomaly(T);
  const C2 = (base_default.horner(T, 1.914602, -4817e-6, -14e-6) * Math.sin(m3) + (0.019993 - 101e-6 * T) * Math.sin(2 * m3) + 289e-6 * Math.sin(3 * m3)) * Math.PI / 180;
  const lon = base_default.pmod(L0 + C2, 2 * Math.PI);
  const ano = base_default.pmod(m3 + C2, 2 * Math.PI);
  return { lon, ano };
}
function meanAnomaly(T) {
  return base_default.horner(T, 357.52911, 35999.05029, -1537e-7) * Math.PI / 180;
}
function eccentricity(T) {
  return base_default.horner(T, 0.016708634, -42037e-9, -1267e-10);
}
function radius(T) {
  const { lon, ano } = trueLongitude(T);
  const e2 = eccentricity(T);
  return 1.000001018 * (1 - e2 * e2) / (1 + e2 * Math.cos(ano));
}
function apparentLongitude(T) {
  const Ω = node(T);
  const { lon, ano } = trueLongitude(T);
  return lon - 569e-5 * Math.PI / 180 - 478e-5 * Math.PI / 180 * Math.sin(Ω);
}
function node(T) {
  return 125.04 * Math.PI / 180 - 1934.136 * Math.PI / 180 * T;
}
function true2000(T) {
  let { lon, ano } = trueLongitude(T);
  lon -= 0.01397 * Math.PI / 180 * T * 100;
  return { lon, ano };
}
function trueEquatorial(jde) {
  const { lon, ano } = trueLongitude(base_default.J2000Century(jde));
  const ε = nutation_default.meanObliquity(jde);
  const [ss, cs] = base_default.sincos(lon);
  const [sε, cε] = base_default.sincos(ε);
  const ra = Math.atan2(cε * ss, cs);
  const dec = sε * ss;
  return new base_default.Coord(ra, dec);
}
function apparentEquatorial(jde) {
  const T = base_default.J2000Century(jde);
  const λ = apparentLongitude(T);
  const ε = nutation_default.meanObliquity(jde);
  const [sλ, cλ] = base_default.sincos(λ);
  const [sε, cε] = base_default.sincos(ε + 256e-5 * Math.PI / 180 * Math.cos(node(T)));
  const ra = Math.atan2(cε * sλ, cλ);
  const dec = Math.asin(sε * sλ);
  return new base_default.Coord(ra, dec);
}
function trueVSOP87(planet, jde) {
  let { lon, lat, range } = planet.position(jde);
  const s2 = lon + Math.PI;
  const λp = base_default.horner(
    base_default.J2000Century(jde),
    s2,
    -1.397 * Math.PI / 180,
    -31e-5 * Math.PI / 180
  );
  const [sλp, cλp] = base_default.sincos(λp);
  const Δβ = 0.03916 / 3600 * Math.PI / 180 * (cλp - sλp);
  lon = base_default.pmod(s2 - 0.09033 / 3600 * Math.PI / 180, 2 * Math.PI);
  lat = Δβ - lat;
  return new base_default.Coord(lon, lat, range);
}
function apparentVSOP87(planet, jde) {
  let { lon, lat, range } = trueVSOP87(planet, jde);
  const Δψ = nutation_default.nutation(jde)[0];
  const a = aberration(range);
  lon = lon + Δψ + a;
  return new base_default.Coord(lon, lat, range);
}
function apparentEquatorialVSOP87(planet, jde) {
  const { lon, lat, range } = trueVSOP87(planet, jde);
  const [Δψ, Δε] = nutation_default.nutation(jde);
  const a = aberration(range);
  const λ = lon + Δψ + a;
  const ε = nutation_default.meanObliquity(jde) + Δε;
  const { ra, dec } = new coord_default.Ecliptic(λ, lat).toEquatorial(ε);
  return new Coord(ra, dec, range);
}
function aberration(range) {
  return -20.4898 / 3600 * Math.PI / 180 / range;
}
var solar_default = {
  trueLongitude,
  true: trueLongitude,
  // BACKWARDS-COMPATIBILITY
  meanAnomaly,
  eccentricity,
  radius,
  apparentLongitude,
  true2000,
  trueEquatorial,
  apparentEquatorial,
  trueVSOP87,
  apparentVSOP87,
  apparentEquatorialVSOP87,
  aberration
};

// node_modules/astronomia/src/apparent.js
var { cos: cos2, tan: tan2 } = Math;
function nutation2(α, δ, jd) {
  const ε = nutation_default.meanObliquity(jd);
  const [sinε, cosε] = base_default.sincos(ε);
  const [Δψ, Δε] = nutation_default.nutation(jd);
  const [sinα, cosα] = base_default.sincos(α);
  const tanδ = tan2(δ);
  const Δα1 = (cosε + sinε * sinα * tanδ) * Δψ - cosα * tanδ * Δε;
  const Δδ1 = sinε * cosα * Δψ + sinα * Δε;
  return [Δα1, Δδ1];
}
var κ = 20.49552 * Math.PI / 180 / 3600;
function perihelion(T) {
  return base_default.horner(T, 102.93735, 1.71946, 46e-5) * Math.PI / 180;
}
function eclipticAberration(λ, β, jd) {
  const T = base_default.J2000Century(jd);
  const { lon, ano } = solar_default.trueLongitude(T);
  const e2 = solar_default.eccentricity(T);
  const π = perihelion(T);
  const [sβ, cβ] = base_default.sincos(β);
  const [ssλ, csλ] = base_default.sincos(lon - λ);
  const [sinπλ, cosπλ] = base_default.sincos(π - λ);
  const Δλ = κ * (e2 * cosπλ - csλ) / cβ;
  const Δβ = -κ * sβ * (ssλ - e2 * sinπλ);
  return [Δλ, Δβ];
}
function aberration2(α, δ, jd) {
  const ε = nutation_default.meanObliquity(jd);
  const T = base_default.J2000Century(jd);
  const { lon, ano } = solar_default.trueLongitude(T);
  const e2 = solar_default.eccentricity(T);
  const π = perihelion(T);
  const [sinα, cosα] = base_default.sincos(α);
  const [sinδ, cosδ] = base_default.sincos(δ);
  const [sins, coss] = base_default.sincos(lon);
  const [sinπ, cosπ] = base_default.sincos(π);
  const cosε = cos2(ε);
  const q1 = cosα * cosε;
  const Δα2 = κ * (e2 * (q1 * cosπ + sinα * sinπ) - (q1 * coss + sinα * sins)) / cosδ;
  const q2 = cosε * (tan2(ε) * cosδ - sinα * sinδ);
  const q3 = cosα * sinδ;
  const Δδ2 = κ * (e2 * (cosπ * q2 + sinπ * q3) - (coss * q2 + sins * q3));
  return [Δα2, Δδ2];
}
function position2(eqFrom, epochFrom, epochTo, mα, mδ) {
  const eqTo = precess_default.position(eqFrom, epochFrom, epochTo, mα, mδ);
  const jd = base_default.JulianYearToJDE(epochTo);
  const [Δα1, Δδ1] = nutation2(eqTo.ra, eqTo.dec, jd);
  const [Δα2, Δδ2] = aberration2(eqTo.ra, eqTo.dec, jd);
  eqTo.ra += Δα1 + Δα2;
  eqTo.dec += Δδ1 + Δδ2;
  return eqTo;
}
function aberrationRonVondrak(α, δ, jd) {
  const T = base_default.J2000Century(jd);
  const r = {
    T,
    L2: 3.1761467 + 1021.3285546 * T,
    L3: 1.7534703 + 628.3075849 * T,
    L4: 6.2034809 + 334.0612431 * T,
    L5: 0.5995465 + 52.9690965 * T,
    L6: 0.8740168 + 21.3299095 * T,
    L7: 5.4812939 + 7.4781599 * T,
    L8: 5.3118863 + 3.8133036 * T,
    Lp: 3.8103444 + 8399.6847337 * T,
    D: 5.1984667 + 7771.3771486 * T,
    Mp: 2.3555559 + 8328.6914289 * T,
    F: 1.6279052 + 8433.4661601 * T
  };
  let Xp = 0;
  let Yp = 0;
  let Zp = 0;
  for (let i = 35; i >= 0; i--) {
    const [x, y, z] = rvTerm[i](r);
    Xp += x;
    Yp += y;
    Zp += z;
  }
  const [sinα, cosα] = base_default.sincos(α);
  const [sinδ, cosδ] = base_default.sincos(δ);
  return [(Yp * cosα - Xp * sinα) / (c * cosδ), -((Xp * cosα + Yp * sinα) * sinδ - Zp * cosδ) / c];
}
var c = 17314463350;
var rvTerm = [
  function(r) {
    const [sinA, cosA] = base_default.sincos(r.L3);
    return [
      (-1719914 - 2 * r.T) * sinA - 25 * cosA,
      (25 - 13 * r.T) * sinA + (1578089 + 156 * r.T) * cosA,
      (10 + 32 * r.T) * sinA + (684185 - 358 * r.T) * cosA
    ];
  },
  function(r) {
    const [sinA, cosA] = base_default.sincos(2 * r.L3);
    return [
      (6434 + 141 * r.T) * sinA + (28007 - 107 * r.T) * cosA,
      (25697 - 95 * r.T) * sinA + (-5904 - 130 * r.T) * cosA,
      (11141 - 48 * r.T) * sinA + (-2559 - 55 * r.T) * cosA
    ];
  },
  function(r) {
    const [sinA, cosA] = base_default.sincos(r.L5);
    return [715 * sinA, 6 * sinA - 657 * cosA, -15 * sinA - 282 * cosA];
  },
  function(r) {
    const [sinA, cosA] = base_default.sincos(r.Lp);
    return [715 * sinA, -656 * cosA, -285 * cosA];
  },
  function(r) {
    const [sinA, cosA] = base_default.sincos(3 * r.L3);
    return [
      (486 - 5 * r.T) * sinA + (-236 - 4 * r.T) * cosA,
      (-216 - 4 * r.T) * sinA + (-446 + 5 * r.T) * cosA,
      -94 * sinA - 193 * cosA
    ];
  },
  function(r) {
    const [sinA, cosA] = base_default.sincos(r.L6);
    return [159 * sinA, 2 * sinA - 147 * cosA, -6 * sinA - 61 * cosA];
  },
  function(r) {
    const cosA = Math.cos(r.F);
    return [0, 26 * cosA, -59 * cosA];
  },
  function(r) {
    const [sinA, cosA] = base_default.sincos(r.Lp + r.Mp);
    return [39 * sinA, -36 * cosA, -16 * cosA];
  },
  function(r) {
    const [sinA, cosA] = base_default.sincos(2 * r.L5);
    return [33 * sinA - 10 * cosA, -9 * sinA - 30 * cosA, -5 * sinA - 13 * cosA];
  },
  function(r) {
    const [sinA, cosA] = base_default.sincos(2 * r.L3 - r.L5);
    return [31 * sinA + cosA, sinA - 28 * cosA, -12 * cosA];
  },
  function(r) {
    const [sinA, cosA] = base_default.sincos(3 * r.L3 - 8 * r.L4 + 3 * r.L5);
    return [8 * sinA - 28 * cosA, 25 * sinA + 8 * cosA, 11 * sinA + 3 * cosA];
  },
  function(r) {
    const [sinA, cosA] = base_default.sincos(5 * r.L3 - 8 * r.L4 + 3 * r.L5);
    return [8 * sinA - 28 * cosA, -25 * sinA - 8 * cosA, -11 * sinA + -3 * cosA];
  },
  function(r) {
    const [sinA, cosA] = base_default.sincos(2 * r.L2 - r.L3);
    return [21 * sinA, -19 * cosA, -8 * cosA];
  },
  function(r) {
    const [sinA, cosA] = base_default.sincos(r.L2);
    return [-19 * sinA, 17 * cosA, 8 * cosA];
  },
  function(r) {
    const [sinA, cosA] = base_default.sincos(r.L7);
    return [17 * sinA, -16 * cosA, -7 * cosA];
  },
  function(r) {
    const [sinA, cosA] = base_default.sincos(r.L3 - 2 * r.L5);
    return [16 * sinA, 15 * cosA, sinA + 7 * cosA];
  },
  function(r) {
    const [sinA, cosA] = base_default.sincos(r.L8);
    return [16 * sinA, sinA - 15 * cosA, -3 * sinA - 6 * cosA];
  },
  function(r) {
    const [sinA, cosA] = base_default.sincos(r.L3 + r.L5);
    return [11 * sinA - cosA, -sinA - 10 * cosA, -sinA - 5 * cosA];
  },
  function(r) {
    const [sinA, cosA] = base_default.sincos(2 * r.L2 - 2 * r.L3);
    return [-11 * cosA, -10 * sinA, -4 * sinA];
  },
  function(r) {
    const [sinA, cosA] = base_default.sincos(r.L3 - r.L5);
    return [-11 * sinA - 2 * cosA, -2 * sinA + 9 * cosA, -sinA + 4 * cosA];
  },
  function(r) {
    const [sinA, cosA] = base_default.sincos(4 * r.L3);
    return [-7 * sinA - 8 * cosA, -8 * sinA + 6 * cosA, -3 * sinA + 3 * cosA];
  },
  function(r) {
    const [sinA, cosA] = base_default.sincos(3 * r.L3 - 2 * r.L5);
    return [-10 * sinA, 9 * cosA, 4 * cosA];
  },
  function(r) {
    const [sinA, cosA] = base_default.sincos(r.L2 - 2 * r.L3);
    return [-9 * sinA, -9 * cosA, -4 * cosA];
  },
  function(r) {
    const [sinA, cosA] = base_default.sincos(2 * r.L2 - 3 * r.L3);
    return [-9 * sinA, -8 * cosA, -4 * cosA];
  },
  function(r) {
    const [sinA, cosA] = base_default.sincos(2 * r.L6);
    return [-9 * cosA, -8 * sinA, -3 * sinA];
  },
  function(r) {
    const [sinA, cosA] = base_default.sincos(2 * r.L2 - 4 * r.L3);
    return [-9 * cosA, 8 * sinA, 3 * sinA];
  },
  function(r) {
    const [sinA, cosA] = base_default.sincos(3 * r.L3 - 2 * r.L4);
    return [8 * sinA, -8 * cosA, -3 * cosA];
  },
  function(r) {
    const [sinA, cosA] = base_default.sincos(r.Lp + 2 * r.D - r.Mp);
    return [8 * sinA, -7 * cosA, -3 * cosA];
  },
  function(r) {
    const [sinA, cosA] = base_default.sincos(8 * r.L2 - 12 * r.L3);
    return [-4 * sinA - 7 * cosA, -6 * sinA + 4 * cosA, -3 * sinA + 2 * cosA];
  },
  function(r) {
    const [sinA, cosA] = base_default.sincos(8 * r.L2 - 14 * r.L3);
    return [-4 * sinA - 7 * cosA, 6 * sinA - 4 * cosA, 3 * sinA - 2 * cosA];
  },
  function(r) {
    const [sinA, cosA] = base_default.sincos(2 * r.L4);
    return [-6 * sinA - 5 * cosA, -4 * sinA + 5 * cosA, -2 * sinA + 2 * cosA];
  },
  function(r) {
    const [sinA, cosA] = base_default.sincos(3 * r.L2 - 4 * r.L3);
    return [-sinA - cosA, -2 * sinA - 7 * cosA, sinA - 4 * cosA];
  },
  function(r) {
    const [sinA, cosA] = base_default.sincos(2 * r.L3 - 2 * r.L5);
    return [4 * sinA - 6 * cosA, -5 * sinA - 4 * cosA, -2 * sinA - 2 * cosA];
  },
  function(r) {
    const [sinA, cosA] = base_default.sincos(3 * r.L2 - 3 * r.L3);
    return [-7 * cosA, -6 * sinA, -3 * sinA];
  },
  function(r) {
    const [sinA, cosA] = base_default.sincos(2 * r.L3 - 2 * r.L4);
    return [5 * sinA - 5 * cosA, -4 * sinA - 5 * cosA, -2 * sinA - 2 * cosA];
  },
  function(r) {
    const [sinA, cosA] = base_default.sincos(r.Lp - 2 * r.D);
    return [5 * sinA, -5 * cosA, -2 * cosA];
  }
];
function positionRonVondrak(eqFrom, epochTo, mα, mδ) {
  const t = epochTo - 2e3;
  let eqTo = new coord_default.Equatorial();
  eqTo.ra = eqFrom.ra + mα.rad() * t;
  eqTo.dec = eqFrom.dec + mδ.rad() * t;
  const jd = base_default.JulianYearToJDE(epochTo);
  const [Δα, Δδ] = aberrationRonVondrak(eqTo.ra, eqTo.dec, jd);
  eqTo.ra += Δα;
  eqTo.dec += Δδ;
  eqTo = precess_default.position(eqTo, 2e3, epochTo, 0, 0);
  const [Δα1, Δδ1] = nutation2(eqTo.ra, eqTo.dec, jd);
  eqTo.ra += Δα1;
  eqTo.dec += Δδ1;
  return eqTo;
}
var apparent_default = {
  nutation: nutation2,
  perihelion,
  eclipticAberration,
  aberration: aberration2,
  position: position2,
  aberrationRonVondrak,
  positionRonVondrak
};

// node_modules/astronomia/src/apsis.js
var { sin: sin2, cos: cos3 } = Math;
var ck = 1 / 1325.55;
var D2R = Math.PI / 180;
var EARTH_RADIUS = 6378.137;
var MOON_RADIUS = 1738.1;
var mean = function(T) {
  return base_default.horner(
    T,
    24515346698e-4,
    27.55454989 / ck,
    -6691e-7,
    -1098e-9,
    52e-10
  );
};
var snap = function(y, h) {
  const k3 = (y - 1999.97) * 13.2555;
  return Math.floor(k3 - h + 0.5) + h;
};
function meanPerigee(year) {
  return mean(snap(year, 0) * ck);
}
function perigee(year) {
  const l = new La(year, 0);
  return mean(l.T) + l.perigeeCorr();
}
function meanApogee(year) {
  return mean(snap(year, 0.5) * ck);
}
function apogee(year) {
  const l = new La(year, 0.5);
  return mean(l.T) + l.apogeeCorr();
}
function apogeeParallax(year) {
  return new La(year, 0.5).apogeeParallax();
}
function perigeeParallax(year) {
  return new La(year, 0).perigeeParallax();
}
function distance(parallax2) {
  return EARTH_RADIUS / sin2(parallax2);
}
var La = class {
  constructor(y, h) {
    this.k = snap(y, h);
    this.T = this.k * ck;
    this.D = base_default.horner(
      this.T,
      171.9179 * D2R,
      335.9106046 * D2R / ck,
      -0.0100383 * D2R,
      -1156e-8 * D2R,
      55e-9 * D2R
    );
    this.M = base_default.horner(
      this.T,
      347.3477 * D2R,
      27.1577721 * D2R / ck,
      -813e-6 * D2R,
      -1e-6 * D2R
    );
    this.F = base_default.horner(
      this.T,
      316.6109 * D2R,
      364.5287911 * D2R / ck,
      -0.0125053 * D2R,
      -148e-7 * D2R
    );
    return this;
  }
  /**
   * perigee correction
   */
  perigeeCorr() {
    const l = this;
    return -1.6769 * sin2(2 * l.D) + 0.4589 * sin2(4 * l.D) + -0.1856 * sin2(6 * l.D) + 0.0883 * sin2(8 * l.D) + (-0.0773 + 19e-5 * l.T) * sin2(2 * l.D - l.M) + (0.0502 - 13e-5 * l.T) * sin2(l.M) + -0.046 * sin2(10 * l.D) + (0.0422 - 11e-5 * l.T) * sin2(4 * l.D - l.M) + -0.0256 * sin2(6 * l.D - l.M) + 0.0253 * sin2(12 * l.D) + 0.0237 * sin2(l.D) + 0.0162 * sin2(8 * l.D - l.M) + -0.0145 * sin2(14 * l.D) + 0.0129 * sin2(2 * l.F) + -0.0112 * sin2(3 * l.D) + -0.0104 * sin2(10 * l.D - l.M) + 86e-4 * sin2(16 * l.D) + 69e-4 * sin2(12 * l.D - l.M) + 66e-4 * sin2(5 * l.D) + -53e-4 * sin2(2 * (l.D + l.F)) + -52e-4 * sin2(18 * l.D) + -46e-4 * sin2(14 * l.D - l.M) + -41e-4 * sin2(7 * l.D) + 4e-3 * sin2(2 * l.D + l.M) + 32e-4 * sin2(20 * l.D) + -32e-4 * sin2(l.D + l.M) + 31e-4 * sin2(16 * l.D - l.M) + -29e-4 * sin2(4 * l.D + l.M) + 27e-4 * sin2(9 * l.D) + 27e-4 * sin2(4 * l.D + 2 * l.F) + -27e-4 * sin2(2 * (l.D - l.M)) + 24e-4 * sin2(4 * l.D - 2 * l.M) + -21e-4 * sin2(6 * l.D - 2 * l.M) + -21e-4 * sin2(22 * l.D) + -21e-4 * sin2(18 * l.D - l.M) + 19e-4 * sin2(6 * l.D + l.M) + -18e-4 * sin2(11 * l.D) + -14e-4 * sin2(8 * l.D + l.M) + -14e-4 * sin2(4 * l.D - 2 * l.F) + -14e-4 * sin2(6 * l.D + 2 * l.F) + 14e-4 * sin2(3 * l.D + l.M) + -14e-4 * sin2(5 * l.D + l.M) + 13e-4 * sin2(13 * l.D) + 13e-4 * sin2(20 * l.D - l.M) + 11e-4 * sin2(3 * l.D + 2 * l.M) + -11e-4 * sin2(2 * (2 * l.D + l.F - l.M)) + -1e-3 * sin2(l.D + 2 * l.M) + -9e-4 * sin2(22 * l.D - l.M) + -8e-4 * sin2(4 * l.F) + 8e-4 * sin2(6 * l.D - 2 * l.F) + 8e-4 * sin2(2 * (l.D - l.F) + l.M) + 7e-4 * sin2(2 * l.M) + 7e-4 * sin2(2 * l.F - l.M) + 7e-4 * sin2(2 * l.D + 4 * l.F) + -6e-4 * sin2(2 * (l.F - l.M)) + -6e-4 * sin2(2 * (l.D - l.F + l.M)) + 6e-4 * sin2(24 * l.D) + 5e-4 * sin2(4 * (l.D - l.F)) + 5e-4 * sin2(2 * (l.D + l.M)) + -4e-4 * sin2(l.D - l.M);
  }
  /**
   * apogee correction
   */
  apogeeCorr() {
    const l = this;
    return 0.4392 * sin2(2 * l.D) + 0.0684 * sin2(4 * l.D) + (0.0456 - 11e-5 * l.T) * sin2(l.M) + (0.0426 - 11e-5 * l.T) * sin2(2 * l.D - l.M) + 0.0212 * sin2(2 * l.F) + -0.0189 * sin2(l.D) + 0.0144 * sin2(6 * l.D) + 0.0113 * sin2(4 * l.D - l.M) + 47e-4 * sin2(2 * (l.D + l.F)) + 36e-4 * sin2(l.D + l.M) + 35e-4 * sin2(8 * l.D) + 34e-4 * sin2(6 * l.D - l.M) + -34e-4 * sin2(2 * (l.D - l.F)) + 22e-4 * sin2(2 * (l.D - l.M)) + -17e-4 * sin2(3 * l.D) + 13e-4 * sin2(4 * l.D + 2 * l.F) + 11e-4 * sin2(8 * l.D - l.M) + 1e-3 * sin2(4 * l.D - 2 * l.M) + 9e-4 * sin2(10 * l.D) + 7e-4 * sin2(3 * l.D + l.M) + 6e-4 * sin2(2 * l.M) + 5e-4 * sin2(2 * l.D + l.M) + 5e-4 * sin2(2 * (l.D + l.M)) + 4e-4 * sin2(6 * l.D + 2 * l.F) + 4e-4 * sin2(6 * l.D - 2 * l.M) + 4e-4 * sin2(10 * l.D - l.M) + -4e-4 * sin2(5 * l.D) + -4e-4 * sin2(4 * l.D - 2 * l.F) + 3e-4 * sin2(2 * l.F + l.M) + 3e-4 * sin2(12 * l.D) + 3e-4 * sin2(2 * l.D + 2 * l.F - l.M) + -3e-4 * sin2(l.D - l.M);
  }
  /**
   * apogee parallax
   */
  apogeeParallax() {
    const s2 = Math.PI / 180 / 3600;
    const l = this;
    return 3245.251 * s2 + -9.147 * s2 * cos3(2 * l.D) + -0.841 * s2 * cos3(l.D) + 0.697 * s2 * cos3(2 * l.F) + (-0.656 * s2 + 16e-4 * s2 * l.T) * cos3(l.M) + 0.355 * s2 * cos3(4 * l.D) + 0.159 * s2 * cos3(2 * l.D - l.M) + 0.127 * s2 * cos3(l.D + l.M) + 0.065 * s2 * cos3(4 * l.D - l.M) + 0.052 * s2 * cos3(6 * l.D) + 0.043 * s2 * cos3(2 * l.D + l.M) + 0.031 * s2 * cos3(2 * (l.D + l.F)) + -0.023 * s2 * cos3(2 * (l.D - l.F)) + 0.022 * s2 * cos3(2 * (l.D - l.M)) + 0.019 * s2 * cos3(2 * (l.D + l.M)) + -0.016 * s2 * cos3(2 * l.M) + 0.014 * s2 * cos3(6 * l.D - l.M) + 0.01 * s2 * cos3(8 * l.D);
  }
  /**
   * perigee parallax
   */
  perigeeParallax() {
    const s2 = Math.PI / 180 / 3600;
    const l = this;
    return 3629.215 * s2 + 63.224 * s2 * cos3(2 * l.D) + -6.99 * s2 * cos3(4 * l.D) + (2.834 * s2 - 71e-4 * l.T * s2) * cos3(2 * l.D - l.M) + 1.927 * s2 * cos3(6 * l.D) + -1.263 * s2 * cos3(l.D) + -0.702 * s2 * cos3(8 * l.D) + (0.696 * s2 - 17e-4 * l.T * s2) * cos3(l.M) + -0.69 * s2 * cos3(2 * l.F) + (-0.629 * s2 + 16e-4 * l.T * s2) * cos3(4 * l.D - l.M) + -0.392 * s2 * cos3(2 * (l.D - l.F)) + 0.297 * s2 * cos3(10 * l.D) + 0.26 * s2 * cos3(6 * l.D - l.M) + 0.201 * s2 * cos3(3 * l.D) + -0.161 * s2 * cos3(2 * l.D + l.M) + 0.157 * s2 * cos3(l.D + l.M) + -0.138 * s2 * cos3(12 * l.D) + -0.127 * s2 * cos3(8 * l.D - l.M) + 0.104 * s2 * cos3(2 * (l.D + l.F)) + 0.104 * s2 * cos3(2 * (l.D - l.M)) + -0.079 * s2 * cos3(5 * l.D) + 0.068 * s2 * cos3(14 * l.D) + 0.067 * s2 * cos3(10 * l.D - l.M) + 0.054 * s2 * cos3(4 * l.D + l.M) + -0.038 * s2 * cos3(12 * l.D - l.M) + -0.038 * s2 * cos3(4 * l.D - 2 * l.M) + 0.037 * s2 * cos3(7 * l.D) + -0.037 * s2 * cos3(4 * l.D + 2 * l.F) + -0.035 * s2 * cos3(16 * l.D) + -0.03 * s2 * cos3(3 * l.D + l.M) + 0.029 * s2 * cos3(l.D - l.M) + -0.025 * s2 * cos3(6 * l.D + l.M) + 0.023 * s2 * cos3(2 * l.M) + 0.023 * s2 * cos3(14 * l.D - l.M) + -0.023 * s2 * cos3(2 * (l.D + l.M)) + 0.022 * s2 * cos3(6 * l.D - 2 * l.M) + -0.021 * s2 * cos3(2 * l.D - 2 * l.F - l.M) + -0.02 * s2 * cos3(9 * l.D) + 0.019 * s2 * cos3(18 * l.D) + 0.017 * s2 * cos3(6 * l.D + 2 * l.F) + 0.014 * s2 * cos3(2 * l.F - l.M) + -0.014 * s2 * cos3(16 * l.D - l.M) + 0.013 * s2 * cos3(4 * l.D - 2 * l.F) + 0.012 * s2 * cos3(8 * l.D + l.M) + 0.011 * s2 * cos3(11 * l.D) + 0.01 * s2 * cos3(5 * l.D + l.M) + -0.01 * s2 * cos3(20 * l.D);
  }
};
var apsis_default = {
  EARTH_RADIUS,
  MOON_RADIUS,
  meanPerigee,
  perigee,
  meanApogee,
  apogee,
  apogeeParallax,
  perigeeParallax,
  distance
};

// node_modules/astronomia/src/binary.js
var { atan, atan2: atan22, cos: cos4, sqrt: sqrt2, tan: tan3 } = Math;
function meanAnomaly2(year, T, P) {
  const n = 2 * Math.PI / P;
  return base_default.pmod(n * (year - T), 2 * Math.PI);
}
function position3(a, e2, i, Ω, ω, E) {
  const r = a * (1 - e2 * cos4(E));
  const ν = 2 * atan(sqrt2((1 + e2) / (1 - e2)) * tan3(E / 2));
  const [sinνω, cosνω] = base_default.sincos(ν + ω);
  const cosi = cos4(i);
  const num = sinνω * cosi;
  let θ = atan22(num, cosνω) + Ω;
  if (θ < 0) {
    θ += 2 * Math.PI;
  }
  const ρ = r * sqrt2(num * num + cosνω * cosνω);
  return [θ, ρ];
}
function apparentEccentricity(e2, i, ω) {
  const cosi = cos4(i);
  const [sinω, cosω] = base_default.sincos(ω);
  const A = (1 - e2 * e2 * cosω * cosω) * cosi * cosi;
  const B = e2 * e2 * sinω * cosω * cosi;
  const C2 = 1 - e2 * e2 * sinω * sinω;
  const d3 = A - C2;
  const sqrtD = sqrt2(d3 * d3 + 4 * B * B);
  return sqrt2(2 * sqrtD / (A + C2 + sqrtD));
}
var binary_default = {
  meanAnomaly: meanAnomaly2,
  position: position3,
  apparentEccentricity
};

// node_modules/astronomia/src/conjunction.js
function planetary(t1, t5, cs1, cs2) {
  if (cs1.length !== 5 || cs2.length !== 5) {
    throw new Error("Five rows required in ephemerides");
  }
  const dr = new Array(5);
  const dd = new Array(5);
  cs1.forEach((r, i) => {
    dr[i] = cs2[i].ra - cs1[i].ra;
    dd[i] = cs2[i].dec - cs1[i].dec;
  });
  return conj(t1, t5, dr, dd);
}
function stellar(t1, t5, c1, cs2) {
  if (cs2.length !== 5) {
    throw new Error("Five rows required in ephemerides");
  }
  const dr = new Array(5);
  const dd = new Array(5);
  cs2.forEach((r, i) => {
    dr[i] = cs2[i].ra - c1.ra;
    dd[i] = cs2[i].dec - c1.dec;
  });
  return conj(t1, t5, dr, dd);
}
var conj = function(t1, t5, dr, dd) {
  let l5 = new interpolation_default.Len5(t1, t5, dr);
  const t = l5.zero(true);
  l5 = new interpolation_default.Len5(t1, t5, dd);
  const Δd = l5.interpolateXStrict(t);
  return [t, Δd];
};
var conjunction_default = {
  planetary,
  stellar
};

// node_modules/astronomia/src/circle.js
function smallest(c1, c22, c3) {
  const cd1 = Math.cos(c1.dec);
  const cd2 = Math.cos(c22.dec);
  const cd3 = Math.cos(c3.dec);
  let a = 2 * Math.asin(Math.sqrt(hav2(c22.dec - c1.dec) + cd1 * cd2 * hav2(c22.ra - c1.ra)));
  let b = 2 * Math.asin(Math.sqrt(hav2(c3.dec - c22.dec) + cd2 * cd3 * hav2(c3.ra - c22.ra)));
  let c4 = 2 * Math.asin(Math.sqrt(hav2(c1.dec - c3.dec) + cd3 * cd1 * hav2(c1.ra - c3.ra)));
  if (b > a) {
    [a, b] = noswap(b, a);
  }
  if (c4 > a) {
    [a, c4] = noswap(c4, a);
  }
  if (a * a >= b * b + c4 * c4) {
    return [a, true];
  }
  return [2 * a * b * c4 / Math.sqrt((a + b + c4) * (a + b - c4) * (b + c4 - a) * (a + c4 - b)), false];
}
var noswap = function(a, b) {
  return [a, b];
};
var hav2 = function(a) {
  return 0.5 * (1 - Math.cos(a));
};
var circle_default = {
  smallest
};

// node_modules/astronomia/data/deltat.js
var m = {
  historic: {
    table: [44, 43, 43, 41, 40, 39, 38, 37, 37, 36, 36, 36, 37, 37, 38, 37, 36, 36, 35, 35, 34, 33, 33, 32, 32, 31, 31, 30, 30, 29, 29, 29, 29, 29, 28, 28, 27, 27, 26, 26, 25, 25, 25, 26, 26, 26, 26, 25, 25, 25, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 23, 23, 23, 23, 22, 22, 22, 22, 22, 21, 21, 21, 21, 21, 21, 21, 21, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 20, 20, 20, 20, 20, 19, 19, 19, 19, 19, 20, 20, 20, 20, 19, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21.1, 21, 21, 21, 20.9, 20.8, 20.7, 20.6, 20.4, 20.2, 20, 19.7, 19.4, 19.1, 18.7, 18.3, 17.8, 17.4, 17, 16.8, 16.6, 16.4, 16.1, 15.9, 15.7, 15.5, 15.3, 15, 14.7, 14.5, 14.3, 14.2, 14.1, 14.1, 14.1, 13.9, 13.7, 13.6, 13.5, 13.5, 13.5, 13.5, 13.4, 13.4, 13.4, 13.4, 13.3, 13.3, 13.2, 13.2, 13.2, 13.1, 13.1, 13.1, 13, 13.2, 13.3, 13.4, 13.5, 13.6, 13.7, 13.8, 13.9, 14, 14, 14.1, 14.1, 14.1, 14.1, 14.2, 14.3, 14.4, 14.4, 14.5, 14.6, 14.6, 14.7, 14.7, 14.7, 14.8, 14.8, 14.9, 14.9, 15, 15, 15.1, 15.2, 15.3, 15.4, 15.5, 15.6, 15.6, 15.6, 15.8, 15.9, 15.9, 15.9, 15.8, 15.7, 15.8, 15.7, 15.7, 15.7, 15.8, 15.9, 16.1, 16.1, 16, 15.9, 15.9, 15.7, 15.4, 15.3, 15.4, 15.5, 15.6, 15.6, 15.6, 15.6, 15.6, 15.6, 15.6, 15.5, 15.5, 15.4, 15.3, 15.2, 15.1, 14.9, 14.8, 14.6, 14.4, 14.3, 14.2, 14.1, 14.2, 14.2, 13.9, 13.7, 13.5, 13.3, 13.1, 13, 13.2, 13.2, 13.1, 13.1, 13.2, 13.3, 13.5, 13.5, 13.4, 13.2, 13.2, 13.1, 13.1, 13, 12.8, 12.6, 12.7, 12.6, 12.3, 12, 11.9, 11.8, 11.6, 11.4, 11.2, 11.1, 11.1, 11.1, 11.1, 11.1, 11.2, 11.1, 11.1, 11.2, 11.4, 11.5, 11.3, 11.2, 11.4, 11.7, 11.9, 11.9, 11.9, 11.8, 11.7, 11.8, 11.8, 11.8, 11.7, 11.6, 11.6, 11.5, 11.5, 11.4, 11.4, 11.3, 11.3, 11.13, 11.16, 10.94, 10.72, 10.29, 10.04, 9.94, 9.91, 9.88, 9.86, 9.72, 9.67, 9.66, 9.64, 9.51, 9.4, 9.21, 9, 8.6, 8.29, 7.95, 7.73, 7.59, 7.49, 7.36, 7.26, 7.1, 7, 6.89, 6.82, 6.73, 6.64, 6.39, 6.28, 6.25, 6.27, 6.25, 6.27, 6.22, 6.24, 6.22, 6.27, 6.3, 6.36, 6.35, 6.37, 6.32, 6.33, 6.33, 6.37, 6.37, 6.41, 6.4, 6.44, 6.46, 6.51, 6.48, 6.51, 6.53, 6.58, 6.55, 6.61, 6.69, 6.8, 6.84, 6.94, 7.03, 7.13, 7.15, 7.22, 7.26, 7.3, 7.23, 7.22, 7.21, 7.2, 6.99, 6.98, 7.19, 7.36, 7.35, 7.39, 7.41, 7.45, 7.36, 7.18, 6.95, 6.72, 6.45, 6.24, 5.92, 5.59, 5.15, 4.67, 4.11, 3.52, 2.94, 2.47, 1.97, 1.52, 1.04, 0.6, 0.11, -0.34, -0.82, -1.25, -1.7, -2.08, -2.48, -2.82, -3.19, -3.5, -3.84, -4.14, -4.43, -4.59, -4.79, -4.92, -5.09, -5.24, -5.36, -5.34, -5.37, -5.32, -5.34, -5.33, -5.4, -5.47, -5.58, -5.66, -5.74, -5.68, -5.69, -5.65, -5.67, -5.68, -5.73, -5.72, -5.78, -5.79, -5.86, -5.89, -6.01, -6.13, -6.28, -6.41, -6.53, -6.49, -6.5, -6.45, -6.41, -6.26, -6.11, -5.9, -5.63, -5.13, -4.68, -4.19, -3.72, -3.21, -2.7, -2.09, -1.48, -0.75, -0.08, 0.62, 1.26, 1.95, 2.59, 3.28, 3.92, 4.61, 5.2, 5.73, 6.29, 7, 7.68, 8.45, 9.13, 9.78, 10.38, 10.99, 11.64, 12.47, 13.23, 14, 14.69, 15.38, 16, 16.64, 17.19, 17.72, 18.19, 18.67, 19.13, 19.69, 20.14, 20.54, 20.86, 21.14, 21.41, 21.78, 22.06, 22.3, 22.51, 22.79, 23.01, 23.29, 23.46, 23.55, 23.63, 23.8, 23.95, 24.25, 24.39, 24.42, 24.34, 24.22, 24.1, 24.08, 24.02, 24.04, 23.98, 23.91, 23.89, 23.95, 23.93, 23.92, 23.88, 23.94, 23.91, 23.82, 23.76, 23.87, 23.91, 23.95, 23.96, 24, 24.04, 24.2, 24.35, 24.61, 24.82, 25.09, 25.3, 25.56, 25.77, 26.05, 26.27, 26.54, 26.76, 27.04, 27.27, 27.55, 27.77, 28.03, 28.25, 28.5, 28.7, 28.95, 29.15, 29.38, 29.57, 29.8, 29.97, 30.19, 30.36, 30.57, 30.72, 30.93, 31.07, 31.24, 31.349, 31.516, 31.677, 31.923, 32.166, 32.449, 32.671, 32.919, 33.15, 33.397, 33.584, 33.804, 33.992, 34.24, 34.466, 34.731, 35.03, 35.4, 35.738, 36.147, 36.546, 36.995, 37.429, 37.879, 38.291, 38.753, 39.204, 39.707, 40.182, 40.706, 41.17, 41.686, 42.227, 42.825, 43.373, 43.959, 44.486, 44.997, 45.477, 45.983, 46.458, 46.997, 47.521, 48.034, 48.535, 49.099, 49.589, 50.102, 50.54, 50.975, 51.382, 51.81, 52.168, 52.572, 52.957, 53.434, 53.789, 54.087],
    first: 1657,
    last: 1984.5
  },
  data: {
    table: [43.4724372, 43.5648351, 43.6736863, 43.7782156, 43.8763273, 43.9562443, 44.0314956, 44.1131788, 44.1982187, 44.2951747, 44.3936471, 44.4840562, 44.5646335, 44.6425099, 44.7385767, 44.8370135, 44.9302138, 44.9986146, 45.0583549, 45.1283911, 45.2063835, 45.2980068, 45.3897017, 45.476138, 45.5632485, 45.6450189, 45.7374593, 45.8283721, 45.9132976, 45.9819705, 46.0407484, 46.1067084, 46.1825041, 46.2788561, 46.3713351, 46.4567207, 46.544486, 46.6310899, 46.7302231, 46.8283588, 46.9247443, 46.9969757, 47.0709148, 47.1450515, 47.2361542, 47.3413241, 47.4319364, 47.5213815, 47.6049313, 47.6837388, 47.7781381, 47.8770756, 47.9687104, 48.0348257, 48.0942021, 48.1608205, 48.2460028, 48.3438529, 48.4355405, 48.5344163, 48.6324506, 48.7293718, 48.8365414, 48.9353232, 49.0318781, 49.1013205, 49.1590844, 49.2285534, 49.3069683, 49.4017939, 49.4945263, 49.5861495, 49.6804907, 49.7602264, 49.8555805, 49.9489224, 50.0346777, 50.1018531, 50.1621723, 50.2260014, 50.2967905, 50.3831254, 50.4598772, 50.5387068, 50.6160484, 50.6865941, 50.7658362, 50.8453698, 50.918672, 50.9761148, 51.0278017, 51.084323, 51.1537928, 51.2318645, 51.306308, 51.3807849, 51.4526292, 51.5160394, 51.5985479, 51.680924, 51.7572854, 51.8133335, 51.8532385, 51.9014358, 51.9603433, 52.0328072, 52.0984957, 52.1667826, 52.2316418, 52.2938376, 52.3679897, 52.4465221, 52.5179552, 52.5751485, 52.6178012, 52.666816, 52.7340036, 52.8055792, 52.8792189, 52.9564838, 53.0444971, 53.126769, 53.2196749, 53.3024139, 53.3746645, 53.4335399, 53.4778015, 53.5299937, 53.5845392, 53.6522628, 53.7255844, 53.7882418, 53.8366625, 53.8829665, 53.9442904, 54.0042478, 54.0536342, 54.085644, 54.1084122, 54.1462942, 54.1913988, 54.2452023, 54.2957622, 54.3427024, 54.3910864, 54.4319877, 54.4897699, 54.545636, 54.597741, 54.6354962, 54.6532352, 54.677594, 54.7173643, 54.7740957, 54.8253023, 54.8712512, 54.916146, 54.9580535, 54.9997186, 55.047571, 55.0911778, 55.1132386, 55.132774, 55.1532423, 55.1898003, 55.2415531, 55.283803, 55.3222105, 55.3612676, 55.406262, 55.4628719, 55.5110909, 55.5523777, 55.5811877, 55.6004372, 55.626202, 55.6656271, 55.7167999, 55.7698097, 55.8196609, 55.8615028, 55.9129883, 55.9663474, 56.0220102, 56.0700015, 56.0939035, 56.110463, 56.1313736, 56.1610839, 56.2068432, 56.2582503, 56.3000349, 56.339902, 56.3789995, 56.4282839, 56.4803947, 56.5352164, 56.5697487, 56.5983102, 56.6328326, 56.6738814, 56.7332116, 56.7971596, 56.8552701, 56.9111378, 56.9754725, 57.0470772, 57.1136128, 57.173831, 57.2226068, 57.259731, 57.3072742, 57.3643368, 57.4334281, 57.5015747, 57.5653127, 57.6333396, 57.6972844, 57.7710774, 57.8407427, 57.9057801, 57.9575663, 57.9974929, 58.0425517, 58.1043319, 58.1679128, 58.2389092, 58.3091659, 58.3833021, 58.4536748, 58.5401438, 58.6227714, 58.6916662, 58.7409628, 58.7836189, 58.8405543, 58.898579, 58.9713678, 59.043837, 59.1218414, 59.2002687, 59.274737, 59.3574134, 59.4433827, 59.5242416, 59.5849787, 59.6343497, 59.6927827, 59.758805, 59.8386448, 59.9110567, 59.9844537, 60.056435, 60.123065, 60.2042185, 60.2803745, 60.3530352, 60.4011891, 60.4439959, 60.4900257, 60.5578054, 60.6324446, 60.7058569, 60.7853482, 60.8663504, 60.9386672, 61.0276757, 61.1103448, 61.1870458, 61.2453891, 61.2881024, 61.3377799, 61.4036165, 61.4760366, 61.5524599, 61.6286593, 61.6845819, 61.743306, 61.8132425, 61.8823203, 61.9496762, 61.9968743, 62.0342938, 62.0714108, 62.1202315, 62.1809508, 62.2382046, 62.2950486, 62.3506479, 62.3995381, 62.475395, 62.5463091, 62.6136031, 62.6570739, 62.6941742, 62.7383271, 62.7926305, 62.8566986, 62.9145607, 62.9658689, 63.0216632, 63.0807052, 63.1461718, 63.2052946, 63.2599441, 63.2844088, 63.2961369, 63.3126092, 63.3421622, 63.3871303, 63.4339302, 63.4673369, 63.4978642, 63.5319327, 63.5679441, 63.6104432, 63.6444291, 63.6641815, 63.6739403, 63.692603, 63.7147066, 63.7518055, 63.792717, 63.8285221, 63.8556871, 63.8803854, 63.9075025, 63.9392787, 63.9690744, 63.9798604, 63.9833077, 63.9938011, 64.0093384, 64.0399621, 64.0670429, 64.0907881, 64.1068077, 64.1282125, 64.1584211, 64.1832722, 64.2093975, 64.2116628, 64.2073173, 64.2115565, 64.2222858, 64.2499625, 64.2760973, 64.2998037, 64.3191858, 64.345013, 64.3734584, 64.3943291, 64.4151156, 64.4132064, 64.4118464, 64.4096536, 64.4167832, 64.43292, 64.4510529, 64.4734276, 64.4893377, 64.5053342, 64.5269189, 64.5470942, 64.5596729, 64.5512293, 64.5370906, 64.5359472, 64.5414947, 64.5543634, 64.5654298, 64.5736111, 64.5891142, 64.6014759, 64.6176147, 64.6374397, 64.6548674, 64.6530021, 64.6379271, 64.637161, 64.6399614, 64.6543152, 64.6723164, 64.6876311, 64.7051905, 64.7313433, 64.7575312, 64.7811143, 64.8000929, 64.7994561, 64.7876424, 64.783095, 64.7920604, 64.8096421, 64.8310888, 64.8451826, 64.8597013, 64.8849929, 64.9174991, 64.9480298, 64.9793881, 64.9894772, 65.0028155, 65.0138193, 65.0371432, 65.0772597, 65.112197, 65.1464034, 65.1832638, 65.2145358, 65.2493713, 65.2920645, 65.3279403, 65.3413366, 65.3451881, 65.34964, 65.3711307, 65.3971998, 65.4295547, 65.4573487, 65.486752, 65.5152012, 65.5449916, 65.5780768, 65.612728, 65.6287505, 65.6370091, 65.6493375, 65.6759928, 65.7096966, 65.746092, 65.7768362, 65.8024614, 65.8236695, 65.8595036, 65.8973008, 65.932291, 65.950911, 65.9534105, 65.962833, 65.9838647, 66.0146733, 66.042049, 66.0699217, 66.0961343, 66.1310116, 66.1682713, 66.2071627, 66.2355846, 66.2408549, 66.2335423, 66.2349107, 66.2441095, 66.2751123, 66.3054334, 66.3245568, 66.3405713, 66.3624433, 66.3957101, 66.428903, 66.4618675, 66.4748837, 66.4751281, 66.4828678, 66.5056165, 66.5382912, 66.5705628, 66.6030198, 66.6339689, 66.6569117, 66.6925011, 66.7288729, 66.7578719, 66.7707625, 66.7740427, 66.7846288, 66.810324, 66.840048, 66.8778601, 66.9069091, 66.944259, 66.9762508, 67.0258126, 67.0716286, 67.1100184, 67.1266401, 67.1331391, 67.145797, 67.17174, 67.2091069, 67.2459812, 67.2810383, 67.3136452, 67.3456968, 67.389003, 67.4318433, 67.4666209, 67.4858459, 67.4989147, 67.5110936, 67.5352658, 67.571103, 67.6070253, 67.6439167, 67.6765272, 67.7116693, 67.7590634, 67.8011542, 67.840213, 67.8606318, 67.8821576, 67.9120101, 67.9546462, 68.0054839, 68.051412, 68.1024205, 68.1577127, 68.2043653, 68.2664507, 68.3188171, 68.3703564, 68.3964356, 68.4094472, 68.4304611, 68.4629791, 68.507818, 68.5537018, 68.5927179, 68.6298107, 68.6670627, 68.7135208, 68.7622755, 68.8032843, 68.8244838, 68.8373427, 68.847693, 68.8688567, 68.9005814, 68.9354999, 68.9676423, 68.9875354, 69.0175527, 69.0499081, 69.0823433, 69.1070034, 69.1134027, 69.1141898, 69.1207203, 69.1355578, 69.16459, 69.1964228, 69.2201632, 69.2451564, 69.2732758, 69.3031979, 69.3325675, 69.3540507, 69.3581722, 69.3441594, 69.3376329, 69.3377424, 69.3432191, 69.3540144, 69.3611554, 69.3751703, 69.3889904, 69.4091639, 69.4264662, 69.4386335, 69.4241335, 69.3921241, 69.3693422, 69.3574782, 69.3593242, 69.3630244, 69.359334, 69.3510133, 69.3537917, 69.3582217, 69.367306, 69.3678649, 69.3514228, 69.3273414, 69.3033273, 69.2892463, 69.2880419, 69.2908014, 69.2944974, 69.2913953, 69.286149, 69.2835153, 69.2815422, 69.2806375, 69.2553511, 69.2125426, 69.1847287, 69.17207, 69.1691531, 69.173303, 69.1698064, 69.1589095, 69.1556275, 69.1672253, 69.1771384],
    first: 1973.0849315068492,
    firstYM: [1973, 2],
    last: 2023.3287671232877,
    lastYM: [2023, 5]
  },
  prediction: {
    table: [67.87818, 67.96817999999999, 68.02817999999999, 68.04818, 68.12818, 68.21817999999999, 68.26818, 68.28818, 68.36818, 68.44818, 68.50818, 68.51818, 68.59818, 68.68818, 68.73818, 68.74817999999999, 68.82818, 68.91817999999999, 68.96817999999999, 68.98818, 69.06818, 69.14818, 69.20818, 69.22818, 69.30818, 69.39818, 69.46817999999999, 69.48818, 69.57818, 69.66817999999999, 69.73818, 69.75818, 69.85817999999999, 69.95818, 70.02817999999999, 70.05818, 70.15818, 70.25818, 70.33818, 70.36818, 70.46817999999999],
    first: 2022,
    last: 2032
  }
};
var deltat_default = m;

// node_modules/astronomia/src/deltat.js
function LeapYearGregorian(y) {
  return y % 4 === 0 && y % 100 !== 0 || y % 400 === 0;
}
function deltaT(dyear) {
  let ΔT;
  if (dyear < -500) {
    ΔT = base_default.horner((dyear - 1820) * 0.01, -20, 0, 32);
  } else if (dyear < 500) {
    ΔT = base_default.horner(
      dyear * 0.01,
      10583.6,
      -1014.41,
      33.78311,
      -5.952053,
      -0.1798452,
      0.022174192,
      0.0090316521
    );
  } else if (dyear < 1600) {
    ΔT = base_default.horner(
      (dyear - 1e3) * 0.01,
      1574.2,
      -556.01,
      71.23472,
      0.319781,
      -0.8503463,
      -5050998e-9,
      0.0083572073
    );
  } else if (dyear < deltat_default.historic.first) {
    ΔT = base_default.horner(dyear - 1600, 120, -0.9808, -0.01532, 1 / 7129);
  } else if (dyear < deltat_default.data.first) {
    ΔT = interpolate(dyear, deltat_default.historic);
  } else if (dyear < deltat_default.data.last - 0.25) {
    ΔT = interpolateData(dyear, deltat_default.data);
  } else if (dyear < deltat_default.prediction.last) {
    ΔT = interpolate(dyear, deltat_default.prediction);
  } else if (dyear < 2050) {
    ΔT = base_default.horner((dyear - 2e3) / 100, 62.92, 32.217, 55.89);
  } else if (dyear < 2150) {
    ΔT = base_default.horner((dyear - 1820) / 100, -205.72, 56.28, 32);
  } else {
    const u = (dyear - 1820) / 100;
    ΔT = -20 + 32 * u * u;
  }
  return ΔT;
}
function interpolate(dyear, data) {
  const d3 = interpolation_default.len3ForInterpolateX(
    dyear,
    data.first,
    data.last,
    data.table
  );
  return d3.interpolateX(dyear);
}
function interpolateData(dyear, data) {
  const [fyear, fmonth] = data.firstYM;
  const { year, month, first: first2, last: last2 } = monthOfYear(dyear);
  const pos = 12 * (year - fyear) + (month - fmonth);
  const table = data.table.slice(pos, pos + 3);
  const d3 = new interpolation_default.Len3(first2, last2, table);
  return d3.interpolateX(dyear);
}
function monthOfYear(dyear) {
  const year = dyear | 0;
  const f = dyear - year;
  const d3 = LeapYearGregorian(year) ? 1 : 0;
  const data = monthOfYear.data[d3];
  let month = 12;
  while (month > 0 && data[month] > f) {
    month--;
  }
  const first2 = year + data[month];
  const last2 = month < 11 ? year + data[month + 2] : year + 1 + data[(month + 2) % 12];
  return { year, month, first: first2, last: last2 };
}
monthOfYear.data = [
  [
    // non leap year
    0,
    0,
    0.08493150684921602,
    0.16164383561635987,
    0.24657534246580326,
    0.3287671232876619,
    0.4136986301368779,
    0.4958904109589639,
    0.5808219178081799,
    0.6657534246576233,
    0.747945205479482,
    0.832876712328698,
    0.915068493150784
  ],
  [
    // leap year
    0,
    0,
    0.08743169398917416,
    0.1639344262296163,
    0.24863387978143692,
    0.3306010928961314,
    0.4153005464481794,
    0.49726775956287383,
    0.5819672131146945,
    0.6666666666667425,
    0.7486338797814369,
    0.8333333333332575,
    0.9153005464481794
  ]
];
var deltat_default2 = {
  deltaT
};

// node_modules/astronomia/src/iterate.js
function decimalPlaces(better, start, places, maxIterations) {
  const d3 = Math.pow(10, -places);
  for (let i = 0; i < maxIterations; i++) {
    const n = better(start);
    if (Math.abs(n - start) < d3) {
      return n;
    }
    start = n;
  }
  throw new Error("Maximum iterations reached");
}
function fullPrecision(better, start, maxIterations) {
  for (let i = 0; i < maxIterations; i++) {
    const n = better(start);
    if (Math.abs((n - start) / n) < 1e-15) {
      return n;
    }
    start = n;
  }
  throw new Error("Maximum iterations reached");
}
function binaryRoot(f, lower, upper) {
  let yLower = f(lower);
  let mid = 0;
  for (let j = 0; j < 52; j++) {
    mid = (lower + upper) / 2;
    const yMid = f(mid);
    if (yMid === 0) {
      break;
    }
    if (signbit(yLower) === signbit(yMid)) {
      lower = mid;
      yLower = yMid;
    } else {
      upper = mid;
    }
  }
  return mid;
}
function signbit(v) {
  return v < 0;
}
var iterate_default = {
  decimalPlaces,
  fullPrecision,
  binaryRoot
};

// node_modules/astronomia/src/kepler.js
function trueAnomaly(E, e2) {
  return 2 * Math.atan(Math.sqrt((1 + e2) / (1 - e2)) * Math.tan(E * 0.5));
}
function radius2(E, e2, a) {
  return a * (1 - e2 * Math.cos(E));
}
function kepler1(e2, m3, places) {
  const f = function(E0) {
    return m3 + e2 * Math.sin(E0);
  };
  return iterate_default.decimalPlaces(f, m3, places, places * 5);
}
function kepler2(e2, m3, places) {
  const f = function(E0) {
    const [se, ce] = base_default.sincos(E0);
    return E0 + (m3 + e2 * se - E0) / (1 - e2 * ce);
  };
  return iterate_default.decimalPlaces(f, m3, places, places);
}
function kepler2a(e2, m3, places) {
  const f = function(E0) {
    const [se, ce] = base_default.sincos(E0);
    return E0 + Math.asin(Math.sin((m3 + e2 * se - E0) / (1 - e2 * ce)));
  };
  return iterate_default.decimalPlaces(f, m3, places, places * 5);
}
function kepler2b(e2, m3, places) {
  const f = function(E0) {
    const [se, ce] = base_default.sincos(E0);
    let d3 = (m3 + e2 * se - E0) / (1 - e2 * ce);
    if (d3 > 0.5) {
      d3 = 0.5;
    } else if (d3 < -0.5) {
      d3 = -0.5;
    }
    return E0 + d3;
  };
  return iterate_default.decimalPlaces(f, m3, places, places);
}
function kepler3(e2, m3) {
  m3 = base_default.pmod(m3, 2 * Math.PI);
  let f = 1;
  if (m3 > Math.PI) {
    f = -1;
    m3 = 2 * Math.PI - m3;
  }
  let E0 = Math.PI * 0.5;
  let d3 = Math.PI * 0.25;
  for (let i = 0; i < 53; i++) {
    const M1 = E0 - e2 * Math.sin(E0);
    if (m3 - M1 < 0) {
      E0 -= d3;
    } else {
      E0 += d3;
    }
    d3 *= 0.5;
  }
  if (f < 0) {
    return -E0;
  }
  return E0;
}
function kepler4(e2, m3) {
  const [sm, cm] = base_default.sincos(m3);
  return Math.atan2(sm, cm - e2);
}
var kepler_default = {
  trueAnomaly,
  true: trueAnomaly,
  // BACKWARDS-COMPATIBILITY
  radius: radius2,
  kepler1,
  kepler2,
  kepler2a,
  kepler2b,
  kepler3,
  kepler4
};

// node_modules/astronomia/src/solarxyz.js
function position4(earth3, jde) {
  const { lon, lat, range } = solar_default.trueVSOP87(earth3, jde);
  const [sε, cε] = base_default.sincos(nutation_default.meanObliquity(jde));
  const [ss, cs] = base_default.sincos(lon);
  const sβ = Math.sin(lat);
  const x = range * cs;
  const y = range * (ss * cε - sβ * sε);
  const z = range * (ss * sε + sβ * cε);
  return { x, y, z };
}
function longitudeJ2000(earth3, jde) {
  const lon = earth3.position2000(jde).lon;
  return base_default.pmod(lon + Math.PI - 0.09033 / 3600 * Math.PI / 180, 2 * Math.PI);
}
function positionJ2000(earth3, jde) {
  const { x, y, z } = xyz(earth3, jde);
  return {
    x: x + 44036e-11 * y - 190919e-12 * z,
    y: -479966e-12 * x + 0.917482137087 * y - 0.397776982902 * z,
    z: 0.397776982902 * y + 0.917482137087 * z
  };
}
function xyz(earth3, jde) {
  const { lon, lat, range } = earth3.position2000(jde);
  const s2 = lon + Math.PI;
  const β = -lat;
  const [ss, cs] = base_default.sincos(s2);
  const [sβ, cβ] = base_default.sincos(β);
  const x = range * cβ * cs;
  const y = range * cβ * ss;
  const z = range * sβ;
  return { x, y, z };
}
function positionB1950(earth3, jde) {
  const { x, y, z } = xyz(earth3, jde);
  return {
    x: 0.999925702634 * x + 0.012189716217 * y + 11134016e-12 * z,
    y: -0.011179418036 * x + 0.917413998946 * y - 0.397777041885 * z,
    z: -0.004859003787 * x + 0.397747363646 * y + 0.917482111428 * z
  };
}
var ζt2 = [2306.2181, 0.30188, 0.017998];
var zt2 = [2306.2181, 1.09468, 0.018203];
var θt2 = [2004.3109, -0.42665, -0.041833];
function positionEquinox(earth3, jde, epoch) {
  const xyz2 = positionJ2000(earth3, jde);
  const x0 = xyz2.x;
  const y0 = xyz2.y;
  const z0 = xyz2.z;
  const t = (epoch - 2e3) * 0.01;
  const ζ = base_default.horner(t, ζt2) * t * Math.PI / 180 / 3600;
  const z = base_default.horner(t, zt2) * t * Math.PI / 180 / 3600;
  const θ = base_default.horner(t, θt2) * t * Math.PI / 180 / 3600;
  const [sζ, cζ] = base_default.sincos(ζ);
  const [sz, cz] = base_default.sincos(z);
  const [sθ, cθ] = base_default.sincos(θ);
  const xx = cζ * cz * cθ - sζ * sz;
  const xy = sζ * cz + cζ * sz * cθ;
  const xz = cζ * sθ;
  const yx = -cζ * sz - sζ * cz * cθ;
  const yy = cζ * cz - sζ * sz * cθ;
  const yz = -sζ * sθ;
  const zx = -cz * sθ;
  const zy = -sz * sθ;
  const zz = cθ;
  return {
    x: xx * x0 + yx * y0 + zx * z0,
    y: xy * x0 + yy * y0 + zy * z0,
    z: xz * x0 + yz * y0 + zz * z0
  };
}
var solarxyz_default = {
  position: position4,
  longitudeJ2000,
  positionJ2000,
  xyz,
  positionB1950,
  positionEquinox
};

// node_modules/astronomia/src/elliptic.js
function position5(planet, earth3, jde) {
  let x = 0;
  let y = 0;
  let z = 0;
  const posEarth = earth3.position(jde);
  const [L0, B0, R0] = [posEarth.lon, posEarth.lat, posEarth.range];
  const [sB0, cB0] = base_default.sincos(B0);
  const [sL0, cL0] = base_default.sincos(L0);
  function pos(τ2 = 0) {
    const pos2 = planet.position(jde - τ2);
    const [L2, B, R] = [pos2.lon, pos2.lat, pos2.range];
    const [sB, cB] = base_default.sincos(B);
    const [sL, cL] = base_default.sincos(L2);
    x = R * cB * cL - R0 * cB0 * cL0;
    y = R * cB * sL - R0 * cB0 * sL0;
    z = R * sB - R0 * sB0;
  }
  pos();
  const Δ = Math.sqrt(x * x + y * y + z * z);
  const τ = base_default.lightTime(Δ);
  pos(τ);
  let λ = Math.atan2(y, x);
  let β = Math.atan2(z, Math.hypot(x, y));
  const [Δλ, Δβ] = apparent_default.eclipticAberration(λ, β, jde);
  const fk5 = planetposition_default.toFK5(λ + Δλ, β + Δβ, jde);
  λ = fk5.lon;
  β = fk5.lat;
  const [Δψ, Δε] = nutation_default.nutation(jde);
  λ += Δψ;
  const ε = nutation_default.meanObliquity(jde) + Δε;
  return new coord_default.Ecliptic(λ, β).toEquatorial(ε);
}
var Elements2 = class {
  /*
  Axis  float64 // Semimajor axis, a, in AU
  Ecc   float64 // Eccentricity, e
  Inc   float64 // Inclination, i, in radians
  ArgP  float64 // Argument of perihelion, ω, in radians
  Node  float64 // Longitude of ascending node, Ω, in radians
  TimeP float64 // Time of perihelion, T, as jde
  */
  constructor(axis, ecc, inc2, argP, node5, timeP) {
    let o = {};
    if (typeof axis === "object") {
      o = axis;
    }
    this.axis = o.axis || axis;
    this.ecc = o.ecc || ecc;
    this.inc = o.inc || inc2;
    this.argP = o.argP || argP;
    this.node = o.node || node5;
    this.timeP = o.timeP || timeP;
  }
  /**
   * Position returns observed equatorial coordinates of a body with Keplerian elements.
   *
   * Argument e must be a valid V87Planet object for Earth.
   *
   * Results are right ascension and declination α and δ, and elongation ψ,
   * all in radians.
   */
  position(jde, earth3) {
    const n = base_default.K / this.axis / Math.sqrt(this.axis);
    const sε = base_default.SOblJ2000;
    const cε = base_default.COblJ2000;
    const [sΩ, cΩ] = base_default.sincos(this.node);
    const [si, ci] = base_default.sincos(this.inc);
    const F = cΩ;
    const G = sΩ * cε;
    const H = sΩ * sε;
    const P = -sΩ * ci;
    const Q = cΩ * ci * cε - si * sε;
    const R = cΩ * ci * sε + si * cε;
    const A = Math.atan2(F, P);
    const B = Math.atan2(G, Q);
    const C2 = Math.atan2(H, R);
    const a = Math.hypot(F, P);
    const b = Math.hypot(G, Q);
    const c3 = Math.hypot(H, R);
    const f = (jde2) => {
      const M = n * (jde2 - this.timeP);
      let E;
      try {
        E = kepler_default.kepler2b(this.ecc, M, 15);
      } catch (e2) {
        E = kepler_default.kepler3(this.ecc, M);
      }
      const ν = kepler_default.trueAnomaly(E, this.ecc);
      const r = kepler_default.radius(E, this.ecc, this.axis);
      const x = r * a * Math.sin(A + this.argP + ν);
      const y = r * b * Math.sin(B + this.argP + ν);
      const z = r * c3 * Math.sin(C2 + this.argP + ν);
      return { x, y, z };
    };
    return astrometricJ2000(f, jde, earth3);
  }
};
function astrometricJ2000(f, jde, earth3) {
  const sol = solarxyz_default.positionJ2000(earth3, jde);
  const [X, Y, Z] = [sol.x, sol.y, sol.z];
  let ξ = 0;
  let η = 0;
  let ζ = 0;
  let Δ = 0;
  function fn(τ2 = 0) {
    const { x, y, z } = f(jde - τ2);
    ξ = X + x;
    η = Y + y;
    ζ = Z + z;
    Δ = Math.sqrt(ξ * ξ + η * η + ζ * ζ);
  }
  fn();
  const τ = base_default.lightTime(Δ);
  fn(τ);
  let α = Math.atan2(η, ξ);
  if (α < 0) {
    α += 2 * Math.PI;
  }
  const δ = Math.asin(ζ / Δ);
  const R0 = Math.sqrt(X * X + Y * Y + Z * Z);
  const ψ = Math.acos((ξ * X + η * Y + ζ * Z) / R0 / Δ);
  return new base_default.Coord(α, δ, void 0, ψ);
}
function velocity(a, r) {
  return 42.1219 * Math.sqrt(1 / r - 0.5 / a);
}
function vAphelion(a, e2) {
  return 29.7847 * Math.sqrt((1 - e2) / (1 + e2) / a);
}
function vPerihelion(a, e2) {
  return 29.7847 * Math.sqrt((1 + e2) / (1 - e2) / a);
}
function length1(a, e2) {
  const b = a * Math.sqrt(1 - e2 * e2);
  return Math.PI * (3 * (a + b) - Math.sqrt((a + 3 * b) * (3 * a + b)));
}
function length2(a, e2) {
  const b = a * Math.sqrt(1 - e2 * e2);
  const s2 = a + b;
  const p2 = a * b;
  const A = s2 * 0.5;
  const G = Math.sqrt(p2);
  const H = 2 * p2 / s2;
  return Math.PI * (21 * A - 2 * G - 3 * H) * 0.125;
}
function length4(a, e2) {
  const b = a * Math.sqrt(1 - e2 * e2);
  const m3 = (a - b) / (a + b);
  const m22 = m3 * m3;
  let sum0 = 1;
  let term = m22 * 0.25;
  let sum1 = 1 + term;
  let nf = -1;
  let df = 2;
  while (sum1 !== sum0) {
    nf += 2;
    df += 2;
    term *= nf * nf * m22 / (df * df);
    sum0 = sum1;
    sum1 += term;
  }
  return 2 * Math.PI * a * sum0 / (1 + m3);
}
var elliptic_default = {
  position: position5,
  Elements: Elements2,
  astrometricJ2000,
  velocity,
  vAphelion,
  vPerihelion,
  length1,
  length2,
  // length3,
  length4
};

// node_modules/astronomia/src/moonphase.js
var { sin: sin3, cos: cos5 } = Math;
var ck2 = 1 / 1236.85;
var D2R2 = Math.PI / 180;
var meanLunarMonth = 29.530588861;
function mean2(T) {
  return base_default.horner(
    T,
    245155009766e-5,
    29.530588861 / ck2,
    15437e-8,
    -15e-8,
    73e-11
  );
}
function snap2(y, q) {
  const k3 = (y - 2e3) * 12.3685;
  return Math.floor(k3 - q + 0.5) + q;
}
function meanNew(year) {
  return mean2(snap2(year, 0) * ck2);
}
function meanFirst(year) {
  return mean2(snap2(year, 0.25) * ck2);
}
function meanFull(year) {
  return mean2(snap2(year, 0.5) * ck2);
}
function meanLast(year) {
  return mean2(snap2(year, 0.75) * ck2);
}
function newMoon(year) {
  const m3 = new Mp(year, 0);
  return mean2(m3.T) + m3.nfc(nc) + m3.a();
}
function first(year) {
  const m3 = new Mp(year, 0.25);
  return mean2(m3.T) + m3.flc() + m3.w() + m3.a();
}
function full(year) {
  const m3 = new Mp(year, 0.5);
  return mean2(m3.T) + m3.nfc(fc) + m3.a();
}
function last(year) {
  const m3 = new Mp(year, 0.75);
  return mean2(m3.T) + m3.flc() - m3.w() + m3.a();
}
var Mp = class {
  constructor(y, q) {
    this.A = new Array(14);
    const k3 = this.k = snap2(y, q);
    const T = this.T = this.k * ck2;
    this.E = base_default.horner(T, 1, -2516e-6, -74e-7);
    this.M = base_default.horner(
      T,
      2.5534 * D2R2,
      29.1053567 * D2R2 / ck2,
      -14e-7 * D2R2,
      -11e-8 * D2R2
    );
    this.M_ = base_default.horner(
      T,
      201.5643 * D2R2,
      385.81693528 * D2R2 / ck2,
      0.0107582 * D2R2,
      1238e-8 * D2R2,
      -58e-9 * D2R2
    );
    this.F = base_default.horner(
      T,
      160.7108 * D2R2,
      390.67050284 * D2R2 / ck2,
      -16118e-7 * D2R2,
      -227e-8 * D2R2,
      11e-9 * D2R2
    );
    this.Ω = base_default.horner(
      T,
      124.7746 * D2R2,
      -1.56375588 * D2R2 / ck2,
      20672e-7 * D2R2,
      215e-8 * D2R2
    );
    this.A[0] = 299.7 * D2R2 + 0.107408 * D2R2 * k3 - 9173e-6 * T * T;
    this.A[1] = 251.88 * D2R2 + 0.016321 * D2R2 * k3;
    this.A[2] = 251.83 * D2R2 + 26.651886 * D2R2 * k3;
    this.A[3] = 349.42 * D2R2 + 36.412478 * D2R2 * k3;
    this.A[4] = 84.66 * D2R2 + 18.206239 * D2R2 * k3;
    this.A[5] = 141.74 * D2R2 + 53.303771 * D2R2 * k3;
    this.A[6] = 207.17 * D2R2 + 2.453732 * D2R2 * k3;
    this.A[7] = 154.84 * D2R2 + 7.30686 * D2R2 * k3;
    this.A[8] = 34.52 * D2R2 + 27.261239 * D2R2 * k3;
    this.A[9] = 207.19 * D2R2 + 0.121824 * D2R2 * k3;
    this.A[10] = 291.34 * D2R2 + 1.844379 * D2R2 * k3;
    this.A[11] = 161.72 * D2R2 + 24.198154 * D2R2 * k3;
    this.A[12] = 239.56 * D2R2 + 25.513099 * D2R2 * k3;
    this.A[13] = 331.55 * D2R2 + 3.592518 * D2R2 * k3;
  }
  // new or full corrections
  nfc(c3) {
    const { M, M_, E, F, Ω } = this;
    return c3[0] * sin3(M_) + c3[1] * sin3(M) * E + c3[2] * sin3(2 * M_) + c3[3] * sin3(2 * F) + c3[4] * sin3(M_ - M) * E + c3[5] * sin3(M_ + M) * E + c3[6] * sin3(2 * M) * E * E + c3[7] * sin3(M_ - 2 * F) + c3[8] * sin3(M_ + 2 * F) + c3[9] * sin3(2 * M_ + M) * E + c3[10] * sin3(3 * M_) + c3[11] * sin3(M + 2 * F) * E + c3[12] * sin3(M - 2 * F) * E + c3[13] * sin3(2 * M_ - M) * E + c3[14] * sin3(Ω) + c3[15] * sin3(M_ + 2 * M) + c3[16] * sin3(2 * (M_ - F)) + c3[17] * sin3(3 * M) + c3[18] * sin3(M_ + M - 2 * F) + c3[19] * sin3(2 * (M_ + F)) + c3[20] * sin3(M_ + M + 2 * F) + c3[21] * sin3(M_ - M + 2 * F) + c3[22] * sin3(M_ - M - 2 * F) + c3[23] * sin3(3 * M_ + M) + c3[24] * sin3(4 * M_);
  }
  // first or last corrections
  flc() {
    const { M, M_, E, F, Ω } = this;
    return -0.62801 * sin3(M_) + 0.17172 * sin3(M) * E + -0.01183 * sin3(M_ + M) * E + 862e-5 * sin3(2 * M_) + 804e-5 * sin3(2 * F) + 454e-5 * sin3(M_ - M) * E + 204e-5 * sin3(2 * M) * E * E + -18e-4 * sin3(M_ - 2 * F) + -7e-4 * sin3(M_ + 2 * F) + -4e-4 * sin3(3 * M_) + -34e-5 * sin3(2 * M_ - M) * E + 32e-5 * sin3(M + 2 * F) * E + 32e-5 * sin3(M - 2 * F) * E + -28e-5 * sin3(M_ + 2 * M) * E * E + 27e-5 * sin3(2 * M_ + M) * E + -17e-5 * sin3(Ω) + -5e-5 * sin3(M_ - M - 2 * F) + 4e-5 * sin3(2 * M_ + 2 * F) + -4e-5 * sin3(M_ + M + 2 * F) + 4e-5 * sin3(M_ - 2 * M) + 3e-5 * sin3(M_ + M - 2 * F) + 3e-5 * sin3(3 * M) + 2e-5 * sin3(2 * M_ - 2 * F) + 2e-5 * sin3(M_ - M + 2 * F) + -2e-5 * sin3(3 * M_ + M);
  }
  w() {
    const { M, M_, E, F } = this;
    return 306e-5 - 38e-5 * E * cos5(M) + 26e-5 * cos5(M_) - 2e-5 * (cos5(M_ - M) - cos5(M_ + M) - cos5(2 * F));
  }
  // additional corrections
  a() {
    let a = 0;
    ac.forEach((c3, i) => {
      a += c3 * sin3(this.A[i]);
    });
    return a;
  }
};
var nc = [
  -0.4072,
  0.17241,
  0.01608,
  0.01039,
  739e-5,
  -514e-5,
  208e-5,
  -111e-5,
  -57e-5,
  56e-5,
  -42e-5,
  42e-5,
  38e-5,
  -24e-5,
  -17e-5,
  -7e-5,
  4e-5,
  4e-5,
  3e-5,
  3e-5,
  -3e-5,
  3e-5,
  -2e-5,
  -2e-5,
  2e-5
];
var fc = [
  -0.40614,
  0.17302,
  0.01614,
  0.01043,
  734e-5,
  -515e-5,
  209e-5,
  -111e-5,
  -57e-5,
  56e-5,
  -42e-5,
  42e-5,
  38e-5,
  -24e-5,
  -17e-5,
  -7e-5,
  4e-5,
  4e-5,
  3e-5,
  3e-5,
  -3e-5,
  3e-5,
  -2e-5,
  -2e-5,
  2e-5
];
var ac = [
  325e-6,
  165e-6,
  164e-6,
  126e-6,
  11e-5,
  62e-6,
  6e-5,
  56e-6,
  47e-6,
  42e-6,
  4e-5,
  37e-6,
  35e-6,
  23e-6
];
var moonphase_default = {
  meanLunarMonth,
  meanNew,
  meanFirst,
  meanFull,
  meanLast,
  newMoon,
  new: newMoon,
  // BACKWARDS-COMPATIBILITY
  first,
  full,
  last
};

// node_modules/astronomia/src/eclipse.js
var g = function(k3, jm, c1, c22) {
  const ck4 = 1 / 1236.85;
  const p2 = Math.PI / 180;
  const T = k3 * ck4;
  const F = base_default.horner(
    T,
    160.7108 * p2,
    390.67050284 * p2 / ck4,
    -16118e-7 * p2,
    -227e-8 * p2,
    11e-9 * p2
  );
  if (Math.abs(Math.sin(F)) > 0.36) {
    return [false];
  }
  const eclipse = true;
  const E = base_default.horner(T, 1, -2516e-6, -74e-7);
  const M = base_default.horner(
    T,
    2.5534 * p2,
    29.1053567 * p2 / ck4,
    -14e-7 * p2,
    -11e-8 * p2
  );
  const Mʹ = base_default.horner(
    T,
    201.5643 * p2,
    385.81693528 * p2 / ck4,
    0.0107582 * p2,
    1238e-8 * p2,
    -58e-9 * p2
  );
  const Ω = base_default.horner(
    T,
    124.7746 * p2,
    -1.56375588 * p2 / ck4,
    20672e-7 * p2,
    215e-8 * p2
  );
  const sΩ = Math.sin(Ω);
  const F1 = F - 0.02665 * p2 * sΩ;
  const A1 = base_default.horner(T, 299.77 * p2, 0.107408 * p2 / ck4, -9173e-6 * p2);
  const jdeMax = jm + c1 * Math.sin(Mʹ) + c22 * Math.sin(M) * E + 0.0161 * Math.sin(2 * Mʹ) + -97e-4 * Math.sin(2 * F1) + 73e-4 * Math.sin(Mʹ - M) * E + -5e-3 * Math.sin(Mʹ + M) * E + -23e-4 * Math.sin(Mʹ - 2 * F1) + 21e-4 * Math.sin(2 * M) * E + 12e-4 * Math.sin(Mʹ + 2 * F1) + 6e-4 * Math.sin(2 * Mʹ + M) * E + -4e-4 * Math.sin(3 * Mʹ) + -3e-4 * Math.sin(M + 2 * F1) * E + 3e-4 * Math.sin(A1) + -2e-4 * Math.sin(M - 2 * F1) * E + -2e-4 * Math.sin(2 * Mʹ - M) * E + -2e-4 * sΩ;
  const P = 0.207 * Math.sin(M) * E + 24e-4 * Math.sin(2 * M) * E + -0.0392 * Math.sin(Mʹ) + 0.0116 * Math.sin(2 * Mʹ) + -73e-4 * Math.sin(Mʹ + M) * E + 67e-4 * Math.sin(Mʹ - M) * E + 0.0118 * Math.sin(2 * F1);
  const Q = 5.2207 + -48e-4 * Math.cos(M) * E + 2e-3 * Math.cos(2 * M) * E + -0.3299 * Math.cos(Mʹ) + -6e-3 * Math.cos(Mʹ + M) * E + 41e-4 * Math.cos(Mʹ - M) * E;
  const [sF1, cF1] = base_default.sincos(F1);
  const W = Math.abs(cF1);
  const γ = (P * cF1 + Q * sF1) * (1 - 48e-4 * W);
  const u = 59e-4 + 46e-4 * Math.cos(M) * E + -0.0182 * Math.cos(Mʹ) + 4e-4 * Math.cos(2 * Mʹ) + -5e-4 * Math.cos(M + Mʹ);
  return [eclipse, jdeMax, γ, u, Mʹ];
};
var TYPE = {
  None: 0,
  Partial: 1,
  // for solar eclipses
  Annular: 2,
  // solar
  AnnularTotal: 3,
  // solar
  Penumbral: 4,
  // for lunar eclipses
  Umbral: 5,
  // lunar
  Total: 6
  // solar or lunar
};
var snap3 = function(y, q) {
  const k3 = (y - 2e3) * 12.3685;
  return Math.floor(k3 - q + 0.5) + q;
};
function solar(year) {
  let eclipseType = TYPE.None;
  let mag;
  const [e2, jdeMax, γ, u, _] = g(snap3(year, 0), moonphase_default.meanNew(year), -0.4075, 0.1721);
  const p2 = u + 0.5461;
  if (!e2) {
    return { type: eclipseType };
  }
  const aγ = Math.abs(γ);
  if (aγ > 1.5433 + u) {
    return { type: eclipseType };
  }
  const central = aγ < 0.9972;
  if (!central) {
    eclipseType = TYPE.Partial;
    if (aγ < 1.026) {
      if (aγ < 0.9972 + Math.abs(u)) {
        eclipseType = TYPE.Total;
      }
    }
  } else if (u < 0) {
    eclipseType = TYPE.Total;
  } else if (u > 47e-4) {
    eclipseType = TYPE.Annular;
  } else {
    const ω = 464e-5 * Math.sqrt(1 - γ * γ);
    if (u < ω) {
      eclipseType = TYPE.AnnularTotal;
    } else {
      eclipseType = TYPE.Annular;
    }
  }
  if (eclipseType === TYPE.Partial) {
    mag = (1.5433 + u - aγ) / (0.5461 + 2 * u);
  }
  return {
    type: eclipseType,
    central,
    jdeMax,
    magnitude: mag,
    distance: γ,
    umbral: u,
    penumbral: p2
  };
}
function lunar(year) {
  let eclipseType = TYPE.None;
  let mag;
  let sdTotal;
  let sdPartial;
  let sdPenumbral;
  const [e2, jdeMax, γ, u, Mʹ] = g(
    snap3(year, 0.5),
    moonphase_default.meanFull(year),
    -0.4065,
    0.1727
  );
  if (!e2) {
    return { type: eclipseType };
  }
  const ρ = 1.2848 + u;
  const σ = 0.7403 - u;
  const aγ = Math.abs(γ);
  mag = (1.0128 - u - aγ) / 0.545;
  if (mag > 1) {
    eclipseType = TYPE.Total;
  } else if (mag > 0) {
    eclipseType = TYPE.Umbral;
  } else {
    mag = (1.5573 + u - aγ) / 0.545;
    if (mag < 0) {
      return { type: eclipseType };
    }
    eclipseType = TYPE.Penumbral;
  }
  const p2 = 1.0128 - u;
  const t = 0.4678 - u;
  const n = 0.5458 + 0.04 * Math.cos(Mʹ);
  const γ2 = γ * γ;
  switch (eclipseType) {
    case TYPE.Total: {
      sdTotal = Math.sqrt(t * t - γ2) / n / 24;
    }
    case TYPE.Umbral: {
      sdPartial = Math.sqrt(p2 * p2 - γ2) / n / 24;
    }
    default: {
      const h = 1.5573 + u;
      sdPenumbral = Math.sqrt(h * h - γ2) / n / 24;
    }
  }
  return {
    type: eclipseType,
    jdeMax,
    magnitude: mag,
    distance: γ,
    umbral: σ,
    penumbral: ρ,
    sdTotal,
    sdPartial,
    sdPenumbral
  };
}
var eclipse_default = {
  TYPE,
  solar,
  lunar
};

// node_modules/astronomia/src/elp.js
var SEC2RAD = 1 / 3600 * Math.PI / 180;
function sum2(T, series) {
  const coeffs = [];
  Object.keys(series).forEach((x) => {
    coeffs[x] = 0;
    let y = series[x].length - 1;
    for (y; y >= 0; y--) {
      const row = series[x][y];
      const φ = base_default.horner(T, row.slice(1));
      coeffs[x] += row[0] * Math.sin(φ);
    }
  });
  return base_default.horner(T, ...coeffs);
}
var Moon = class {
  /**
   * ELP representation of a Moon
   * @constructs Moon
   * @param {object} data - elp data series
   * @example
   * ```js
   * // for use in browser
   * import {data} from 'astronomia.js'
   * const moon = new elp.Moon(data.elpMppDe)
   * ```
   */
  constructor(data) {
    if (typeof data !== "object") throw new TypeError("need Elp data");
    this.series = data;
  }
  _calcLBR(T) {
    const L2 = base_default.horner(T, this.series.W1) + sum2(T, this.series.L) * SEC2RAD;
    const B = sum2(T, this.series.B) * SEC2RAD;
    const R = sum2(T, this.series.R);
    return { L: base_default.pmod(L2, 2 * Math.PI), B, R };
  }
  /**
   * Position returns rectangular coordinates referred to the inertial mean ecliptic and equinox of J2000.
   * @param {Number} jde - Julian ephemeris day
   * @return {object} rectangular coordinates
   *   {Number} x
   *   {Number} y
   *   {Number} z
   */
  positionXYZ(jde) {
    const T = base_default.J2000Century(jde);
    const { L: L2, B, R } = this._calcLBR(T);
    const x = R * Math.cos(L2) * Math.cos(B);
    const y = R * Math.sin(L2) * Math.cos(B);
    const z = R * Math.sin(B);
    const P = base_default.horner(T, 0, 10180391e-12, 47020439e-14, -5417367e-16, -2507948e-18, 463486e-20);
    const Q = base_default.horner(T, 0, -113469002e-12, 12372674e-14, 1265417e-15, -1371808e-18, -320334e-20);
    const sq = Math.sqrt(1 - P * P - Q * Q);
    const p11 = 1 - 2 * P * P;
    const p12 = 2 * P * Q;
    const p13 = 2 * P * sq;
    const p21 = 2 * P * Q;
    const p22 = 1 - 2 * Q * Q;
    const p23 = -2 * Q * sq;
    const p31 = -2 * P * sq;
    const p32 = 2 * Q * sq;
    const p33 = 1 - 2 * P * P - 2 * Q * Q;
    const result = {
      x: p11 * x + p12 * y + p13 * z,
      y: p21 * x + p22 * y + p23 * z,
      z: p31 * x + p32 * y + p33 * z
    };
    return result;
  }
  /**
   * Delay effect of light time
   *
   * @param {Number} jde - Julian ephemeris day
   * @returns {Number} Delay time in days
   */
  lightTime(jde) {
    const T = base_default.J2000Century(jde);
    const R = sum2(T, this.series.R);
    return base_default.lightTime(R / base_default.AU);
  }
  /**
   * Position returns ecliptic position of moon at equinox and ecliptic of date.
   *
   * @param {Number} jde - the date for which positions are desired.
   * @returns {Coord} Results are positions consistent with those elp data,
   * that is, at equinox and ecliptic of date.
   *  {Number} lon - geocentric longitude in radians.
   *  {Number} lat - geocentric latitude in radians.
   *  {Number} range - geocentric range in KM.
   */
  position(jde) {
    const T = base_default.J2000Century(jde);
    const { L: L2, B, R } = this._calcLBR(T);
    const pA = base_default.horner(T, 0, 5029.0966 - 0.29965, 1.112, 77e-6, -2353e-8) * SEC2RAD;
    return new Coord(
      base_default.pmod(L2 + pA, 2 * Math.PI),
      B,
      R
    );
  }
};
function position6(elpData, jde) {
  const moon = new Moon(elpData);
  return moon.position(jde);
}
var elp_default = {
  Moon,
  position: position6
};

// node_modules/astronomia/src/eqtime.js
var { cos: cos6, sin: sin4, tan: tan4 } = Math;
function e(jde, earth3) {
  const τ = base_default.J2000Century(jde) * 0.1;
  const L0 = l0(τ);
  const { lon, lat, range } = solar_default.trueVSOP87(earth3, jde);
  const [Δψ, Δε] = nutation_default.nutation(jde);
  const a = -20.4898 / 3600 * Math.PI / 180 / range;
  const λ = lon + Δψ + a;
  const ε = nutation_default.meanObliquity(jde) + Δε;
  const eq3 = new coord_default.Ecliptic(λ, lat).toEquatorial(ε);
  const E = L0 - 57183e-7 * Math.PI / 180 - eq3.ra + Δψ * cos6(ε);
  return base_default.pmod(E + Math.PI, 2 * Math.PI) - Math.PI;
}
var l0 = function(τ) {
  return base_default.horner(
    τ,
    280.4664567,
    360007.6982779,
    0.03032028,
    1 / 49931,
    -1 / 15300,
    -1 / 2e6
  ) * Math.PI / 180;
};
function eSmart(jde) {
  const ε = nutation_default.meanObliquity(jde);
  const t = tan4(ε * 0.5);
  const y = t * t;
  const T = base_default.J2000Century(jde);
  const L0 = l0(T * 0.1);
  const e2 = solar_default.eccentricity(T);
  const M = solar_default.meanAnomaly(T);
  const [sin2L0, cos2L0] = base_default.sincos(2 * L0);
  const sinM = sin4(M);
  return y * sin2L0 - 2 * e2 * sinM + 4 * e2 * y * sinM * cos2L0 - y * y * sin2L0 * cos2L0 - 1.25 * e2 * e2 * sin4(2 * M);
}
var eqtime_default = {
  e,
  eSmart
};

// node_modules/astronomia/src/fit.js
function linear2(points) {
  let sx = 0;
  let sy = 0;
  let sx2 = 0;
  let sxy = 0;
  for (const p2 of points) {
    const x = p2.x;
    const y = p2.y;
    sx += x;
    sy += y;
    sx2 += x * x;
    sxy += x * y;
  }
  const n = points.length;
  const d3 = n * sx2 - sx * sx;
  const a = (n * sxy - sx * sy) / d3;
  const b = (sy * sx2 - sx * sxy) / d3;
  return [a, b];
}
function correlationCoefficient(points) {
  let sx = 0;
  let sy = 0;
  let sx2 = 0;
  let sy2 = 0;
  let sxy = 0;
  for (const p2 of points) {
    const x = p2.x;
    const y = p2.y;
    sx += x;
    sy += y;
    sx2 += x * x;
    sy2 += y * y;
    sxy += x * y;
  }
  const n = points.length;
  return (n * sxy - sx * sy) / (Math.sqrt(n * sx2 - sx * sx) * Math.sqrt(n * sy2 - sy * sy));
}
function quadratic(points) {
  let P = 0;
  let Q = 0;
  let R = 0;
  let S2 = 0;
  let T = 0;
  let U = 0;
  let V = 0;
  for (const p2 of points) {
    const x = p2.x;
    const y = p2.y;
    const x2 = x * x;
    P += x;
    Q += x2;
    R += x * x2;
    S2 += x2 * x2;
    T += y;
    U += x * y;
    V += x2 * y;
  }
  const N = points.length;
  const D = N * Q * S2 + 2 * P * Q * R - Q * Q * Q - P * P * S2 - N * R * R;
  const a = (N * Q * V + P * R * T + P * Q * U - Q * Q * T - P * P * V - N * R * U) / D;
  const b = (N * S2 * U + P * Q * V + Q * R * T - Q * Q * U - P * S2 * T - N * R * V) / D;
  const c3 = (Q * S2 * T + Q * R * U + P * R * V - Q * Q * V - P * S2 * U - R * R * T) / D;
  return [a, b, c3];
}
function func3(points, f0, f1, f2) {
  let M = 0;
  let P = 0;
  let Q = 0;
  let R = 0;
  let S2 = 0;
  let T = 0;
  let U = 0;
  let V = 0;
  let W = 0;
  for (const p2 of points) {
    const x = p2.x;
    const y = p2.y;
    const y0 = f0(x);
    const y1 = f1(x);
    const y2 = f2(x);
    M += y0 * y0;
    P += y0 * y1;
    Q += y0 * y2;
    R += y1 * y1;
    S2 += y1 * y2;
    T += y2 * y2;
    U += y * y0;
    V += y * y1;
    W += y * y2;
  }
  const D = M * R * T + 2 * P * Q * S2 - M * S2 * S2 - R * Q * Q - T * P * P;
  const a = (U * (R * T - S2 * S2) + V * (Q * S2 - P * T) + W * (P * S2 - Q * R)) / D;
  const b = (U * (S2 * Q - P * T) + V * (M * T - Q * Q) + W * (P * Q - M * S2)) / D;
  const c3 = (U * (P * S2 - R * Q) + V * (P * Q - M * S2) + W * (M * R - P * P)) / D;
  return [a, b, c3];
}
function func1(points, f) {
  let syf = 0;
  let sf2 = 0;
  for (const p2 of points) {
    const fx = f(p2.x);
    const y = p2.y;
    syf += y * fx;
    sf2 += fx * fx;
  }
  return syf / sf2;
}
var fit_default = {
  linear: linear2,
  correlationCoefficient,
  quadratic,
  func3,
  func1
};

// node_modules/astronomia/src/illum.js
var { toDeg: toDeg2 } = base_default;
var D2R3 = Math.PI / 180;
function phaseAngle(r, Δ, R) {
  return Math.acos((r * r + Δ * Δ - R * R) / (2 * r * Δ));
}
function fraction(r, Δ, R) {
  const s2 = r + Δ;
  return (s2 * s2 - R * R) / (4 * r * Δ);
}
function phaseAngle2(L2, B, R, L0, R0, Δ) {
  return Math.acos((R - R0 * Math.cos(B) * Math.cos(L2 - L0)) / Δ);
}
function phaseAngle3(L2, B, x, y, z, Δ) {
  const [sL, cL] = base_default.sincos(L2);
  const [sB, cB] = base_default.sincos(B);
  return Math.acos((x * cB * cL + y * cB * sL + z * sB) / Δ);
}
function fractionVenus(jde) {
  const T = base_default.J2000Century(jde);
  const V = (261.51 + 22518.443 * T) * D2R3;
  const M = (177.53 + 35999.05 * T) * D2R3;
  const N = (50.42 + 58517.811 * T) * D2R3;
  const W = V + (1.91 * Math.sin(M) + 0.78 * Math.sin(N)) * D2R3;
  const Δ = Math.sqrt(1.52321 + 1.44666 * Math.cos(W));
  const s2 = 0.72333 + Δ;
  return (s2 * s2 - 1) / 2.89332 / Δ;
}
function mercury(r, Δ, i) {
  const s2 = toDeg2(i) - 50;
  return 1.16 + 5 * Math.log10(r * Δ) + (0.02838 + 1023e-7 * s2) * s2;
}
function venus(r, Δ, i) {
  const iDeg = toDeg2(i);
  return -4 + 5 * Math.log10(r * Δ) + (0.01322 + 4247e-10 * iDeg * iDeg) * iDeg;
}
function mars(r, Δ, i) {
  return -1.3 + 5 * Math.log10(r * Δ) + 0.01486 * toDeg2(i);
}
function jupiter(r, Δ) {
  return -8.93 + 5 * Math.log10(r * Δ);
}
function saturn(r, Δ, B, ΔU) {
  const s2 = Math.sin(Math.abs(B));
  return -8.68 + 5 * Math.log10(r * Δ) + 0.044 * Math.abs(toDeg2(ΔU)) - 2.6 * s2 + 1.25 * s2 * s2;
}
function uranus(r, Δ) {
  return -6.85 + 5 * Math.log10(r * Δ);
}
function neptune(r, Δ) {
  return -7.05 + 5 * Math.log10(r * Δ);
}
function mercury84(r, Δ, i) {
  return base_default.horner(
    toDeg2(i),
    -0.42 + 5 * Math.log10(r * Δ),
    0.038,
    -273e-6,
    2e-6
  );
}
function venus84(r, Δ, i) {
  return base_default.horner(
    toDeg2(i),
    -4.4 + 5 * Math.log10(r * Δ),
    9e-4,
    239e-6,
    -65e-8
  );
}
function mars84(r, Δ, i) {
  return -1.52 + 5 * Math.log10(r * Δ) + 0.016 * toDeg2(i);
}
function jupiter84(r, Δ, i) {
  return -9.4 + 5 * Math.log10(r * Δ) + 5e-3 * toDeg2(i);
}
function saturn84(r, Δ, B, ΔU) {
  const s2 = Math.sin(Math.abs(B));
  return -8.88 + 5 * Math.log10(r * Δ) + 0.044 * Math.abs(toDeg2(ΔU)) - 2.6 * s2 + 1.25 * s2 * s2;
}
function uranus84(r, Δ) {
  return -7.19 + 5 * Math.log10(r * Δ);
}
function neptune84(r, Δ) {
  return -6.87 + 5 * Math.log10(r * Δ);
}
function pluto84(r, Δ) {
  return -1 + 5 * Math.log10(r * Δ);
}
var illum_default = {
  phaseAngle,
  fraction,
  phaseAngle2,
  phaseAngle3,
  fractionVenus,
  mercury,
  venus,
  mars,
  jupiter,
  saturn,
  uranus,
  neptune,
  mercury84,
  venus84,
  mars84,
  jupiter84,
  saturn84,
  uranus84,
  neptune84,
  pluto84
};

// node_modules/astronomia/src/julian.js
var int2 = Math.trunc;
var GREGORIAN0JD = 22991605e-1;
var DAYS_OF_YEAR = [0, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
var SECS_OF_DAY = 86400;
var Calendar = class {
  /**
   * @param {number|Date} [year] - If `Date` is given then year, month, day is taken from that. Shortcut to `new Calendar().fromDate(date)`
   * @param {number} [month]
   * @param {number} [day]
   */
  constructor(year, month = 1, day = 1) {
    if (year instanceof Date) {
      this.fromDate(year);
    } else {
      this.year = year;
      this.month = month;
      this.day = day;
    }
  }
  getDate() {
    return {
      year: this.year,
      month: this.month,
      day: Math.floor(this.day)
    };
  }
  getTime() {
    const t = new sexagesimal_default.Time(this.day * SECS_OF_DAY);
    const [neg, h, m3, _s] = t.toHMS();
    let [s2, ms3] = base_default.modf(_s);
    ms3 = Math.trunc(ms3 * 1e3);
    return {
      hour: h % 24,
      minute: m3,
      second: s2,
      millisecond: ms3
    };
  }
  toISOString() {
    const { year, month, day } = this.getDate();
    const { hour, minute, second, millisecond } = this.getTime();
    return `${pad(year, 4)}-${pad(month)}-${pad(day)}T${pad(hour)}:${pad(minute)}:${pad(second)}.${pad(millisecond, 3)}Z`;
  }
  isGregorian() {
    return isCalendarGregorian(this.year, this.month, this.day);
  }
  /**
   * Note: Take care for dates < GREGORIAN0JD as `date` is always within the
   * proleptic Gregorian Calender
   * @param {Date} date - proleptic Gregorian date
   */
  fromDate(date) {
    this.year = date.getUTCFullYear();
    this.month = date.getUTCMonth() + 1;
    const day = date.getUTCDate();
    const hour = date.getUTCHours();
    const minute = date.getUTCMinutes();
    const second = date.getUTCSeconds();
    const ms3 = date.getMilliseconds();
    this.day = day + (hour + (minute + (second + ms3 / 1e3) / 60) / 60) / 24;
    return this;
  }
  /**
   * Note: Take care for dates < GREGORIAN0JD as `date` is always within the
   * proleptic Gregorian Calender
   * @returns {Date} proleptic Gregorian date
   */
  toDate() {
    const [day, fhour] = base_default.modf(this.day);
    const [hour, fminute] = base_default.modf(fhour * 24);
    const [minute, fsecond] = base_default.modf(fminute * 60);
    const [second, fms] = base_default.modf(fsecond * 60);
    const date = new Date(Date.UTC(
      this.year,
      this.month - 1,
      day,
      hour,
      minute,
      second,
      Math.round(fms * 1e3)
    ));
    date.setUTCFullYear(this.year);
    return date;
  }
  /**
   * converts a calendar date to decimal year
   * @returns {number} decimal year
   */
  toYear() {
    const [d3, f] = base_default.modf(this.day);
    const n = this.dayOfYear() - 1 + f;
    const days = this.isLeapYear() ? 366 : 365;
    const decYear = this.year + n / days;
    return decYear;
  }
  /**
   * converts a decimal year to a calendar date
   * @param {number} year - decimal year
   */
  fromYear(year) {
    const [y, f] = base_default.modf(year);
    this.year = y;
    const days = this.isLeapYear() ? 366 : 365;
    const dayOfYear = base_default.round(f * days, 5);
    let m3 = 12;
    while (m3 > 0 && DAYS_OF_YEAR[m3] > dayOfYear) {
      m3--;
    }
    this.month = m3;
    this.day = 1 + dayOfYear - DAYS_OF_YEAR[this.month];
    return this;
  }
  isLeapYear() {
    if (this.isGregorian()) {
      return LeapYearGregorian2(this.year);
    } else {
      return LeapYearJulian(this.year);
    }
  }
  toJD() {
    return CalendarToJD(this.year, this.month, this.day, !this.isGregorian());
  }
  fromJD(jd) {
    const isJulian = !isJDCalendarGregorian(jd);
    const { year, month, day } = JDToCalendar(jd, isJulian);
    this.year = year;
    this.month = month;
    this.day = day;
    return this;
  }
  fromJDE(jde) {
    this.fromJD(jde);
    const dT = deltat_default2.deltaT(this.toYear());
    this.day -= dT / 86400;
    return this;
  }
  toJDE() {
    const dT = deltat_default2.deltaT(this.toYear());
    this.day += dT / 86400;
    return this.toJD();
  }
  /**
   * set date to midnight UTC
   */
  midnight() {
    this.day = Math.floor(this.day);
    return this;
  }
  /**
   * set date to noon UTC
   */
  noon() {
    this.day = Math.floor(this.day) + 0.5;
    return this;
  }
  /**
   * @param {Boolean} td - if `true` calendar instance is in TD; date gets converted to UT
   *   true  - `UT = TD - ΔT`
   *   false - `TD = UT + ΔT`
   */
  deltaT(td) {
    const dT = deltat_default2.deltaT(this.toYear());
    if (td) {
      this.day -= dT / 86400;
    } else {
      this.day += dT / 86400;
    }
    return this;
  }
  dayOfWeek() {
    return DayOfWeek(this.toJD());
  }
  dayOfYear() {
    if (this.isGregorian()) {
      return DayOfYearGregorian(this.year, this.month, this.day);
    } else {
      return DayOfYearJulian(this.year, this.month, this.day);
    }
  }
};
var CalendarJulian = class extends Calendar {
  toJD() {
    return CalendarJulianToJD(this.year, this.month, this.day);
  }
  fromJD(jd) {
    const { year, month, day } = JDToCalendarJulian(jd);
    this.year = year;
    this.month = month;
    this.day = day;
    return this;
  }
  isLeapYear() {
    return LeapYearJulian(this.year);
  }
  dayOfYear() {
    return DayOfYearJulian(this.year, this.month, this.day);
  }
  /**
   * toGregorian converts a Julian calendar date to a year, month, and day
   * in the Gregorian calendar.
   * @returns {CalendarGregorian}
   */
  toGregorian() {
    const jd = this.toJD();
    return new CalendarGregorian().fromJD(jd);
  }
};
var CalendarGregorian = class extends Calendar {
  toJD() {
    return CalendarGregorianToJD(this.year, this.month, this.day);
  }
  fromJD(jd) {
    const { year, month, day } = JDToCalendarGregorian(jd);
    this.year = year;
    this.month = month;
    this.day = day;
    return this;
  }
  isLeapYear() {
    return LeapYearGregorian2(this.year);
  }
  dayOfYear() {
    return DayOfYearGregorian(this.year, this.month, this.day);
  }
  /*
  * toJulian converts a Gregorian calendar date to a year, month, and day
  * in the Julian calendar.
  * @returns {CalendarJulian}
  */
  toJulian() {
    const jd = this.toJD();
    return new CalendarJulian().fromJD(jd);
  }
};
function CalendarToJD(y, m3, d3, isJulian) {
  let b = 0;
  if (m3 < 3) {
    y--;
    m3 += 12;
  }
  if (!isJulian) {
    const a = base_default.floorDiv(y, 100);
    b = 2 - a + base_default.floorDiv(a, 4);
  }
  const jd = base_default.floorDiv(36525 * int2(y + 4716), 100) + (base_default.floorDiv(306 * (m3 + 1), 10) + b) + d3 - 1524.5;
  return jd;
}
function CalendarGregorianToJD(y, m3, d3) {
  return CalendarToJD(y, m3, d3, false);
}
function CalendarJulianToJD(y, m3, d3) {
  return CalendarToJD(y, m3, d3, true);
}
function LeapYearJulian(y) {
  return y % 4 === 0;
}
function LeapYearGregorian2(y) {
  return y % 4 === 0 && y % 100 !== 0 || y % 400 === 0;
}
function JDToCalendar(jd, isJulian) {
  const [z, f] = base_default.modf(jd + 0.5);
  let a = z;
  if (!isJulian) {
    const α = base_default.floorDiv(z * 100 - 186721625, 3652425);
    a = z + 1 + α - base_default.floorDiv(α, 4);
  }
  const b = a + 1524;
  const c3 = base_default.floorDiv(b * 100 - 12210, 36525);
  const d3 = base_default.floorDiv(36525 * c3, 100);
  const e2 = int2(base_default.floorDiv((b - d3) * 1e4, 306001));
  let year;
  let month;
  const day = int2(b - d3) - base_default.floorDiv(306001 * e2, 1e4) + f;
  if (e2 === 14 || e2 === 15) {
    month = e2 - 13;
  } else {
    month = e2 - 1;
  }
  if (month < 3) {
    year = int2(c3) - 4715;
  } else {
    year = int2(c3) - 4716;
  }
  return { year, month, day };
}
function JDToCalendarGregorian(jd) {
  return JDToCalendar(jd, false);
}
function JDToCalendarJulian(jd) {
  return JDToCalendar(jd, true);
}
function isJDCalendarGregorian(jd) {
  return jd >= GREGORIAN0JD;
}
function isCalendarGregorian(year, month = 1, day = 1) {
  return year > 1582 || year === 1582 && month > 10 || year === 1582 && month === 10 && day >= 15;
}
function JDToDate(jd) {
  return new CalendarGregorian().fromJD(jd).toDate();
}
function DateToJD(date) {
  return new CalendarGregorian().fromDate(date).toJD();
}
function JDEToDate(jde) {
  return new CalendarGregorian().fromJDE(jde).toDate();
}
function DateToJDE(date) {
  return new CalendarGregorian().fromDate(date).toJDE();
}
function MJDToJD(mjd) {
  return mjd + base_default.JMod;
}
function JDToMJD(jd) {
  return jd - base_default.JMod;
}
function DayOfWeek(jd) {
  return int2(jd + 1.5) % 7;
}
function DayOfYearGregorian(y, m3, d3) {
  return DayOfYear(y, m3, int2(d3), LeapYearGregorian2(y));
}
function DayOfYearJulian(y, m3, d3) {
  return DayOfYear(y, m3, int2(d3), LeapYearJulian(y));
}
function DayOfYear(y, m3, d3, leap) {
  let k3 = 0;
  if (leap && m3 > 1) {
    k3 = 1;
  }
  return k3 + DAYS_OF_YEAR[m3] + int2(d3);
}
function DayOfYearToCalendar(n, leap) {
  let month;
  let k3 = 0;
  if (leap) {
    k3 = 1;
  }
  for (month = 1; month <= 12; month++) {
    if (k3 + DAYS_OF_YEAR[month] > n) {
      month = month - 1;
      break;
    }
  }
  const day = n - k3 - DAYS_OF_YEAR[month];
  return { month, day };
}
function DayOfYearToCalendarGregorian(year, n) {
  const { month, day } = DayOfYearToCalendar(n, LeapYearGregorian2(year));
  return new CalendarGregorian(year, month, day);
}
function DayOfYearToCalendarJulian(year, n) {
  const { month, day } = DayOfYearToCalendar(n, LeapYearJulian(year));
  return new CalendarJulian(year, month, day);
}
function pad(num, len) {
  len = len || 2;
  const neg = num < 0 ? "-" : "";
  num = Math.abs(num);
  const padded = "0000" + num;
  return neg + padded.substr(padded.length - len, len);
}
var julian_default = {
  GREGORIAN0JD,
  Calendar,
  CalendarJulian,
  CalendarGregorian,
  CalendarToJD,
  CalendarGregorianToJD,
  CalendarJulianToJD,
  LeapYearJulian,
  LeapYearGregorian: LeapYearGregorian2,
  JDToCalendar,
  JDToCalendarGregorian,
  JDToCalendarJulian,
  isJDCalendarGregorian,
  isCalendarGregorian,
  JDToDate,
  DateToJD,
  JDEToDate,
  DateToJDE,
  MJDToJD,
  JDToMJD,
  DayOfWeek,
  DayOfYearGregorian,
  DayOfYearJulian,
  DayOfYear,
  DayOfYearToCalendar,
  DayOfYearToCalendarGregorian,
  DayOfYearToCalendarJulian
};

// node_modules/astronomia/src/jm.js
var int3 = Math.trunc;
function JewishCalendar(y) {
  const A = y + 3760;
  const D = bigD(y);
  let mP = 3;
  let dP = D;
  if (dP > 31) {
    mP++;
    dP -= 31;
  }
  let mNY = 9;
  let dNY = D - 21;
  if (dNY > 30) {
    mNY++;
    dNY -= 30;
  }
  let months = 12;
  switch (A % 19) {
    case 0:
    case 3:
    case 6:
    case 8:
    case 11:
    case 14:
    case 17:
      months++;
      break;
  }
  const y1 = y + 1;
  let lf = julian_default.LeapYearGregorian;
  if (y1 < 1583) {
    lf = julian_default.LeapYearJulian;
  }
  let days = 365;
  if (lf(y1)) {
    days++;
  }
  days += bigD(y1) - D;
  return [A, mP, dP, mNY, dNY, months, days];
}
var bigD = function(y) {
  const C2 = base_default.floorDiv(y, 100);
  let S2 = 0;
  if (y >= 1583) {
    S2 = int3(base_default.floorDiv(3 * C2 - 5, 4));
  }
  const a = (12 * y + 12) % 19;
  const b = y % 4;
  const Q = -1.904412361576 + 1.554241796621 * a + 0.25 * b - 0.003177794022 * y + S2;
  const fq = Math.floor(Q);
  const iq = int3(fq);
  const j = (iq + 3 * y + 5 * b + 2 - S2) % 7;
  const r = Q - fq;
  let D;
  if (j === 2 || j === 4 || j === 6) {
    D = iq + 23;
  } else if (j === 1 && a > 6 && r >= 0.63287037) {
    D = iq + 24;
  } else if (j === 0 && a > 11 && r >= 0.897723765) {
    D = iq + 23;
  } else {
    D = iq + 22;
  }
  return int3(D);
};
function MoslemToJD(y, m3, d3) {
  const N = d3 + base_default.floorDiv(295001 * (m3 - 1) + 9900, 1e4);
  const Q = base_default.floorDiv(y, 30);
  const R = y % 30;
  const A = base_default.floorDiv(11 * R + 3, 30);
  const W = 404 * Q + 354 * R + 208 + A;
  const Q1 = base_default.floorDiv(W, 1461);
  const Q2 = W % 1461;
  const G = 621 + 28 * Q + 4 * Q1;
  const K2 = base_default.floorDiv(Q2 * 1e4, 3652422);
  const E = base_default.floorDiv(3652422 * K2, 1e4);
  let J2 = Q2 - E + N - 1;
  let X = G + K2;
  if (J2 > 366 && X % 4 === 0) {
    J2 -= 366;
    X++;
  } else if (J2 > 365 && X % 4 > 0) {
    J2 -= 365;
    X++;
  }
  const jd = base_default.floorDiv(36525 * (X - 1), 100) + 1721423 + J2;
  return jd;
}
function MoslemLeapYear(year) {
  const R = year % 30;
  return (11 * R + 3) % 30 > 18;
}
function JulianToMoslem(y, m3, d3) {
  let W = 2;
  if (y % 4 === 0) {
    W = 1;
  }
  const N = base_default.floorDiv(275 * m3, 9) - W * base_default.floorDiv(m3 + 9, 12) + d3 - 30;
  const A = int3(y - 623);
  const B = base_default.floorDiv(A, 4);
  const C2 = function(A2) {
    const C3 = A2 % 4;
    const C1 = 365.25001 * C3;
    const C22 = Math.floor(C1);
    if (C1 - C22 > 0.5) {
      return int3(C22) + 1;
    }
    return int3(C22);
  }(A);
  const Dp = 1461 * B + 170 + C2;
  const Q = base_default.floorDiv(Dp, 10631);
  const R = Dp % 10631;
  const J2 = base_default.floorDiv(R, 354);
  const K2 = R % 354;
  const O = base_default.floorDiv(11 * J2 + 14, 30);
  let my = 30 * Q + J2 + 1;
  let JJ = K2 - O + N - 1;
  let days = 354;
  if (MoslemLeapYear(y)) {
    days++;
  }
  if (JJ > days) {
    JJ -= days;
    my++;
  }
  let mm;
  let md;
  if (JJ === 355) {
    mm = 12;
    md = 30;
  } else {
    const S2 = base_default.floorDiv((JJ - 1) * 10, 295);
    mm = 1 + S2;
    md = base_default.floorDiv(10 * JJ - 295 * S2, 10);
  }
  return { year: my, month: mm, day: md };
}
var mmonths = [
  "",
  "Muḥarram",
  "Ṣafar",
  "Rabīʿ I",
  "Rabīʿ II",
  "Jumādā I",
  "Jumādā II",
  "Rajab",
  "Shaʿbān",
  "Ramaḍān",
  "Shawwāl",
  "Dhū al-Qaʿda",
  "Dhū al-Ḥijja"
];
function moslemMonth(m3) {
  return mmonths[m3];
}
var jm_default = {
  JewishCalendar,
  MoslemToJD,
  MoslemLeapYear,
  JulianToMoslem,
  moslemMonth
};

// node_modules/astronomia/src/jupiter.js
function physical(jde, earth3, jupiter4) {
  const d3 = jde - 24332825e-1;
  const T1 = d3 / base_default.JulianCentury;
  const p2 = Math.PI / 180;
  const α0 = 268 * p2 + 0.1061 * p2 * T1;
  const δ0 = 64.5 * p2 - 0.0164 * p2 * T1;
  const W1 = 17.71 * p2 + 877.90003539 * p2 * d3;
  const W2 = 16.838 * p2 + 870.27003539 * p2 * d3;
  const pos = earth3.position(jde);
  let [l02, b0, R] = [pos.lon, pos.lat, pos.range];
  const fk5 = planetposition_default.toFK5(l02, b0, jde);
  l02 = fk5.lon;
  b0 = fk5.lat;
  const [sl0, cl0] = base_default.sincos(l02);
  const sb0 = Math.sin(b0);
  let Δ = 4;
  let l = 0;
  let b = 0;
  let r = 0;
  let x = 0;
  let y = 0;
  let z = 0;
  const f = function() {
    const τ = base_default.lightTime(Δ);
    const pos2 = jupiter4.position(jde - τ);
    l = pos2.lon;
    b = pos2.lat;
    r = pos2.range;
    const fk52 = planetposition_default.toFK5(l, b, jde);
    l = fk52.lon;
    b = fk52.lat;
    const [sb2, cb2] = base_default.sincos(b);
    const [sl2, cl3] = base_default.sincos(l);
    x = r * cb2 * cl3 - R * cl0;
    y = r * cb2 * sl2 - R * sl0;
    z = r * sb2 - R * sb0;
    Δ = Math.sqrt(x * x + y * y + z * z);
  };
  f();
  f();
  const ε0 = nutation_default.meanObliquity(jde);
  const [sε0, cε0] = base_default.sincos(ε0);
  const [sl, cl2] = base_default.sincos(l);
  const [sb, cb] = base_default.sincos(b);
  const αs = Math.atan2(cε0 * sl - sε0 * sb / cb, cl2);
  const δs = Math.asin(cε0 * sb + sε0 * cb * sl);
  const [sδs, cδs] = base_default.sincos(δs);
  const [sδ0, cδ0] = base_default.sincos(δ0);
  const DS = Math.asin(-sδ0 * sδs - cδ0 * cδs * Math.cos(α0 - αs));
  const u = y * cε0 - z * sε0;
  const v = y * sε0 + z * cε0;
  let α = Math.atan2(u, x);
  let δ = Math.atan(v / Math.hypot(x, u));
  const [sδ, cδ] = base_default.sincos(δ);
  const [sα0α, cα0α] = base_default.sincos(α0 - α);
  const ζ = Math.atan2(sδ0 * cδ * cα0α - sδ * cδ0, cδ * sα0α);
  const DE = Math.asin(-sδ0 * sδ - cδ0 * cδ * Math.cos(α0 - α));
  let ω1 = W1 - ζ - 5.07033 * p2 * Δ;
  let ω2 = W2 - ζ - 5.02626 * p2 * Δ;
  let C2 = (2 * r * Δ + R * R - r * r - Δ * Δ) / (4 * r * Δ);
  if (Math.sin(l - l02) < 0) {
    C2 = -C2;
  }
  ω1 = base_default.pmod(ω1 + C2, 2 * Math.PI);
  ω2 = base_default.pmod(ω2 + C2, 2 * Math.PI);
  const [Δψ, Δε] = nutation_default.nutation(jde);
  const ε = ε0 + Δε;
  const [sε, cε] = base_default.sincos(ε);
  const [sα, cα] = base_default.sincos(α);
  α += 5693e-6 * p2 * (cα * cl0 * cε + sα * sl0) / cδ;
  δ += 5693e-6 * p2 * (cl0 * cε * (sε / cε * cδ - sα * sδ) + cα * sδ * sl0);
  const tδ = sδ / cδ;
  const Δα = (cε + sε * sα * tδ) * Δψ - cα * tδ * Δε;
  const Δδ = sε * cα * Δψ + sα * Δε;
  const αʹ = α + Δα;
  const δʹ = δ + Δδ;
  const [sα0, cα0] = base_default.sincos(α0);
  const tδ0 = sδ0 / cδ0;
  const Δα0 = (cε + sε * sα0 * tδ0) * Δψ - cα0 * tδ0 * Δε;
  const Δδ0 = sε * cα0 * Δψ + sα0 * Δε;
  const α0ʹ = α0 + Δα0;
  const δ0ʹ = δ0 + Δδ0;
  const [sδʹ, cδʹ] = base_default.sincos(δʹ);
  const [sδ0ʹ, cδ0ʹ] = base_default.sincos(δ0ʹ);
  const [sα0ʹαʹ, cα0ʹαʹ] = base_default.sincos(α0ʹ - αʹ);
  let P = Math.atan2(cδ0ʹ * sα0ʹαʹ, sδ0ʹ * cδʹ - cδ0ʹ * sδʹ * cα0ʹαʹ);
  if (P < 0) {
    P += 2 * Math.PI;
  }
  return [DS, DE, ω1, ω2, P];
}
function physical2(jde) {
  const d3 = jde - base_default.J2000;
  const p2 = Math.PI / 180;
  const V = 172.74 * p2 + 111588e-8 * p2 * d3;
  const M = 357.529 * p2 + 0.9856003 * p2 * d3;
  const sV = Math.sin(V);
  const N = 20.02 * p2 + 0.0830853 * p2 * d3 + 0.329 * p2 * sV;
  const J2 = 66.115 * p2 + 0.9025179 * p2 * d3 - 0.329 * p2 * sV;
  const [sM, cM] = base_default.sincos(M);
  const [sN, cN] = base_default.sincos(N);
  const [s2M, c2M] = base_default.sincos(2 * M);
  const [s2N, c2N] = base_default.sincos(2 * N);
  const A = 1.915 * p2 * sM + 0.02 * p2 * s2M;
  const B = 5.555 * p2 * sN + 0.168 * p2 * s2N;
  const K2 = J2 + A - B;
  const R = 1.00014 - 0.01671 * cM - 14e-5 * c2M;
  const r = 5.20872 - 0.25208 * cN - 611e-5 * c2N;
  const [sK, cK] = base_default.sincos(K2);
  const Δ = Math.sqrt(r * r + R * R - 2 * r * R * cK);
  const ψ = Math.asin(R / Δ * sK);
  const dd = d3 - Δ / 173;
  let ω1 = 210.98 * p2 + 877.8169088 * p2 * dd + ψ - B;
  let ω2 = 187.23 * p2 + 870.1869088 * p2 * dd + ψ - B;
  let C2 = Math.sin(ψ / 2);
  C2 *= C2;
  if (sK > 0) {
    C2 = -C2;
  }
  ω1 = base_default.pmod(ω1 + C2, 2 * Math.PI);
  ω2 = base_default.pmod(ω2 + C2, 2 * Math.PI);
  const λ = 34.35 * p2 + 0.083091 * p2 * d3 + 0.329 * p2 * sV + B;
  const DS = 3.12 * p2 * Math.sin(λ + 42.8 * p2);
  const DE = DS - 2.22 * p2 * Math.sin(ψ) * Math.cos(λ + 22 * p2) - 1.3 * p2 * (r - Δ) / Δ * Math.sin(λ - 100.5 * p2);
  return [DS, DE, ω1, ω2];
}
var jupiter_default = {
  physical,
  physical2
};

// node_modules/astronomia/src/planetelements.js
var mercury2 = "mercury";
var venus2 = "venus";
var earth = "earth";
var mars2 = "mars";
var jupiter2 = "jupiter";
var saturn2 = "saturn";
var uranus2 = "uranus";
var neptune2 = "neptune";
function Elements3(lon, axis, ecc, inc2, node5, peri) {
  const o = typeof lon === "object" ? lon : {};
  this.lon = o.lon || lon;
  this.axis = o.axis || axis;
  this.ecc = o.ecc || ecc;
  this.inc = o.inc || inc2;
  this.node = o.node || node5;
  this.peri = o.peri || peri;
}
var cMean = {
  mercury: {
    // Mercury
    L: [252.250906, 149474.0722491, 3035e-7, 18e-9],
    a: [0.38709831],
    e: [0.20563175, 20407e-9, -283e-10, -18e-11],
    i: [7.004986, 18215e-7, -181e-7, 56e-9],
    Ω: [48.330893, 1.1861883, 17542e-8, 215e-9],
    ϖ: [77.456119, 1.5564776, 29544e-8, 9e-9]
  },
  venus: {
    // Venus
    L: [181.979801, 58519.2130302, 31014e-8, 15e-9],
    a: [0.72332982],
    e: [677192e-8, -47765e-9, 981e-10, 46e-11],
    i: [3.394662, 10037e-7, -88e-8, -7e-9],
    Ω: [76.67992, 0.9011206, 40618e-8, -93e-9],
    ϖ: [131.563703, 1.4022288, -107618e-8, -5678e-9]
  },
  earth: {
    // Earth
    L: [100.466457, 36000.7698278, 30322e-8, 2e-8],
    a: [1.000001018],
    e: [0.01670863, -42037e-9, -1267e-10, 14e-11],
    i: [0],
    Ω: void 0,
    ϖ: [102.937348, 1.7195366, 45688e-8, -18e-9]
  },
  mars: {
    // Mars
    L: [355.433, 19141.6964471, 31052e-8, 16e-9],
    a: [1.523679342],
    e: [0.09340065, 90484e-9, -806e-10, -25e-11],
    i: [1.849726, -6011e-7, 1276e-8, -7e-9],
    Ω: [49.558093, 0.7720959, 1557e-8, 2267e-9],
    ϖ: [336.060234, 1.8410449, 13477e-8, 536e-9]
  },
  jupiter: {
    // Jupiter
    L: [34.351519, 3036.3027748, 2233e-7, 37e-9],
    a: [5.202603209, 1913e-10],
    e: [0.04849793, 163225e-9, -4714e-10, -201e-11],
    i: [1.303267, -54965e-7, 466e-8, -2e-9],
    Ω: [100.464407, 1.0209774, 40315e-8, 404e-9],
    ϖ: [14.331207, 1.6126352, 103042e-8, -4464e-9]
  },
  saturn: {
    // Saturn
    L: [50.077444, 1223.5110686, 51908e-8, -3e-8],
    a: [9.554909192, -2139e-9, 4e-9],
    e: [0.05554814, -346641e-9, -6436e-10, 34e-10],
    i: [2.488879, -37362e-7, -1519e-8, 87e-9],
    Ω: [113.665503, 0.877088, -12176e-8, -2249e-9],
    ϖ: [93.057237, 1.9637613, 83753e-8, 4928e-9]
  },
  uranus: {
    // Uranus
    L: [314.055005, 429.8640561, 3039e-7, 26e-9],
    a: [19.218446062, -372e-10, 98e-11],
    e: [0.04638122, -27293e-9, 789e-10, 24e-11],
    i: [0.773197, 7744e-7, 3749e-8, -92e-9],
    Ω: [74.005957, 0.5211278, 133947e-8, 18484e-9],
    ϖ: [173.005291, 1.486379, 21406e-8, 434e-9]
  },
  neptune: {
    // Neptune
    L: [304.348665, 219.8833092, 30882e-8, 18e-9],
    a: [30.110386869, -1663e-10, 69e-11],
    e: [945575e-8, 6033e-9, 0, -5e-11],
    i: [1.769953, -93082e-7, -708e-8, 27e-9],
    Ω: [131.784057, 1.1022039, 25952e-8, -637e-9],
    ϖ: [48.120276, 1.4262957, 38434e-8, 2e-8]
  }
};
function mean3(p2, jde, e2) {
  const T = base_default.J2000Century(jde);
  const c3 = cMean[p2];
  e2 = e2 || new Elements3();
  e2.lon = base_default.pmod(base_default.horner(T, c3.L) * Math.PI / 180, 2 * Math.PI);
  e2.axis = base_default.horner(T, c3.a);
  e2.ecc = base_default.horner(T, c3.e);
  e2.inc = base_default.horner(T, c3.i) * Math.PI / 180;
  e2.node = base_default.horner(T, c3.Ω) * Math.PI / 180;
  e2.peri = base_default.horner(T, c3.ϖ) * Math.PI / 180;
  return e2;
}
function inc(p2, jde) {
  return base_default.horner(base_default.J2000Century(jde), cMean[p2].i) * Math.PI / 180;
}
function node2(p2, jde) {
  return base_default.horner(base_default.J2000Century(jde), cMean[p2].Ω) * Math.PI / 180;
}
var planetelements_default = {
  mercury: mercury2,
  venus: venus2,
  earth,
  mars: mars2,
  jupiter: jupiter2,
  saturn: saturn2,
  uranus: uranus2,
  neptune: neptune2,
  Elements: Elements3,
  mean: mean3,
  inc,
  node: node2
};

// node_modules/astronomia/src/jupitermoons.js
var io = 0;
var europa = 1;
var ganymede = 2;
var callisto = 3;
var k = [17295, 21819, 27558, 36548];
function XY(x, y) {
  this.x = x;
  this.y = y;
}
function positions(jde) {
  const d3 = jde - base_default.J2000;
  const p2 = Math.PI / 180;
  const V = 172.74 * p2 + 111588e-8 * p2 * d3;
  const M = 357.529 * p2 + 0.9856003 * p2 * d3;
  const sV = Math.sin(V);
  const N = 20.02 * p2 + 0.0830853 * p2 * d3 + 0.329 * p2 * sV;
  const J2 = 66.115 * p2 + 0.9025179 * p2 * d3 - 0.329 * p2 * sV;
  const [sM, cM] = base_default.sincos(M);
  const [sN, cN] = base_default.sincos(N);
  const [s2M, c2M] = base_default.sincos(2 * M);
  const [s2N, c2N] = base_default.sincos(2 * N);
  const A = 1.915 * p2 * sM + 0.02 * p2 * s2M;
  const B = 5.555 * p2 * sN + 0.168 * p2 * s2N;
  const K2 = J2 + A - B;
  const R = 1.00014 - 0.01671 * cM - 14e-5 * c2M;
  const r = 5.20872 - 0.25208 * cN - 611e-5 * c2N;
  const [sK, cK] = base_default.sincos(K2);
  const Δ = Math.sqrt(r * r + R * R - 2 * r * R * cK);
  const ψ = Math.asin(R / Δ * sK);
  const λ = 34.35 * p2 + 0.083091 * p2 * d3 + 0.329 * p2 * sV + B;
  const DS = 3.12 * p2 * Math.sin(λ + 42.8 * p2);
  const DE = DS - 2.22 * p2 * Math.sin(ψ) * Math.cos(λ + 22 * p2) - 1.3 * p2 * (r - Δ) / Δ * Math.sin(λ - 100.5 * p2);
  const dd = d3 - Δ / 173;
  const u1 = 163.8069 * p2 + 203.4058646 * p2 * dd + ψ - B;
  const u2 = 358.414 * p2 + 101.2916335 * p2 * dd + ψ - B;
  const u3 = 5.7176 * p2 + 50.234518 * p2 * dd + ψ - B;
  const u4 = 224.8092 * p2 + 21.48798 * p2 * dd + ψ - B;
  const G = 331.18 * p2 + 50.310482 * p2 * dd;
  const H = 87.45 * p2 + 21.569231 * p2 * dd;
  const [s212, c212] = base_default.sincos(2 * (u1 - u2));
  const [s223, c223] = base_default.sincos(2 * (u2 - u3));
  const [sG, cG] = base_default.sincos(G);
  const [sH, cH] = base_default.sincos(H);
  const c1 = 0.473 * p2 * s212;
  const c22 = 1.065 * p2 * s223;
  const c3 = 0.165 * p2 * sG;
  const c4 = 0.843 * p2 * sH;
  const r1 = 5.9057 - 0.0244 * c212;
  const r2 = 9.3966 - 0.0882 * c223;
  const r3 = 14.9883 - 0.0216 * cG;
  const r4 = 26.3627 - 0.1939 * cH;
  const sDE = Math.sin(DE);
  const xy = function(u, r5) {
    const [su, cu] = base_default.sincos(u);
    return new XY(r5 * su, -r5 * cu * sDE);
  };
  return [xy(u1 + c1, r1), xy(u2 + c22, r2), xy(u3 + c3, r3), xy(u4 + c4, r4)];
}
function e5(jde, earth3, jupiter4, pos) {
  pos = pos || new Array(4);
  let λ0, β0, t;
  let Δ = 5;
  (function() {
    const { lon, lat, range } = solar_default.trueVSOP87(earth3, jde);
    const [s2, β, R2] = [lon, lat, range];
    const [ss, cs] = base_default.sincos(s2);
    const sβ = Math.sin(β);
    let τ = base_default.lightTime(Δ);
    let x = 0;
    let y = 0;
    let z = 0;
    function f() {
      const { lon: lon2, lat: lat2, range: range2 } = jupiter4.position(jde - τ);
      const [sl, cl2] = base_default.sincos(lon2);
      const [sb, cb] = base_default.sincos(lat2);
      x = range2 * cb * cl2 + R2 * cs;
      y = range2 * cb * sl + R2 * ss;
      z = range2 * sb + R2 * sβ;
      Δ = Math.sqrt(x * x + y * y + z * z);
      τ = base_default.lightTime(Δ);
    }
    f();
    f();
    λ0 = Math.atan2(y, x);
    β0 = Math.atan(z / Math.hypot(x, y));
    t = jde - 24430005e-1 - τ;
  })();
  const p2 = Math.PI / 180;
  const l1 = 106.07719 * p2 + 203.48895579 * p2 * t;
  const l2 = 175.73161 * p2 + 101.374724735 * p2 * t;
  const l3 = 120.55883 * p2 + 50.317609207 * p2 * t;
  const l4 = 84.44459 * p2 + 21.571071177 * p2 * t;
  const π1 = 97.0881 * p2 + 0.16138586 * p2 * t;
  const π2 = 154.8663 * p2 + 0.04726307 * p2 * t;
  const π3 = 188.184 * p2 + 712734e-8 * p2 * t;
  const π4 = 335.2868 * p2 + 184e-5 * p2 * t;
  const ω1 = 312.3346 * p2 - 0.13279386 * p2 * t;
  const ω2 = 100.4411 * p2 - 0.03263064 * p2 * t;
  const ω3 = 119.1942 * p2 - 717703e-8 * p2 * t;
  const ω4 = 322.6186 * p2 - 175934e-8 * p2 * t;
  const Γ = 0.33033 * p2 * Math.sin(163.679 * p2 + 10512e-7 * p2 * t) + 0.03439 * p2 * Math.sin(34.486 * p2 - 0.0161731 * p2 * t);
  const Φλ = 199.6766 * p2 + 0.1737919 * p2 * t;
  let ψ = 316.5182 * p2 - 208e-8 * p2 * t;
  const G = 30.23756 * p2 + 0.0830925701 * p2 * t + Γ;
  const Gʹ = 31.97853 * p2 + 0.0334597339 * p2 * t;
  const Π = 13.469942 * p2;
  const Σ1 = 0.47259 * p2 * Math.sin(2 * (l1 - l2)) + -0.03478 * p2 * Math.sin(π3 - π4) + 0.01081 * p2 * Math.sin(l2 - 2 * l3 + π3) + 738e-5 * p2 * Math.sin(Φλ) + 713e-5 * p2 * Math.sin(l2 - 2 * l3 + π2) + -674e-5 * p2 * Math.sin(π1 + π3 - 2 * Π - 2 * G) + 666e-5 * p2 * Math.sin(l2 - 2 * l3 + π4) + 445e-5 * p2 * Math.sin(l1 - π3) + -354e-5 * p2 * Math.sin(l1 - l2) + -317e-5 * p2 * Math.sin(2 * ψ - 2 * Π) + 265e-5 * p2 * Math.sin(l1 - π4) + -186e-5 * p2 * Math.sin(G) + 162e-5 * p2 * Math.sin(π2 - π3) + 158e-5 * p2 * Math.sin(4 * (l1 - l2)) + -155e-5 * p2 * Math.sin(l1 - l3) + -138e-5 * p2 * Math.sin(ψ + ω3 - 2 * Π - 2 * G) + -115e-5 * p2 * Math.sin(2 * (l1 - 2 * l2 + ω2)) + 89e-5 * p2 * Math.sin(π2 - π4) + 85e-5 * p2 * Math.sin(l1 + π3 - 2 * Π - 2 * G) + 83e-5 * p2 * Math.sin(ω2 - ω3) + 53e-5 * p2 * Math.sin(ψ - ω2);
  const Σ2 = 1.06476 * p2 * Math.sin(2 * (l2 - l3)) + 0.04256 * p2 * Math.sin(l1 - 2 * l2 + π3) + 0.03581 * p2 * Math.sin(l2 - π3) + 0.02395 * p2 * Math.sin(l1 - 2 * l2 + π4) + 0.01984 * p2 * Math.sin(l2 - π4) + -0.01778 * p2 * Math.sin(Φλ) + 0.01654 * p2 * Math.sin(l2 - π2) + 0.01334 * p2 * Math.sin(l2 - 2 * l3 + π2) + 0.01294 * p2 * Math.sin(π3 - π4) + -0.01142 * p2 * Math.sin(l2 - l3) + -0.01057 * p2 * Math.sin(G) + -775e-5 * p2 * Math.sin(2 * (ψ - Π)) + 524e-5 * p2 * Math.sin(2 * (l1 - l2)) + -46e-4 * p2 * Math.sin(l1 - l3) + 316e-5 * p2 * Math.sin(ψ - 2 * G + ω3 - 2 * Π) + -203e-5 * p2 * Math.sin(π1 + π3 - 2 * Π - 2 * G) + 146e-5 * p2 * Math.sin(ψ - ω3) + -145e-5 * p2 * Math.sin(2 * G) + 125e-5 * p2 * Math.sin(ψ - ω4) + -115e-5 * p2 * Math.sin(l1 - 2 * l3 + π3) + -94e-5 * p2 * Math.sin(2 * (l2 - ω2)) + 86e-5 * p2 * Math.sin(2 * (l1 - 2 * l2 + ω2)) + -86e-5 * p2 * Math.sin(5 * Gʹ - 2 * G + 52.225 * p2) + -78e-5 * p2 * Math.sin(l2 - l4) + -64e-5 * p2 * Math.sin(3 * l3 - 7 * l4 + 4 * π4) + 64e-5 * p2 * Math.sin(π1 - π4) + -63e-5 * p2 * Math.sin(l1 - 2 * l3 + π4) + 58e-5 * p2 * Math.sin(ω3 - ω4) + 56e-5 * p2 * Math.sin(2 * (ψ - Π - G)) + 56e-5 * p2 * Math.sin(2 * (l2 - l4)) + 55e-5 * p2 * Math.sin(2 * (l1 - l3)) + 52e-5 * p2 * Math.sin(3 * l3 - 7 * l4 + π3 + 3 * π4) + -43e-5 * p2 * Math.sin(l1 - π3) + 41e-5 * p2 * Math.sin(5 * (l2 - l3)) + 41e-5 * p2 * Math.sin(π4 - Π) + 32e-5 * p2 * Math.sin(ω2 - ω3) + 32e-5 * p2 * Math.sin(2 * (l3 - G - Π));
  const Σ3 = 0.1649 * p2 * Math.sin(l3 - π3) + 0.09081 * p2 * Math.sin(l3 - π4) + -0.06907 * p2 * Math.sin(l2 - l3) + 0.03784 * p2 * Math.sin(π3 - π4) + 0.01846 * p2 * Math.sin(2 * (l3 - l4)) + -0.0134 * p2 * Math.sin(G) + -0.01014 * p2 * Math.sin(2 * (ψ - Π)) + 704e-5 * p2 * Math.sin(l2 - 2 * l3 + π3) + -62e-4 * p2 * Math.sin(l2 - 2 * l3 + π2) + -541e-5 * p2 * Math.sin(l3 - l4) + 381e-5 * p2 * Math.sin(l2 - 2 * l3 + π4) + 235e-5 * p2 * Math.sin(ψ - ω3) + 198e-5 * p2 * Math.sin(ψ - ω4) + 176e-5 * p2 * Math.sin(Φλ) + 13e-4 * p2 * Math.sin(3 * (l3 - l4)) + 125e-5 * p2 * Math.sin(l1 - l3) + -119e-5 * p2 * Math.sin(5 * Gʹ - 2 * G + 52.225 * p2) + 109e-5 * p2 * Math.sin(l1 - l2) + -1e-3 * p2 * Math.sin(3 * l3 - 7 * l4 + 4 * π4) + 91e-5 * p2 * Math.sin(ω3 - ω4) + 8e-4 * p2 * Math.sin(3 * l3 - 7 * l4 + π3 + 3 * π4) + -75e-5 * p2 * Math.sin(2 * l2 - 3 * l3 + π3) + 72e-5 * p2 * Math.sin(π1 + π3 - 2 * Π - 2 * G) + 69e-5 * p2 * Math.sin(π4 - Π) + -58e-5 * p2 * Math.sin(2 * l3 - 3 * l4 + π4) + -57e-5 * p2 * Math.sin(l3 - 2 * l4 + π4) + 56e-5 * p2 * Math.sin(l3 + π3 - 2 * Π - 2 * G) + -52e-5 * p2 * Math.sin(l2 - 2 * l3 + π1) + -5e-4 * p2 * Math.sin(π2 - π3) + 48e-5 * p2 * Math.sin(l3 - 2 * l4 + π3) + -45e-5 * p2 * Math.sin(2 * l2 - 3 * l3 + π4) + -41e-5 * p2 * Math.sin(π2 - π4) + -38e-5 * p2 * Math.sin(2 * G) + -37e-5 * p2 * Math.sin(π3 - π4 + ω3 - ω4) + -32e-5 * p2 * Math.sin(3 * l3 - 7 * l4 + 2 * π3 + 2 * π4) + 3e-4 * p2 * Math.sin(4 * (l3 - l4)) + 29e-5 * p2 * Math.sin(l3 + π4 - 2 * Π - 2 * G) + -28e-5 * p2 * Math.sin(ω3 + ψ - 2 * Π - 2 * G) + 26e-5 * p2 * Math.sin(l3 - Π - G) + 24e-5 * p2 * Math.sin(l2 - 3 * l3 + 2 * l4) + 21e-5 * p2 * Math.sin(2 * (l3 - Π - G)) + -21e-5 * p2 * Math.sin(l3 - π2) + 17e-5 * p2 * Math.sin(2 * (l3 - π3));
  const Σ4 = 0.84287 * p2 * Math.sin(l4 - π4) + 0.03431 * p2 * Math.sin(π4 - π3) + -0.03305 * p2 * Math.sin(2 * (ψ - Π)) + -0.03211 * p2 * Math.sin(G) + -0.01862 * p2 * Math.sin(l4 - π3) + 0.01186 * p2 * Math.sin(ψ - ω4) + 623e-5 * p2 * Math.sin(l4 + π4 - 2 * G - 2 * Π) + 387e-5 * p2 * Math.sin(2 * (l4 - π4)) + -284e-5 * p2 * Math.sin(5 * Gʹ - 2 * G + 52.225 * p2) + -234e-5 * p2 * Math.sin(2 * (ψ - π4)) + -223e-5 * p2 * Math.sin(l3 - l4) + -208e-5 * p2 * Math.sin(l4 - Π) + 178e-5 * p2 * Math.sin(ψ + ω4 - 2 * π4) + 134e-5 * p2 * Math.sin(π4 - Π) + 125e-5 * p2 * Math.sin(2 * (l4 - G - Π)) + -117e-5 * p2 * Math.sin(2 * G) + -112e-5 * p2 * Math.sin(2 * (l3 - l4)) + 107e-5 * p2 * Math.sin(3 * l3 - 7 * l4 + 4 * π4) + 102e-5 * p2 * Math.sin(l4 - G - Π) + 96e-5 * p2 * Math.sin(2 * l4 - ψ - ω4) + 87e-5 * p2 * Math.sin(2 * (ψ - ω4)) + -85e-5 * p2 * Math.sin(3 * l3 - 7 * l4 + π3 + 3 * π4) + 85e-5 * p2 * Math.sin(l3 - 2 * l4 + π4) + -81e-5 * p2 * Math.sin(2 * (l4 - ψ)) + 71e-5 * p2 * Math.sin(l4 + π4 - 2 * Π - 3 * G) + 61e-5 * p2 * Math.sin(l1 - l4) + -56e-5 * p2 * Math.sin(ψ - ω3) + -54e-5 * p2 * Math.sin(l3 - 2 * l4 + π3) + 51e-5 * p2 * Math.sin(l2 - l4) + 42e-5 * p2 * Math.sin(2 * (ψ - G - Π)) + 39e-5 * p2 * Math.sin(2 * (π4 - ω4)) + 36e-5 * p2 * Math.sin(ψ + Π - π4 - ω4) + 35e-5 * p2 * Math.sin(2 * Gʹ - G + 188.37 * p2) + -35e-5 * p2 * Math.sin(l4 - π4 + 2 * Π - 2 * ψ) + -32e-5 * p2 * Math.sin(l4 + π4 - 2 * Π - G) + 3e-4 * p2 * Math.sin(2 * Gʹ - 2 * G + 149.15 * p2) + 29e-5 * p2 * Math.sin(3 * l3 - 7 * l4 + 2 * π3 + 2 * π4) + 28e-5 * p2 * Math.sin(l4 - π4 + 2 * ψ - 2 * Π) + -28e-5 * p2 * Math.sin(2 * (l4 - ω4)) + -27e-5 * p2 * Math.sin(π3 - π4 + ω3 - ω4) + -26e-5 * p2 * Math.sin(5 * Gʹ - 3 * G + 188.37 * p2) + 25e-5 * p2 * Math.sin(ω4 - ω3) + -25e-5 * p2 * Math.sin(l2 - 3 * l3 + 2 * l4) + -23e-5 * p2 * Math.sin(3 * (l3 - l4)) + 21e-5 * p2 * Math.sin(2 * l4 - 2 * Π - 3 * G) + -21e-5 * p2 * Math.sin(2 * l3 - 3 * l4 + π4) + 19e-5 * p2 * Math.sin(l4 - π4 - G) + -19e-5 * p2 * Math.sin(2 * l4 - π3 - π4) + -18e-5 * p2 * Math.sin(l4 - π4 + G) + -16e-5 * p2 * Math.sin(l4 + π3 - 2 * Π - 2 * G);
  const L1 = l1 + Σ1;
  const L2 = l2 + Σ2;
  const L3 = l3 + Σ3;
  const L4 = l4 + Σ4;
  let I;
  const X = new Array(5).fill(0);
  const Y = new Array(5).fill(0);
  const Z = new Array(5).fill(0);
  let R;
  (function() {
    const L5 = [L1, L2, L3, L4];
    const B2 = [
      Math.atan(6393e-7 * Math.sin(L1 - ω1) + 1825e-7 * Math.sin(L1 - ω2) + 329e-7 * Math.sin(L1 - ω3) + -311e-7 * Math.sin(L1 - ψ) + 93e-7 * Math.sin(L1 - ω4) + 75e-7 * Math.sin(3 * L1 - 4 * l2 - 1.9927 * Σ1 + ω2) + 46e-7 * Math.sin(L1 + ψ - 2 * Π - 2 * G)),
      Math.atan(81004e-7 * Math.sin(L2 - ω2) + 4512e-7 * Math.sin(L2 - ω3) + -3284e-7 * Math.sin(L2 - ψ) + 116e-6 * Math.sin(L2 - ω4) + 272e-7 * Math.sin(l1 - 2 * l3 + 1.0146 * Σ2 + ω2) + -144e-7 * Math.sin(L2 - ω1) + 143e-7 * Math.sin(L2 + ψ - 2 * Π - 2 * G) + 35e-7 * Math.sin(L2 - ψ + G) + -28e-7 * Math.sin(l1 - 2 * l3 + 1.0146 * Σ2 + ω3)),
      Math.atan(32402e-7 * Math.sin(L3 - ω3) + -16911e-7 * Math.sin(L3 - ψ) + 6847e-7 * Math.sin(L3 - ω4) + -2797e-7 * Math.sin(L3 - ω2) + 321e-7 * Math.sin(L3 + ψ - 2 * Π - 2 * G) + 51e-7 * Math.sin(L3 - ψ + G) + -45e-7 * Math.sin(L3 - ψ - G) + -45e-7 * Math.sin(L3 + ψ - 2 * Π) + 37e-7 * Math.sin(L3 + ψ - 2 * Π - 3 * G) + 3e-6 * Math.sin(2 * l2 - 3 * L3 + 4.03 * Σ3 + ω2) + -21e-7 * Math.sin(2 * l2 - 3 * L3 + 4.03 * Σ3 + ω3)),
      Math.atan(-76579e-7 * Math.sin(L4 - ψ) + 44134e-7 * Math.sin(L4 - ω4) + -5112e-7 * Math.sin(L4 - ω3) + 773e-7 * Math.sin(L4 + ψ - 2 * Π - 2 * G) + 104e-7 * Math.sin(L4 - ψ + G) + -102e-7 * Math.sin(L4 - ψ - G) + 88e-7 * Math.sin(L4 + ψ - 2 * Π - 3 * G) + -38e-7 * Math.sin(L4 + ψ - 2 * Π - G))
    ];
    R = [
      5.90569 * (1 + -41339e-7 * Math.cos(2 * (l1 - l2)) + -387e-7 * Math.cos(l1 - π3) + -214e-7 * Math.cos(l1 - π4) + 17e-6 * Math.cos(l1 - l2) + -131e-7 * Math.cos(4 * (l1 - l2)) + 106e-7 * Math.cos(l1 - l3) + -66e-7 * Math.cos(l1 + π3 - 2 * Π - 2 * G)),
      9.39657 * (1 + 93848e-7 * Math.cos(l1 - l2) + -3116e-7 * Math.cos(l2 - π3) + -1744e-7 * Math.cos(l2 - π4) + -1442e-7 * Math.cos(l2 - π2) + 553e-7 * Math.cos(l2 - l3) + 523e-7 * Math.cos(l1 - l3) + -29e-6 * Math.cos(2 * (l1 - l2)) + 164e-7 * Math.cos(2 * (l2 - ω2)) + 107e-7 * Math.cos(l1 - 2 * l3 + π3) + -102e-7 * Math.cos(l2 - π1) + -91e-7 * Math.cos(2 * (l1 - l3))),
      14.98832 * (1 + -14388e-7 * Math.cos(l3 - π3) + -7917e-7 * Math.cos(l3 - π4) + 6342e-7 * Math.cos(l2 - l3) + -1761e-7 * Math.cos(2 * (l3 - l4)) + 294e-7 * Math.cos(l3 - l4) + -156e-7 * Math.cos(3 * (l3 - l4)) + 156e-7 * Math.cos(l1 - l3) + -153e-7 * Math.cos(l1 - l2) + 7e-6 * Math.cos(2 * l2 - 3 * l3 + π3) + -51e-7 * Math.cos(l3 + π3 - 2 * Π - 2 * G)),
      26.36273 * (1 + -73546e-7 * Math.cos(l4 - π4) + 1621e-7 * Math.cos(l4 - π3) + 974e-7 * Math.cos(l3 - l4) + -543e-7 * Math.cos(l4 + π4 - 2 * Π - 2 * G) + -271e-7 * Math.cos(2 * (l4 - π4)) + 182e-7 * Math.cos(l4 - Π) + 177e-7 * Math.cos(2 * (l3 - l4)) + -167e-7 * Math.cos(2 * l4 - ψ - ω4) + 167e-7 * Math.cos(ψ - ω4) + -155e-7 * Math.cos(2 * (l4 - Π - G)) + 142e-7 * Math.cos(2 * (l4 - ψ)) + 105e-7 * Math.cos(l1 - l4) + 92e-7 * Math.cos(l2 - l4) + -89e-7 * Math.cos(l4 - Π - G) + -62e-7 * Math.cos(l4 + π4 - 2 * Π - 3 * G) + 48e-7 * Math.cos(2 * (l4 - ω4)))
    ];
    const T0 = (jde - 2433282423e-3) / base_default.JulianCentury;
    const P = (1.3966626 * p2 + 3088e-7 * p2 * T0) * T0;
    for (const i in L5) {
      L5[i] += P;
    }
    ψ += P;
    const T = (jde - base_default.J1900) / base_default.JulianCentury;
    I = 3.120262 * p2 + 6e-4 * p2 * T;
    for (const i in L5) {
      const [sLψ, cLψ] = base_default.sincos(L5[i] - ψ);
      const [sB, cB] = base_default.sincos(B2[i]);
      X[i] = R[i] * cLψ * cB;
      Y[i] = R[i] * sLψ * cB;
      Z[i] = R[i] * sB;
    }
  })();
  Z[4] = 1;
  const A = new Array(5).fill(0);
  const B = new Array(5).fill(0);
  const C2 = new Array(5).fill(0);
  const [sI2, cI2] = base_default.sincos(I);
  const Ω = planetelements_default.node(planetelements_default.jupiter, jde);
  const [sΩ, cΩ] = base_default.sincos(Ω);
  const [sΦ, cΦ] = base_default.sincos(ψ - Ω);
  const [si, ci] = base_default.sincos(planetelements_default.inc(planetelements_default.jupiter, jde));
  const [sλ0, cλ0] = base_default.sincos(λ0);
  const [sβ0, cβ0] = base_default.sincos(β0);
  for (const i in A) {
    let a0;
    let a = X[i];
    let b = Y[i] * cI2 - Z[i] * sI2;
    let c3 = Y[i] * sI2 + Z[i] * cI2;
    a0 = a * cΦ - b * sΦ;
    b = a * sΦ + b * cΦ;
    a = a0;
    const b0 = b * ci - c3 * si;
    c3 = b * si + c3 * ci;
    b = b0;
    a0 = a * cΩ - b * sΩ;
    b = a * sΩ + b * cΩ;
    a = a0;
    a0 = a * sλ0 - b * cλ0;
    b = a * cλ0 + b * sλ0;
    a = a0;
    A[i] = a;
    B[i] = c3 * sβ0 + b * cβ0;
    C2[i] = c3 * cβ0 - b * sβ0;
  }
  const [sD, cD] = base_default.sincos(Math.atan2(A[4], C2[4]));
  for (let i = 0; i < 4; i++) {
    let x = A[i] * cD - C2[i] * sD;
    const y = A[i] * sD + C2[i] * cD;
    const z = B[i];
    const d3 = x / R[i];
    x += Math.abs(z) / k[i] * Math.sqrt(1 - d3 * d3);
    const W = Δ / (Δ + z / 2095);
    pos[i] = new XY(x * W, y * W);
  }
  return pos;
}
var jupitermoons_default = {
  io,
  europa,
  ganymede,
  callisto,
  positions,
  e5
};

// node_modules/astronomia/src/line.js
function time(r1, d1, r2, d22, r3, d3, t1, t5) {
  if (r3.length !== 5 || d3.length !== 5) {
    throw new Error("r3, d3 must be length 5");
  }
  const gc = new Array(5);
  r3.forEach((r3i, i) => {
    gc[i] = Math.tan(d1) * Math.sin(r2 - r3i) + Math.tan(d22) * Math.sin(r3i - r1) + Math.tan(d3[i]) * Math.sin(r1 - r2);
  });
  const l5 = new interpolation_default.Len5(t1, t5, gc);
  return l5.zero(false);
}
function angle(r1, d1, r2, d22, r3, d3) {
  const [sd2, cd2] = base_default.sincos(d22);
  const [sr21, cr21] = base_default.sincos(r2 - r1);
  const [sr32, cr32] = base_default.sincos(r3 - r2);
  const C1 = Math.atan2(sr21, cd2 * Math.tan(d1) - sd2 * cr21);
  const C2 = Math.atan2(sr32, cd2 * Math.tan(d3) - sd2 * cr32);
  return C1 + C2;
}
function error(r1, d1, r2, d22, r0, d0) {
  const [sr1, cr1] = base_default.sincos(r1);
  const [sd1, cd1] = base_default.sincos(d1);
  const [sr2, cr2] = base_default.sincos(r2);
  const [sd2, cd2] = base_default.sincos(d22);
  const X1 = cd1 * cr1;
  const X2 = cd2 * cr2;
  const Y1 = cd1 * sr1;
  const Y2 = cd2 * sr2;
  const Z1 = sd1;
  const Z2 = sd2;
  const A = Y1 * Z2 - Z1 * Y2;
  const B = Z1 * X2 - X1 * Z2;
  const C2 = X1 * Y2 - Y1 * X2;
  const m3 = Math.tan(r0);
  const n = Math.tan(d0) / Math.cos(r0);
  return Math.asin((A + B * m3 + C2 * n) / (Math.sqrt(A * A + B * B + C2 * C2) * Math.sqrt(1 + m3 * m3 + n * n)));
}
function angleError(r1, d1, r2, d22, r3, d3) {
  const [sr1, cr1] = base_default.sincos(r1);
  const [c1, cd1] = base_default.sincos(d1);
  const [sr2, cr2] = base_default.sincos(r2);
  const [c22, cd2] = base_default.sincos(d22);
  const [sr3, cr3] = base_default.sincos(r3);
  const [c3, cd3] = base_default.sincos(d3);
  const a1 = cd1 * cr1;
  const a2 = cd2 * cr2;
  const a3 = cd3 * cr3;
  const b1 = cd1 * sr1;
  const b2 = cd2 * sr2;
  const b3 = cd3 * sr3;
  const l1 = b1 * c22 - b2 * c1;
  const l2 = b2 * c3 - b3 * c22;
  const l3 = b1 * c3 - b3 * c1;
  const m1 = c1 * a2 - c22 * a1;
  const m22 = c22 * a3 - c3 * a2;
  const m3 = c1 * a3 - c3 * a1;
  const n1 = a1 * b2 - a2 * b1;
  const n2 = a2 * b3 - a3 * b2;
  const n3 = a1 * b3 - a3 * b1;
  const ψ = Math.acos((l1 * l2 + m1 * m22 + n1 * n2) / (Math.sqrt(l1 * l1 + m1 * m1 + n1 * n1) * Math.sqrt(l2 * l2 + m22 * m22 + n2 * n2)));
  const ω = Math.asin((a2 * l3 + b2 * m3 + c22 * n3) / (Math.sqrt(a2 * a2 + b2 * b2 + c22 * c22) * Math.sqrt(l3 * l3 + m3 * m3 + n3 * n3)));
  return [ψ, ω];
}
var line_default = {
  time,
  angle,
  error,
  angleError
};

// node_modules/astronomia/src/nearparabolic.js
var Elements4 = class {
  /**
   * @param {Number} timeP - time of Perihelion, T
   * @param {Number} pDis - Perihelion distance, q
   * @param {Number} ecc - eccentricity, e
   */
  constructor(timeP, pDis, ecc) {
    this.timeP = timeP;
    this.pDis = pDis;
    this.ecc = ecc;
  }
  /**
   * AnomalyDistance returns true anomaly and distance for near-parabolic orbits.
   *
   * True anomaly ν returned in radians. Distance r returned in AU.
   * An error is returned if the algorithm fails to converge.
   */
  anomalyDistance(jde) {
    const q1 = base_default.K * Math.sqrt((1 + this.ecc) / this.pDis) / (2 * this.pDis);
    const g2 = (1 - this.ecc) / (1 + this.ecc);
    const t = jde - this.timeP;
    if (t === 0) {
      return { ano: 0, dist: this.pDis, err: null };
    }
    const d1 = 1e4;
    const d3 = 1e-9;
    const q2 = q1 * t;
    let s2 = 2 / (3 * Math.abs(q2));
    s2 = 2 / Math.tan(2 * Math.atan(Math.cbrt(Math.tan(Math.atan(s2) / 2))));
    if (t < 0) {
      s2 = -s2;
    }
    if (this.ecc !== 1) {
      let l = 0;
      for (; ; ) {
        const s0 = s2;
        let z = 1;
        const y = s2 * s2;
        let g1 = -y * s2;
        let q3 = q2 + 2 * g2 * s2 * y / 3;
        for (; ; ) {
          z += 1;
          g1 = -g1 * g2 * y;
          const z1 = (z - (z + 1) * g2) / (2 * z + 1);
          const f = z1 * g1;
          q3 += f;
          if (z > 50 || Math.abs(f) > d1) {
            return {
              err: new Error("No convergence")
            };
          }
          if (Math.abs(f) <= d3) {
            break;
          }
        }
        l++;
        if (l > 50) {
          return {
            err: new Error("No convergence")
          };
        }
        for (; ; ) {
          const s1 = s2;
          s2 = (2 * s2 * s2 * s2 / 3 + q3) / (s2 * s2 + 1);
          if (Math.abs(s2 - s1) <= d3) {
            break;
          }
        }
        if (Math.abs(s2 - s0) <= d3) {
          break;
        }
      }
    }
    let ν = 2 * Math.atan(s2);
    const r = this.pDis * (1 + this.ecc) / (1 + this.ecc * Math.cos(ν));
    if (ν < 0) {
      ν += 2 * Math.PI;
    }
    return {
      ano: ν,
      dist: r,
      err: null
    };
  }
};
var nearparabolic_default = {
  Elements: Elements4
};

// node_modules/astronomia/src/node.js
function ellipticAscending(axis, ecc, argP, timeP) {
  return el(-argP, axis, ecc, timeP);
}
function ellipticDescending(axis, ecc, argP, timeP) {
  return el(Math.PI - argP, axis, ecc, timeP);
}
function el(ν, axis, ecc, timeP) {
  const E = 2 * Math.atan(Math.sqrt((1 - ecc) / (1 + ecc)) * Math.tan(ν * 0.5));
  const [sE, cE] = base_default.sincos(E);
  const M = E - ecc * sE;
  const n = base_default.K / axis / Math.sqrt(axis);
  const jde = timeP + M / n;
  const r = axis * (1 - ecc * cE);
  return [jde, r];
}
function parabolicAscending(q, argP, timeP) {
  return pa(-argP, q, timeP);
}
function parabolicDescending(q, argP, timeP) {
  return pa(Math.PI - argP, q, timeP);
}
function pa(ν, q, timeP) {
  const s2 = Math.tan(ν * 0.5);
  const jde = timeP + 27.403895 * s2 * (s2 * s2 + 3) * q * Math.sqrt(q);
  const r = q * (1 + s2 * s2);
  return [jde, r];
}
var node_default = {
  ellipticAscending,
  ellipticDescending,
  el,
  parabolicAscending,
  parabolicDescending,
  pa
};

// node_modules/astronomia/src/mars.js
function physical3(jde, earth3, mars4) {
  const T = base_default.J2000Century(jde);
  const p2 = Math.PI / 180;
  let λ0 = 352.9065 * p2 + 1.1733 * p2 * T;
  const β0 = 63.2818 * p2 - 394e-5 * p2 * T;
  const earthPos = earth3.position(jde);
  const R = earthPos.range;
  const fk5 = planetposition_default.toFK5(earthPos.lon, earthPos.lat, jde);
  const [l02, b0] = [fk5.lon, fk5.lat];
  const [sl0, cl0] = base_default.sincos(l02);
  const sb0 = Math.sin(b0);
  let Δ = 0.5;
  let τ = base_default.lightTime(Δ);
  let l = 0;
  let b = 0;
  let r = 0;
  let x = 0;
  let y = 0;
  let z = 0;
  function f() {
    const marsPos = mars4.position(jde - τ);
    r = marsPos.range;
    const fk52 = planetposition_default.toFK5(marsPos.lon, marsPos.lat, jde);
    l = fk52.lon;
    b = fk52.lat;
    const [sb, cb] = base_default.sincos(b);
    const [sl, cl2] = base_default.sincos(l);
    x = r * cb * cl2 - R * cl0;
    y = r * cb * sl - R * sl0;
    z = r * sb - R * sb0;
    Δ = Math.sqrt(x * x + y * y + z * z);
    τ = base_default.lightTime(Δ);
  }
  f();
  f();
  let λ = Math.atan2(y, x);
  let β = Math.atan(z / Math.hypot(x, y));
  const [sβ0, cβ0] = base_default.sincos(β0);
  const [sβ, cβ] = base_default.sincos(β);
  const DE = Math.asin(-sβ0 * sβ - cβ0 * cβ * Math.cos(λ0 - λ));
  const N = 49.5581 * p2 + 0.7721 * p2 * T;
  const lʹ = l - 697e-5 * p2 / r;
  const bʹ = b - 225e-6 * p2 * Math.cos(l - N) / r;
  const [sbʹ, cbʹ] = base_default.sincos(bʹ);
  const DS = Math.asin(-sβ0 * sbʹ - cβ0 * cbʹ * Math.cos(λ0 - lʹ));
  const W = 11.504 * p2 + 350.89200025 * p2 * (jde - τ - 24332825e-1);
  const ε0 = nutation_default.meanObliquity(jde);
  const [sε0, cε0] = base_default.sincos(ε0);
  let eq3 = new coord_default.Ecliptic(λ0, β0).toEquatorial(ε0);
  const [α0, δ0] = [eq3.ra, eq3.dec];
  const u = y * cε0 - z * sε0;
  const v = y * sε0 + z * cε0;
  const α = Math.atan2(u, x);
  const δ = Math.atan(v / Math.hypot(x, u));
  const [sδ, cδ] = base_default.sincos(δ);
  const [sδ0, cδ0] = base_default.sincos(δ0);
  const [sα0α, cα0α] = base_default.sincos(α0 - α);
  const ζ = Math.atan2(sδ0 * cδ * cα0α - sδ * cδ0, cδ * sα0α);
  const ω = base_default.pmod(W - ζ, 2 * Math.PI);
  const [Δψ, Δε] = nutation_default.nutation(jde);
  const [sl0λ, cl0λ] = base_default.sincos(l02 - λ);
  λ += 5693e-6 * p2 * cl0λ / cβ;
  β += 5693e-6 * p2 * sl0λ * sβ;
  λ0 += Δψ;
  λ += Δψ;
  const ε = ε0 + Δε;
  const [sε, cε] = base_default.sincos(ε);
  eq3 = new coord_default.Ecliptic(λ0, β0).toEquatorial(ε);
  const [α0ʹ, δ0ʹ] = [eq3.ra, eq3.dec];
  eq3 = new coord_default.Ecliptic(λ, β).toEquatorial(ε);
  const [αʹ, δʹ] = [eq3.ra, eq3.dec];
  const [sδ0ʹ, cδ0ʹ] = base_default.sincos(δ0ʹ);
  const [sδʹ, cδʹ] = base_default.sincos(δʹ);
  const [sα0ʹαʹ, cα0ʹαʹ] = base_default.sincos(α0ʹ - αʹ);
  let P = Math.atan2(cδ0ʹ * sα0ʹαʹ, sδ0ʹ * cδʹ - cδ0ʹ * sδʹ * cα0ʹαʹ);
  if (P < 0) {
    P += 2 * Math.PI;
  }
  const s2 = l02 + Math.PI;
  const [ss, cs] = base_default.sincos(s2);
  const αs = Math.atan2(cε * ss, cs);
  const δs = Math.asin(sε * ss);
  const [sδs, cδs] = base_default.sincos(δs);
  const [sαsα, cαsα] = base_default.sincos(αs - α);
  const χ = Math.atan2(cδs * sαsα, sδs * cδ - cδs * sδ * cαsα);
  const Q = χ + Math.PI;
  const d3 = 9.36 / 60 / 60 * Math.PI / 180 / Δ;
  const k3 = illum_default.fraction(r, Δ, R);
  const q = (1 - k3) * d3;
  return [DE, DS, ω, P, Q, d3, k3, q];
}
var mars_default = {
  physical: physical3
};

// node_modules/astronomia/src/moonposition.js
var { asin: asin2, sin: sin5 } = Math;
var D2R4 = Math.PI / 180;
var EARTH_RADIUS2 = 6378.137;
function parallax(distance2) {
  return asin2(EARTH_RADIUS2 / distance2);
}
function dmf(T) {
  const d3 = base_default.horner(T, 297.8501921 * D2R4, 445267.1114034 * D2R4, -18819e-7 * D2R4, D2R4 / 545868, -D2R4 / 113065e3);
  const m3 = base_default.horner(T, 357.5291092 * D2R4, 35999.0502909 * D2R4, -1536e-7 * D2R4, D2R4 / 2449e4);
  const m_ = base_default.horner(
    T,
    134.9633964 * D2R4,
    477198.8675055 * D2R4,
    87414e-7 * D2R4,
    D2R4 / 69699,
    -D2R4 / 14712e3
  );
  const f = base_default.horner(T, 93.272095 * D2R4, 483202.0175233 * D2R4, -36539e-7 * D2R4, -D2R4 / 3526e3, D2R4 / 86331e4);
  return [d3, m3, m_, f];
}
function position7(jde) {
  const T = base_default.J2000Century(jde);
  const l_ = base_default.horner(T, 218.3164477 * D2R4, 481267.88123421 * D2R4, -15786e-7 * D2R4, D2R4 / 538841, -D2R4 / 65194e3);
  const [d3, m3, m_, f] = dmf(T);
  const a1 = 119.75 * D2R4 + 131.849 * D2R4 * T;
  const a2 = 53.09 * D2R4 + 479264.29 * D2R4 * T;
  const a3 = 313.45 * D2R4 + 481266.484 * D2R4 * T;
  const e2 = base_default.horner(T, 1, -2516e-6, -74e-7);
  const e22 = e2 * e2;
  let Σl = 3958 * sin5(a1) + 1962 * sin5(l_ - f) + 318 * sin5(a2);
  let Σr = 0;
  let Σb = -2235 * sin5(l_) + 382 * sin5(a3) + 175 * sin5(a1 - f) + 175 * sin5(a1 + f) + 127 * sin5(l_ - m_) - 115 * sin5(l_ + m_);
  ta.forEach((r) => {
    const [sina, cosa] = base_default.sincos(d3 * r.d + m3 * r.m + m_ * r.m_ + f * r.f);
    switch (r.m) {
      case 0:
        Σl += r.Σl * sina;
        Σr += r.Σr * cosa;
        break;
      case -1:
      case 1:
        Σl += r.Σl * sina * e2;
        Σr += r.Σr * cosa * e2;
        break;
      case -2:
      case 2:
        Σl += r.Σl * sina * e22;
        Σr += r.Σr * cosa * e22;
        break;
    }
  });
  tb.forEach((r) => {
    const sb = sin5(d3 * r.d + m3 * r.m + m_ * r.m_ + f * r.f);
    switch (r.m) {
      case 0:
        Σb += r.Σb * sb;
        break;
      case -1:
      case 1:
        Σb += r.Σb * sb * e2;
        break;
      case -2:
      case 2:
        Σb += r.Σb * sb * e22;
        break;
    }
  });
  const lon = base_default.pmod(l_, 2 * Math.PI) + Σl * 1e-6 * D2R4;
  const lat = Σb * 1e-6 * D2R4;
  const range = 385000.56 + Σr * 1e-3;
  return new base_default.Coord(lon, lat, range);
}
var ta = function() {
  const ta2 = [
    [0, 0, 1, 0, 6288774, -20905355],
    [2, 0, -1, 0, 1274027, -3699111],
    [2, 0, 0, 0, 658314, -2955968],
    [0, 0, 2, 0, 213618, -569925],
    [0, 1, 0, 0, -185116, 48888],
    [0, 0, 0, 2, -114332, -3149],
    [2, 0, -2, 0, 58793, 246158],
    [2, -1, -1, 0, 57066, -152138],
    [2, 0, 1, 0, 53322, -170733],
    [2, -1, 0, 0, 45758, -204586],
    [0, 1, -1, 0, -40923, -129620],
    [1, 0, 0, 0, -34720, 108743],
    [0, 1, 1, 0, -30383, 104755],
    [2, 0, 0, -2, 15327, 10321],
    [0, 0, 1, 2, -12528, 0],
    [0, 0, 1, -2, 10980, 79661],
    [4, 0, -1, 0, 10675, -34782],
    [0, 0, 3, 0, 10034, -23210],
    [4, 0, -2, 0, 8548, -21636],
    [2, 1, -1, 0, -7888, 24208],
    [2, 1, 0, 0, -6766, 30824],
    [1, 0, -1, 0, -5163, -8379],
    [1, 1, 0, 0, 4987, -16675],
    [2, -1, 1, 0, 4036, -12831],
    [2, 0, 2, 0, 3994, -10445],
    [4, 0, 0, 0, 3861, -11650],
    [2, 0, -3, 0, 3665, 14403],
    [0, 1, -2, 0, -2689, -7003],
    [2, 0, -1, 2, -2602, 0],
    [2, -1, -2, 0, 2390, 10056],
    [1, 0, 1, 0, -2348, 6322],
    [2, -2, 0, 0, 2236, -9884],
    [0, 1, 2, 0, -2120, 5751],
    [0, 2, 0, 0, -2069, 0],
    [2, -2, -1, 0, 2048, -4950],
    [2, 0, 1, -2, -1773, 4130],
    [2, 0, 0, 2, -1595, 0],
    [4, -1, -1, 0, 1215, -3958],
    [0, 0, 2, 2, -1110, 0],
    [3, 0, -1, 0, -892, 3258],
    [2, 1, 1, 0, -810, 2616],
    [4, -1, -2, 0, 759, -1897],
    [0, 2, -1, 0, -713, -2117],
    [2, 2, -1, 0, -700, 2354],
    [2, 1, -2, 0, 691, 0],
    [2, -1, 0, -2, 596, 0],
    [4, 0, 1, 0, 549, -1423],
    [0, 0, 4, 0, 537, -1117],
    [4, -1, 0, 0, 520, -1571],
    [1, 0, -2, 0, -487, -1739],
    [2, 1, 0, -2, -399, 0],
    [0, 0, 2, -2, -381, -4421],
    [1, 1, 1, 0, 351, 0],
    [3, 0, -2, 0, -340, 0],
    [4, 0, -3, 0, 330, 0],
    [2, -1, 2, 0, 327, 0],
    [0, 2, 1, 0, -323, 1165],
    [1, 1, -1, 0, 299, 0],
    [2, 0, 3, 0, 294, 0],
    [2, 0, -1, -2, 0, 8752]
  ];
  return ta2.map((row) => {
    const o = {};
    const vals = ["d", "m", "m_", "f", "Σl", "Σr"];
    vals.forEach((D2R10, i) => {
      o[D2R10] = row[i];
    });
    return o;
  });
}();
var tb = function() {
  const tb2 = [
    [0, 0, 0, 1, 5128122],
    [0, 0, 1, 1, 280602],
    [0, 0, 1, -1, 277693],
    [2, 0, 0, -1, 173237],
    [2, 0, -1, 1, 55413],
    [2, 0, -1, -1, 46271],
    [2, 0, 0, 1, 32573],
    [0, 0, 2, 1, 17198],
    [2, 0, 1, -1, 9266],
    [0, 0, 2, -1, 8822],
    [2, -1, 0, -1, 8216],
    [2, 0, -2, -1, 4324],
    [2, 0, 1, 1, 4200],
    [2, 1, 0, -1, -3359],
    [2, -1, -1, 1, 2463],
    [2, -1, 0, 1, 2211],
    [2, -1, -1, -1, 2065],
    [0, 1, -1, -1, -1870],
    [4, 0, -1, -1, 1828],
    [0, 1, 0, 1, -1794],
    [0, 0, 0, 3, -1749],
    [0, 1, -1, 1, -1565],
    [1, 0, 0, 1, -1491],
    [0, 1, 1, 1, -1475],
    [0, 1, 1, -1, -1410],
    [0, 1, 0, -1, -1344],
    [1, 0, 0, -1, -1335],
    [0, 0, 3, 1, 1107],
    [4, 0, 0, -1, 1021],
    [4, 0, -1, 1, 833],
    [0, 0, 1, -3, 777],
    [4, 0, -2, 1, 671],
    [2, 0, 0, -3, 607],
    [2, 0, 2, -1, 596],
    [2, -1, 1, -1, 491],
    [2, 0, -2, 1, -451],
    [0, 0, 3, -1, 439],
    [2, 0, 2, 1, 422],
    [2, 0, -3, -1, 421],
    [2, 1, -1, 1, -366],
    [2, 1, 0, 1, -351],
    [4, 0, 0, 1, 331],
    [2, -1, 1, 1, 315],
    [2, -2, 0, -1, 302],
    [0, 0, 1, 3, -283],
    [2, 1, 1, -1, -229],
    [1, 1, 0, -1, 223],
    [1, 1, 0, 1, 223],
    [0, 1, -2, -1, -220],
    [2, 1, -1, -1, -220],
    [1, 0, 1, 1, -185],
    [2, -1, -2, -1, 181],
    [0, 1, 2, 1, -177],
    [4, 0, -2, -1, 176],
    [4, -1, -1, -1, 166],
    [1, 0, 1, -1, -164],
    [4, 0, 1, -1, 132],
    [1, 0, -1, -1, -119],
    [4, -1, 0, -1, 115],
    [2, -2, 0, 1, 107]
  ];
  return tb2.map((row) => {
    const o = {};
    const vals = ["d", "m", "m_", "f", "Σb"];
    vals.forEach((D2R10, i) => {
      o[D2R10] = row[i];
    });
    return o;
  });
}();
function node3(jde) {
  return base_default.pmod(
    base_default.horner(
      base_default.J2000Century(jde),
      125.0445479 * D2R4,
      -1934.1362891 * D2R4,
      20754e-7 * D2R4,
      D2R4 / 467441,
      -D2R4 / 60616e3
    ),
    2 * Math.PI
  );
}
function perigee2(jde) {
  return base_default.pmod(
    base_default.horner(
      base_default.J2000Century(jde),
      83.3532465 * D2R4,
      4069.0137287 * D2R4,
      -0.01032 * D2R4,
      -D2R4 / 80053,
      D2R4 / 18999e3
    ),
    2 * Math.PI
  );
}
function trueNode(jde) {
  const [d3, m3, m_, f] = dmf(base_default.J2000Century(jde));
  return node3(jde) + -1.4979 * D2R4 * sin5(2 * (d3 - f)) + -0.15 * D2R4 * sin5(m3) + -0.1226 * D2R4 * sin5(2 * d3) + 0.1176 * D2R4 * sin5(2 * f) + -0.0801 * D2R4 * sin5(2 * (m_ - f));
}
var moonposition_default = {
  parallax,
  position: position7,
  node: node3,
  perigee: perigee2,
  trueNode
};

// node_modules/astronomia/src/moon.js
var { sin: sin6, cos: cos7, asin: asin3, atan2: atan23 } = Math;
var D2R5 = Math.PI / 180;
var _I = 1.54242 * D2R5;
var [sI, cI] = base_default.sincos(_I);
function physical4(jde, earth3) {
  const { lon, lat, range } = moonposition_default.position(jde);
  const m3 = new Moon2(jde);
  const [l, b] = m3.lib(lon, lat);
  const P = m3.pa(lon, lat, b);
  const [l02, b0] = m3.sun(lon, lat, range, earth3);
  const cMoon = new base_default.Coord(l, b);
  const cSun = new base_default.Coord(l02, b0);
  return [cMoon, P, cSun];
}
var Moon2 = class {
  constructor(jde) {
    this.jde = jde;
    const [Δψ, Δε] = nutation_default.nutation(jde);
    this.Δψ = Δψ;
    const T = base_default.J2000Century(jde);
    const F = this.F = base_default.horner(T, 93.272095 * D2R5, 483202.0175233 * D2R5, -36539e-7 * D2R5, -D2R5 / 3526e3, D2R5 / 86331e4);
    this.Ω = base_default.horner(
      T,
      125.0445479 * D2R5,
      -1934.1362891 * D2R5,
      20754e-7 * D2R5,
      D2R5 / 467441,
      -D2R5 / 60616e3
    );
    this.ε = nutation_default.meanObliquity(jde) + Δε;
    this.sε = sin6(this.ε);
    this.cε = cos7(this.ε);
    const D = base_default.horner(T, 297.8501921 * D2R5, 445267.1114034 * D2R5, -18819e-7 * D2R5, D2R5 / 545868, -D2R5 / 113065e3);
    const M = base_default.horner(T, 357.5291092 * D2R5, 35999.0502909 * D2R5, -1536e-7 * D2R5, D2R5 / 2449e4);
    const M_ = base_default.horner(
      T,
      134.9633964 * D2R5,
      477198.8675055 * D2R5,
      87414e-7 * D2R5,
      D2R5 / 69699,
      -D2R5 / 14712e3
    );
    const E = base_default.horner(T, 1, -2516e-6, -74e-7);
    const K1 = 119.75 * D2R5 + 131.849 * D2R5 * T;
    const K2 = 72.56 * D2R5 + 20.186 * D2R5 * T;
    this.ρ = -0.02752 * D2R5 * cos7(M_) + -0.02245 * D2R5 * sin6(F) + 684e-5 * D2R5 * cos7(M_ - 2 * F) + -293e-5 * D2R5 * cos7(2 * F) + -85e-5 * D2R5 * cos7(2 * (F - D)) + -54e-5 * D2R5 * cos7(M_ - 2 * D) + -2e-4 * D2R5 * sin6(M_ + F) + -2e-4 * D2R5 * cos7(M_ + 2 * F) + -2e-4 * D2R5 * cos7(M_ - F) + 14e-5 * D2R5 * cos7(M_ + 2 * (F - D));
    this.σ = -0.02816 * D2R5 * sin6(M_) + 0.02244 * D2R5 * cos7(F) + -682e-5 * D2R5 * sin6(M_ - 2 * F) + -279e-5 * D2R5 * sin6(2 * F) + -83e-5 * D2R5 * sin6(2 * (F - D)) + 69e-5 * D2R5 * sin6(M_ - 2 * D) + 4e-4 * D2R5 * cos7(M_ + F) + -25e-5 * D2R5 * sin6(2 * M_) + -23e-5 * D2R5 * sin6(M_ + 2 * F) + 2e-4 * D2R5 * cos7(M_ - F) + 19e-5 * D2R5 * sin6(M_ - F) + 13e-5 * D2R5 * sin6(M_ + 2 * (F - D)) + -1e-4 * D2R5 * cos7(M_ - 3 * F);
    this.τ = 0.0252 * D2R5 * sin6(M) * E + 473e-5 * D2R5 * sin6(2 * (M_ - F)) + -467e-5 * D2R5 * sin6(M_) + 396e-5 * D2R5 * sin6(K1) + 276e-5 * D2R5 * sin6(2 * (M_ - D)) + 196e-5 * D2R5 * sin6(this.Ω) + -183e-5 * D2R5 * cos7(M_ - F) + 115e-5 * D2R5 * sin6(M_ - 2 * D) + -96e-5 * D2R5 * sin6(M_ - D) + 46e-5 * D2R5 * sin6(2 * (F - D)) + -39e-5 * D2R5 * sin6(M_ - F) + -32e-5 * D2R5 * sin6(M_ - M - D) + 27e-5 * D2R5 * sin6(2 * (M_ - D) - M) + 23e-5 * D2R5 * sin6(K2) + -14e-5 * D2R5 * sin6(2 * D) + 14e-5 * D2R5 * cos7(2 * (M_ - F)) + -12e-5 * D2R5 * sin6(M_ - 2 * F) + -12e-5 * D2R5 * sin6(2 * M_) + 11e-5 * D2R5 * sin6(2 * (M_ - M - D));
  }
  /**
   * lib() curiously serves for computing both librations and solar coordinates,
   * depending on the coordinates λ, β passed in.  Quantity A not described in
   * the book, but clearly depends on the λ, β of the current context and so
   * does not belong in the moon struct.  Instead just return it from optical
   * and pass it along to physical.
   */
  lib(λ, β) {
    const [l_, b_, A] = this.optical(λ, β);
    const [l$, b$] = this.physical(A, b_);
    let l = l_ + l$;
    if (l > Math.PI) {
      l -= 2 * Math.PI;
    }
    const b = b_ + b$;
    return [l, b];
  }
  optical(λ, β) {
    const W = λ - this.Ω;
    const [sW, cW] = base_default.sincos(W);
    const [sβ, cβ] = base_default.sincos(β);
    const A = atan23(sW * cβ * cI - sβ * sI, cW * cβ);
    const l_ = base_default.pmod(A - this.F, 2 * Math.PI);
    const b_ = asin3(-sW * cβ * sI - sβ * cI);
    return [l_, b_, A];
  }
  physical(A, b_) {
    const [sA, cA] = base_default.sincos(A);
    const l$ = -this.τ + (this.ρ * cA + this.σ * sA) * Math.tan(b_);
    const b$ = this.σ * cA - this.ρ * sA;
    return [l$, b$];
  }
  pa(λ, β, b) {
    const V = this.Ω + this.Δψ + this.σ / sI;
    const [sV, cV] = base_default.sincos(V);
    const [sIρ, cIρ] = base_default.sincos(_I + this.ρ);
    const X = sIρ * sV;
    const Y = sIρ * cV * this.cε - cIρ * this.sε;
    const ω = Math.atan2(X, Y);
    const ecl = new coord_default.Ecliptic(λ + this.Δψ, β).toEquatorial(this.ε);
    let P = asin3(Math.hypot(X, Y) * cos7(ecl.ra - ω) / cos7(b));
    if (P < 0) {
      P += 2 * Math.PI;
    }
    return P;
  }
  sun(λ, β, Δ, earth3) {
    const { lon, lat, range } = solar_default.apparentVSOP87(earth3, this.jde);
    const ΔR = Δ / (range * base_default.AU);
    const λH = lon + Math.PI + 57.296 * D2R5 * ΔR * cos7(β) * sin6(lon - λ);
    const βH = ΔR * β;
    return this.lib(λH, βH);
  }
};
function sunAltitude(cOnMoon, cSun) {
  const c0 = Math.PI / 2 - cSun.lon;
  const [sb0, cb0] = base_default.sincos(cSun.lat);
  const [sθ, cθ] = base_default.sincos(cOnMoon.lat);
  return asin3(sb0 * sθ + cb0 * cθ * sin6(c0 + cOnMoon.lon));
}
function sunrise(cOnMoon, jde, earth3) {
  jde -= srCorr(cOnMoon, jde, earth3);
  return jde - srCorr(cOnMoon, jde, earth3);
}
function sunset(cOnMoon, jde, earth3) {
  jde += srCorr(cOnMoon, jde, earth3);
  return jde + srCorr(cOnMoon, jde, earth3);
}
function srCorr(cOnMoon, jde, earth3) {
  const phy = physical4(jde, earth3);
  const h = sunAltitude(cOnMoon, phy[2]);
  return h / (12.19075 * D2R5 * cos7(cOnMoon.lat));
}
var lunarCoord = (η, θ) => new base_default.Coord(η * D2R5, θ * D2R5);
var selenographic = {
  archimedes: lunarCoord(-3.9, 29.7),
  aristarchus: lunarCoord(-47.5, 23.7),
  aristillus: lunarCoord(1.2, 33.9),
  aristoteles: lunarCoord(17.3, 50.1),
  arzachel: lunarCoord(-1.9, -17.7),
  autolycus: lunarCoord(1.5, 30.7),
  billy: lunarCoord(-50, -13.8),
  birt: lunarCoord(-8.5, -22.3),
  campanus: lunarCoord(-27.7, -28),
  censorinus: lunarCoord(32.7, -0.4),
  clavius: lunarCoord(-14, -58),
  copernicus: lunarCoord(-20, 9.7),
  delambre: lunarCoord(17.5, -1.9),
  dionysius: lunarCoord(17.3, 2.8),
  endymion: lunarCoord(56.4, 53.6),
  eratosthenes: lunarCoord(-11.3, 14.5),
  eudoxus: lunarCoord(16.3, 44.3),
  fracastorius: lunarCoord(33.2, -21),
  fraMauro: lunarCoord(-17, -6),
  gassendi: lunarCoord(-39.9, -17.5),
  goclenius: lunarCoord(45, -10.1),
  grimaldi: lunarCoord(-68.5, -5.8),
  harpalus: lunarCoord(-43.4, 52.6),
  horrocks: lunarCoord(5.9, -4),
  kepler: lunarCoord(-38, 8.1),
  langrenus: lunarCoord(60.9, -8.9),
  lansberg: lunarCoord(-26.6, -0.3),
  letronne: lunarCoord(-43, -10),
  macrobius: lunarCoord(46, 21.2),
  manilius: lunarCoord(9.1, 14.5),
  menelaus: lunarCoord(16, 16.3),
  messier: lunarCoord(47.6, -1.9),
  petavius: lunarCoord(61, -25),
  pico: lunarCoord(-8.8, 45.8),
  pitatus: lunarCoord(-13.5, -29.8),
  piton: lunarCoord(-0.8, 40.8),
  plato: lunarCoord(-9.2, 51.4),
  plinius: lunarCoord(23.6, 15.3),
  posidonius: lunarCoord(30, 31.9),
  proclus: lunarCoord(46.9, 16.1),
  ptolemeusA: lunarCoord(-0.8, -8.5),
  pytheas: lunarCoord(-20.6, 20.5),
  reinhold: lunarCoord(-22.8, 3.2),
  riccioli: lunarCoord(-74.3, -3.2),
  schickard: lunarCoord(-54.5, -44),
  schiller: lunarCoord(-39, -52),
  tauruntius: lunarCoord(46.5, 5.6),
  theophilus: lunarCoord(26.5, -11.4),
  timocharis: lunarCoord(-13.1, 26.7),
  tycho: lunarCoord(-11, -43.2),
  vitruvius: lunarCoord(31.3, 17.6),
  walter: lunarCoord(1, -33)
};
var moon_default = {
  physical: physical4,
  Moon: Moon2,
  // Topocentric,
  // TopocentricCorrections,
  sunAltitude,
  sunrise,
  sunset,
  selenographic
};

// node_modules/astronomia/src/moonillum.js
var D2R6 = Math.PI / 180;
function phaseAngleEquatorial(cMoon, cSun) {
  return pa2(cMoon.range, cSun.range, cosEq(cMoon.ra, cMoon.dec, cSun.ra, cSun.dec));
}
function cosEq(α, δ, α0, δ0) {
  const [sδ, cδ] = base_default.sincos(δ);
  const [sδ0, cδ0] = base_default.sincos(δ0);
  return sδ0 * sδ + cδ0 * cδ * Math.cos(α0 - α);
}
function pa2(Δ, R, cψ) {
  const sψ = Math.sin(Math.acos(cψ));
  let i = Math.atan(R * sψ / (Δ - R * cψ));
  if (i < 0) {
    i += Math.PI;
  }
  return i;
}
function phaseAngleEquatorial2(cMoon, cSun) {
  return Math.acos(-cosEq(cMoon.ra, cMoon.dec, cSun.ra, cSun.dec));
}
function phaseAngleEcliptic(cMoon, cSun) {
  return pa2(cMoon.range, cSun.range, cosEcl(cMoon.lon, cMoon.lat, cSun.lon));
}
function cosEcl(λ, β, λ0) {
  return Math.cos(β) * Math.cos(λ - λ0);
}
function phaseAngleEcliptic2(cMoon, cSun) {
  return Math.acos(-cosEcl(cMoon.lon, cMoon.lat, cSun.lon));
}
function phaseAngle32(jde) {
  const T = base_default.J2000Century(jde);
  const D = base_default.horner(
    T,
    297.8501921 * D2R6,
    445267.1114034 * D2R6,
    -18819e-7 * D2R6,
    D2R6 / 545868,
    -D2R6 / 113065e3
  );
  const m3 = base_default.horner(
    T,
    357.5291092 * D2R6,
    35999.0502909 * D2R6,
    -1536e-7 * D2R6,
    D2R6 / 2449e4
  );
  const m_ = base_default.horner(
    T,
    134.9633964 * D2R6,
    477198.8675055 * D2R6,
    87414e-7 * D2R6,
    D2R6 / 69699,
    -D2R6 / 14712e3
  );
  return Math.PI - base_default.pmod(D, 2 * Math.PI) + -6.289 * D2R6 * Math.sin(m_) + 2.1 * D2R6 * Math.sin(m3) + -1.274 * D2R6 * Math.sin(2 * D - m_) + -0.658 * D2R6 * Math.sin(2 * D) + -0.214 * D2R6 * Math.sin(2 * m_) + -0.11 * D2R6 * Math.sin(D);
}
var moonillum_default = {
  phaseAngleEquatorial,
  phaseAngleEquatorial2,
  phaseAngleEcliptic,
  phaseAngleEcliptic2,
  phaseAngle3: phaseAngle32
};

// node_modules/astronomia/src/moonmaxdec.js
function north(y) {
  return max(y, nc2);
}
function south(y) {
  return max(y, sc);
}
var p = Math.PI / 180;
var ck3 = 1 / 1336.86;
function max(y, c3) {
  let k3 = (y - 2000.03) * 13.3686;
  k3 = Math.floor(k3 + 0.5);
  const T = k3 * ck3;
  const D = base_default.horner(T, c3.D, 333.0705546 * p / ck3, -4214e-7 * p, 11e-8 * p);
  const m3 = base_default.horner(T, c3.m, 26.9281592 * p / ck3, -355e-7 * p, -1e-7 * p);
  const m_ = base_default.horner(T, c3.m_, 356.9562794 * p / ck3, 0.0103066 * p, 1251e-8 * p);
  const f = base_default.horner(T, c3.f, 1.4467807 * p / ck3, -2069e-6 * p, -215e-8 * p);
  const E = base_default.horner(T, 1, -2516e-6, -74e-7);
  const jde = base_default.horner(T, c3.JDE, 27.321582247 / ck3, 119804e-9, -141e-9) + c3.tc[0] * Math.cos(f) + c3.tc[1] * Math.sin(m_) + c3.tc[2] * Math.sin(2 * f) + c3.tc[3] * Math.sin(2 * D - m_) + c3.tc[4] * Math.cos(m_ - f) + c3.tc[5] * Math.cos(m_ + f) + c3.tc[6] * Math.sin(2 * D) + c3.tc[7] * Math.sin(m3) * E + c3.tc[8] * Math.cos(3 * f) + c3.tc[9] * Math.sin(m_ + 2 * f) + c3.tc[10] * Math.cos(2 * D - f) + c3.tc[11] * Math.cos(2 * D - m_ - f) + c3.tc[12] * Math.cos(2 * D - m_ + f) + c3.tc[13] * Math.cos(2 * D + f) + c3.tc[14] * Math.sin(2 * m_) + c3.tc[15] * Math.sin(m_ - 2 * f) + c3.tc[16] * Math.cos(2 * m_ - f) + c3.tc[17] * Math.sin(m_ + 3 * f) + c3.tc[18] * Math.sin(2 * D - m3 - m_) * E + c3.tc[19] * Math.cos(m_ - 2 * f) + c3.tc[20] * Math.sin(2 * (D - m_)) + c3.tc[21] * Math.sin(f) + c3.tc[22] * Math.sin(2 * D + m_) + c3.tc[23] * Math.cos(m_ + 2 * f) + c3.tc[24] * Math.sin(2 * D - m3) * E + c3.tc[25] * Math.sin(m_ + f) + c3.tc[26] * Math.sin(m3 - m_) * E + c3.tc[27] * Math.sin(m_ - 3 * f) + c3.tc[28] * Math.sin(2 * m_ + f) + c3.tc[29] * Math.cos(2 * (D - m_) - f) + c3.tc[30] * Math.sin(3 * f) + c3.tc[31] * Math.cos(m_ + 3 * f) + c3.tc[32] * Math.cos(2 * m_) + c3.tc[33] * Math.cos(2 * D - m_) + c3.tc[34] * Math.cos(2 * D + m_ + f) + c3.tc[35] * Math.cos(m_) + c3.tc[36] * Math.sin(3 * m_ + f) + c3.tc[37] * Math.sin(2 * D - m_ + f) + c3.tc[38] * Math.cos(2 * (D - m_)) + c3.tc[39] * Math.cos(D + f) + c3.tc[40] * Math.sin(m3 + m_) * E + c3.tc[41] * Math.sin(2 * (D - f)) + c3.tc[42] * Math.cos(2 * m_ + f) + c3.tc[43] * Math.cos(3 * m_ + f);
  const δ = 23.6961 * p - 0.013004 * p * T + c3.dc[0] * Math.sin(f) + c3.dc[1] * Math.cos(2 * f) + c3.dc[2] * Math.sin(2 * D - f) + c3.dc[3] * Math.sin(3 * f) + c3.dc[4] * Math.cos(2 * (D - f)) + c3.dc[5] * Math.cos(2 * D) + c3.dc[6] * Math.sin(m_ - f) + c3.dc[7] * Math.sin(m_ + 2 * f) + c3.dc[8] * Math.cos(f) + c3.dc[9] * Math.sin(2 * D + m3 - f) * E + c3.dc[10] * Math.sin(m_ + 3 * f) + c3.dc[11] * Math.sin(D + f) + c3.dc[12] * Math.sin(m_ - 2 * f) + c3.dc[13] * Math.sin(2 * D - m3 - f) * E + c3.dc[14] * Math.sin(2 * D - m_ - f) + c3.dc[15] * Math.cos(m_ + f) + c3.dc[16] * Math.cos(m_ + 2 * f) + c3.dc[17] * Math.cos(2 * m_ + f) + c3.dc[18] * Math.cos(m_ - 3 * f) + c3.dc[19] * Math.cos(2 * m_ - f) + c3.dc[20] * Math.cos(m_ - 2 * f) + c3.dc[21] * Math.sin(2 * m_) + c3.dc[22] * Math.sin(3 * m_ + f) + c3.dc[23] * Math.cos(2 * D + m3 - f) * E + c3.dc[24] * Math.cos(m_ - f) + c3.dc[25] * Math.cos(3 * f) + c3.dc[26] * Math.sin(2 * D + f) + c3.dc[27] * Math.cos(m_ + 3 * f) + c3.dc[28] * Math.cos(D + f) + c3.dc[29] * Math.sin(2 * m_ - f) + c3.dc[30] * Math.cos(3 * m_ + f) + c3.dc[31] * Math.cos(2 * (D + m_) + f) + c3.dc[32] * Math.sin(2 * (D - m_) - f) + c3.dc[33] * Math.cos(2 * m_) + c3.dc[34] * Math.cos(m_) + c3.dc[35] * Math.sin(2 * f) + c3.dc[36] * Math.sin(m_ + f);
  return { jde, dec: c3.s * δ };
}
var nc2 = {
  D: 152.2029 * p,
  m: 14.8591 * p,
  m_: 4.6881 * p,
  f: 325.8867 * p,
  JDE: 24515625897e-4,
  s: 1,
  tc: [
    0.8975,
    -0.4726,
    -0.103,
    -0.0976,
    -0.0462,
    -0.0461,
    -0.0438,
    0.0162,
    -0.0157,
    0.0145,
    0.0136,
    -95e-4,
    -91e-4,
    -89e-4,
    75e-4,
    -68e-4,
    61e-4,
    -47e-4,
    -43e-4,
    -4e-3,
    -37e-4,
    31e-4,
    3e-3,
    -29e-4,
    -29e-4,
    -27e-4,
    24e-4,
    -21e-4,
    19e-4,
    18e-4,
    18e-4,
    17e-4,
    17e-4,
    -14e-4,
    13e-4,
    13e-4,
    12e-4,
    11e-4,
    -11e-4,
    1e-3,
    1e-3,
    -9e-4,
    7e-4,
    -7e-4
  ],
  dc: [
    5.1093 * p,
    0.2658 * p,
    0.1448 * p,
    -0.0322 * p,
    0.0133 * p,
    0.0125 * p,
    -0.0124 * p,
    -0.0101 * p,
    97e-4 * p,
    -87e-4 * p,
    74e-4 * p,
    67e-4 * p,
    63e-4 * p,
    6e-3 * p,
    -57e-4 * p,
    -56e-4 * p,
    52e-4 * p,
    41e-4 * p,
    -4e-3 * p,
    38e-4 * p,
    -34e-4 * p,
    -29e-4 * p,
    29e-4 * p,
    -28e-4 * p,
    -28e-4 * p,
    -23e-4 * p,
    -21e-4 * p,
    19e-4 * p,
    18e-4 * p,
    17e-4 * p,
    15e-4 * p,
    14e-4 * p,
    -12e-4 * p,
    -12e-4 * p,
    -1e-3 * p,
    -1e-3 * p,
    6e-4 * p
  ]
};
var sc = {
  D: 345.6676 * p,
  m: 1.3951 * p,
  m_: 186.21 * p,
  f: 145.1633 * p,
  JDE: 24515489289e-4,
  s: -1,
  tc: [
    -0.8975,
    -0.4726,
    -0.103,
    -0.0976,
    0.0541,
    0.0516,
    -0.0438,
    0.0112,
    0.0157,
    23e-4,
    -0.0136,
    0.011,
    91e-4,
    89e-4,
    75e-4,
    -3e-3,
    -61e-4,
    -47e-4,
    -43e-4,
    4e-3,
    -37e-4,
    -31e-4,
    3e-3,
    29e-4,
    -29e-4,
    -27e-4,
    24e-4,
    -21e-4,
    -19e-4,
    -6e-4,
    -18e-4,
    -17e-4,
    17e-4,
    14e-4,
    -13e-4,
    -13e-4,
    12e-4,
    11e-4,
    11e-4,
    1e-3,
    1e-3,
    -9e-4,
    -7e-4,
    -7e-4
  ],
  dc: [
    -5.1093 * p,
    0.2658 * p,
    -0.1448 * p,
    0.0322 * p,
    0.0133 * p,
    0.0125 * p,
    -15e-4 * p,
    0.0101 * p,
    -97e-4 * p,
    87e-4 * p,
    74e-4 * p,
    67e-4 * p,
    -63e-4 * p,
    -6e-3 * p,
    57e-4 * p,
    -56e-4 * p,
    -52e-4 * p,
    -41e-4 * p,
    -4e-3 * p,
    -38e-4 * p,
    34e-4 * p,
    -29e-4 * p,
    29e-4 * p,
    28e-4 * p,
    -28e-4 * p,
    23e-4 * p,
    21e-4 * p,
    19e-4 * p,
    18e-4 * p,
    -17e-4 * p,
    15e-4 * p,
    14e-4 * p,
    12e-4 * p,
    -12e-4 * p,
    1e-3 * p,
    -1e-3 * p,
    37e-4 * p
  ]
};
var moonmaxdec_default = {
  north,
  south
};

// node_modules/astronomia/src/moonnode.js
function ascending(year) {
  return node4(year, 0);
}
function descending(year) {
  return node4(year, 0.5);
}
function node4(y, h) {
  let k3 = (y - 2000.05) * 13.4223;
  k3 = Math.floor(k3 - h + 0.5) + h;
  const p2 = Math.PI / 180;
  const ck4 = 1 / 1342.23;
  const T = k3 * ck4;
  const D = base_default.horner(
    T,
    183.638 * p2,
    331.73735682 * p2 / ck4,
    14852e-7 * p2,
    209e-8 * p2,
    -1e-8 * p2
  );
  const M = base_default.horner(
    T,
    17.4006 * p2,
    26.8203725 * p2 / ck4,
    1186e-7 * p2,
    6e-8 * p2
  );
  const m_ = base_default.horner(
    T,
    38.3776 * p2,
    355.52747313 * p2 / ck4,
    0.0123499 * p2,
    14627e-9 * p2,
    -69e-9 * p2
  );
  const Ω = base_default.horner(
    T,
    123.9767 * p2,
    -1.44098956 * p2 / ck4,
    20608e-7 * p2,
    214e-8 * p2,
    -16e-9 * p2
  );
  const V = base_default.horner(T, 299.75 * p2, 132.85 * p2, -9173e-6 * p2);
  const P = Ω + 272.75 * p2 - 2.3 * p2 * T;
  const E = base_default.horner(T, 1, -2516e-6, -74e-7);
  return base_default.horner(
    T,
    24515651619e-4,
    27.212220817 / ck4,
    2762e-7,
    21e-9,
    -88e-12
  ) + -0.4721 * Math.sin(m_) + -0.1649 * Math.sin(2 * D) + -0.0868 * Math.sin(2 * D - m_) + 84e-4 * Math.sin(2 * D + m_) + -83e-4 * Math.sin(2 * D - M) * E + -39e-4 * Math.sin(2 * D - M - m_) * E + 34e-4 * Math.sin(2 * m_) + -31e-4 * Math.sin(2 * (D - m_)) + 3e-3 * Math.sin(2 * D + M) * E + 28e-4 * Math.sin(M - m_) * E + 26e-4 * Math.sin(M) * E + 25e-4 * Math.sin(4 * D) + 24e-4 * Math.sin(D) + 22e-4 * Math.sin(M + m_) * E + 17e-4 * Math.sin(Ω) + 14e-4 * Math.sin(4 * D - m_) + 5e-4 * Math.sin(2 * D + M - m_) * E + 4e-4 * Math.sin(2 * D - M + m_) * E + -3e-4 * Math.sin(2 * (D - M)) * E + 3e-4 * Math.sin(4 * D - M) * E + 3e-4 * Math.sin(V) + 3e-4 * Math.sin(P);
}
var moonnode_default = {
  ascending,
  descending
};

// node_modules/astronomia/src/parabolic.js
var Elements5 = class {
  /**
   * @param {Number} timeP - time of perihelion, T
   * @param {Number} pDis - perihelion distance, q
   */
  constructor(timeP, pDis) {
    this.timeP = timeP;
    this.pDis = pDis;
  }
  /**
   * AnomalyDistance returns true anomaly and distance of a body in a parabolic orbit of the Sun.
   *
   * @param {Number} jde - Julian ephemeris day
   * @returns {Object} {ano, dist}
   *   {Number} ano - True anomaly ν in radians.
   *   {Number} dist - Distance r returned in AU.
   */
  anomalyDistance(jde) {
    const W = 3 * base_default.K / Math.SQRT2 * (jde - this.timeP) / this.pDis / Math.sqrt(this.pDis);
    const G = W * 0.5;
    const Y = Math.cbrt(G + Math.sqrt(G * G + 1));
    const s2 = Y - 1 / Y;
    const ν = 2 * Math.atan(s2);
    const r = this.pDis * (1 + s2 * s2);
    return {
      ano: ν,
      dist: r
    };
  }
};
var parabolic_default = {
  Elements: Elements5
};

// node_modules/astronomia/src/sidereal.js
function JDToCFrac(jd) {
  const [j0, f] = base_default.modf(jd + 0.5);
  return [base_default.J2000Century(j0 - 0.5), f];
}
var iau82 = [24110.54841, 8640184812866e-6, 0.093104, -62e-7];
function mean4(jd) {
  return base_default.pmod(_mean(jd), 86400);
}
function _mean(jd) {
  const [s2, f] = _mean0UT(jd);
  return s2 + f * 1.00273790935 * 86400;
}
function mean0UT(jd) {
  const [s2, _] = _mean0UT(jd);
  return base_default.pmod(s2, 86400);
}
function _mean0UT(jd) {
  const [cen, f] = JDToCFrac(jd);
  return [base_default.horner(cen, ...iau82), f];
}
function apparent(jd) {
  const s2 = _mean(jd);
  const n = nutation_default.nutationInRA(jd);
  const ns = n * 3600 * 180 / Math.PI / 15;
  return base_default.pmod(s2 + ns, 86400);
}
function apparent0UT(jd) {
  const [j0, f] = base_default.modf(jd + 0.5);
  const cen = (j0 - 0.5 - base_default.J2000) / 36525;
  const s2 = base_default.horner(cen, ...iau82) + f * 1.00273790935 * 86400;
  const n = nutation_default.nutationInRA(j0);
  const ns = n * 3600 * 180 / Math.PI / 15;
  return base_default.pmod(s2 + ns, 86400);
}
var sidereal_default = {
  JDToCFrac,
  iau82,
  mean: mean4,
  mean0UT,
  apparent,
  apparent0UT
};

// node_modules/astronomia/src/parallax.js
var horPar = 8.794 / 3600 * Math.PI / 180;
function horizontal(Δ) {
  return Math.asin(Math.sin(horPar) / Δ);
}
function topocentric(c3, ρsφ, ρcφ, lon, jde) {
  const [α, δ, Δ] = [c3.ra, c3.dec, c3.range];
  const π = horizontal(Δ);
  const θ0 = new sexagesimal_default.Time(sidereal_default.apparent(jde)).rad();
  const H = base_default.pmod(θ0 - lon - α, 2 * Math.PI);
  const sπ = Math.sin(π);
  const [sH, cH] = base_default.sincos(H);
  const [sδ, cδ] = base_default.sincos(δ);
  const Δα = Math.atan2(-ρcφ * sπ * sH, cδ - ρcφ * sπ * cH);
  const α_ = α + Δα;
  const δ_ = Math.atan2((sδ - ρsφ * sπ) * Math.cos(Δα), cδ - ρcφ * sπ * cH);
  return new Coord(α_, δ_);
}
function topocentric2(c3, ρsφ, ρcφ, lon, jde) {
  const [α, δ, Δ] = [c3.ra, c3.dec, c3.range];
  const π = horizontal(Δ);
  const θ0 = new sexagesimal_default.Time(sidereal_default.apparent(jde)).rad();
  const H = base_default.pmod(θ0 - lon - α, 2 * Math.PI);
  const [sH, cH] = base_default.sincos(H);
  const [sδ, cδ] = base_default.sincos(δ);
  const Δα = -π * ρcφ * sH / cδ;
  const Δδ = -π * (ρsφ * cδ - ρcφ * cH * sδ);
  return new base_default.Coord(Δα, Δδ);
}
function topocentric3(c3, ρsφ, ρcφ, lon, jde) {
  const [α, δ, Δ] = [c3.ra, c3.dec, c3.range];
  const π = horizontal(Δ);
  const θ0 = new sexagesimal_default.Time(sidereal_default.apparent(jde)).rad();
  const H = base_default.pmod(θ0 - lon - α, 2 * Math.PI);
  const sπ = Math.sin(π);
  const [sH, cH] = base_default.sincos(H);
  const [sδ, cδ] = base_default.sincos(δ);
  const A = cδ * sH;
  const B = cδ * cH - ρcφ * sπ;
  const C2 = sδ - ρsφ * sπ;
  const q = Math.sqrt(A * A + B * B + C2 * C2);
  const H_ = Math.atan2(A, B);
  const δ_ = Math.asin(C2 / q);
  return [H_, δ_];
}
function topocentricEcliptical(c3, s2, φ, h, ε, θ, π) {
  const [λ, β] = [c3.lon, c3.lat];
  const [S2, C2] = globe_default.Earth76.parallaxConstants(φ, h);
  const [sλ, cλ] = base_default.sincos(λ);
  const [sβ, cβ] = base_default.sincos(β);
  const [sε, cε] = base_default.sincos(ε);
  const [sθ, cθ] = base_default.sincos(θ);
  const sπ = Math.sin(π);
  const N = cλ * cβ - C2 * sπ * cθ;
  let λ_ = Math.atan2(sλ * cβ - sπ * (S2 * sε + C2 * cε * sθ), N);
  if (λ_ < 0) {
    λ_ += 2 * Math.PI;
  }
  const cλ_ = Math.cos(λ_);
  const β_ = Math.atan(cλ_ * (sβ - sπ * (S2 * cε - C2 * sε * sθ)) / N);
  const s_ = Math.asin(cλ_ * Math.cos(β_) * Math.sin(s2) / N);
  return [λ_, β_, s_];
}
var parallax_default = {
  horizontal,
  topocentric,
  topocentric2,
  topocentric3,
  topocentricEcliptical
};

// node_modules/astronomia/src/parallactic.js
function parallacticAngle(φ, δ, H) {
  const [sδ, cδ] = base_default.sincos(δ);
  const [sH, cH] = base_default.sincos(H);
  return Math.atan2(sH, Math.tan(φ) * cδ - sδ * cH);
}
function parallacticAngleOnHorizon(φ, δ) {
  return Math.acos(Math.sin(φ) / Math.cos(δ));
}
function eclipticAtHorizon(ε, φ, θ) {
  const [sε, cε] = base_default.sincos(ε);
  const [sφ, cφ] = base_default.sincos(φ);
  const [sθ, cθ] = base_default.sincos(θ);
  let λ = Math.atan2(-cθ, sε * (sφ / cφ) + cε * sθ);
  if (λ < 0) {
    λ += Math.PI;
  }
  return [λ, λ + Math.PI, Math.acos(cε * sφ - sε * cφ * sθ)];
}
function eclipticAtEquator(λ, ε) {
  return Math.atan(-Math.cos(λ) * Math.tan(ε));
}
function diurnalPathAtHorizon(δ, φ) {
  const tφ = Math.tan(φ);
  const b = Math.tan(δ) * tφ;
  const c3 = Math.sqrt(1 - b * b);
  return Math.atan(c3 * Math.cos(δ) / tφ);
}
var parallactic_default = {
  parallacticAngle,
  parallacticAngleOnHorizon,
  eclipticAtHorizon,
  eclipticAtEquator,
  diurnalPathAtHorizon
};

// node_modules/astronomia/src/perihelion.js
var planetsEnum = {
  mercury: 0,
  venus: 1,
  earth: 2,
  mars: 3,
  jupiter: 4,
  saturn: 5,
  uranus: 6,
  neptune: 7,
  embary: 8
};
var mercury3 = planetsEnum.mercury;
var venus3 = planetsEnum.venus;
var earth2 = planetsEnum.earth;
var mars3 = planetsEnum.mars;
var jupiter3 = planetsEnum.jupiter;
var saturn3 = planetsEnum.saturn;
var uranus3 = planetsEnum.uranus;
var neptune3 = planetsEnum.neptune;
var embary = planetsEnum.embary;
function perihelion2(p2, year) {
  return ap(p2, year, false, pf);
}
function aphelion(p2, year) {
  return ap(p2, year, true, af);
}
var pf = function(x) {
  return Math.floor(x + 0.5);
};
var af = function(x) {
  return Math.floor(x) + 0.5;
};
var ap = function(p2, y, a, f) {
  let i = p2;
  if (i === embary) {
    i = earth2;
  }
  const k3 = f(ka[i].a * (y - ka[i].b));
  let j = base_default.horner(k3, ...c2[i]);
  if (p2 === earth2) {
    let c3 = ep;
    if (a) {
      c3 = ea;
    }
    for (let i2 = 0; i2 < 5; i2++) {
      j += c3[i2] * Math.sin((ec[i2].a + ec[i2].b * k3) * Math.PI / 180);
    }
  }
  return j;
};
var ka = [
  { a: 4.15201, b: 2000.12 },
  // mercury
  { a: 1.62549, b: 2000.53 },
  // ...
  { a: 0.99997, b: 2000.01 },
  { a: 0.53166, b: 2001.78 },
  { a: 0.0843, b: 2011.2 },
  { a: 0.03393, b: 2003.52 },
  { a: 0.0119, b: 2051.1 },
  { a: 607e-5, b: 2047.5 }
  // neptune
];
var c2 = [
  [2451590257e-3, 87.96934963],
  // mercury
  [2451738233e-3, 224.7008188, -327e-10],
  // ...
  [2451547507e-3, 365.2596358, 156e-10],
  [2452195026e-3, 686.9957857, -1187e-10],
  [2455636936e-3, 4332.897065, 1367e-7],
  [245283012e-2, 10764.21676, 827e-6],
  [24702135e-1, 30694.8767, -541e-5],
  [24688951e-1, 60190.33, 0.03429]
  // neptune
];
var ec = [
  { a: 328.41, b: 132.788585 },
  { a: 316.13, b: 584.903153 },
  { a: 346.2, b: 450.380738 },
  { a: 136.95, b: 659.306737 },
  { a: 249.52, b: 329.653368 }
];
var ep = [1.278, -0.055, -0.091, -0.056, -0.045];
var ea = [-1.352, 0.061, 0.062, 0.029, 0.031];
function perihelion22(planet, year, precision, cb) {
  return ap2(planetsEnum[planet.name], year, precision, planet, false, pf, cb);
}
function aphelion2(planet, year, precision, cb) {
  return ap2(planetsEnum[planet.name], year, precision, planet, true, af, cb);
}
if (typeof setImmediate !== "function") {
  const setImmediate2 = setTimeout;
}
var ap2 = function(p2, y, d3, v, a, f, cb) {
  const j1 = ap(p2, y, a, f);
  if (p2 !== neptune3) {
    return ap2a(j1, d3, a, v, cb);
  }
  if (cb) {
    ap2a(j1 - 5e3, d3, a, v, ([j0, r0]) => {
      ap2a(j1 + 5e3, d3, a, v, ([j2, r2]) => {
        if (r0 > r2 === a) {
          cb([j0, r0]);
          return;
        }
        cb([j2, r2]);
      });
    });
  } else {
    const [j0, r0] = ap2a(j1 - 5e3, d3, a, v);
    const [j2, r2] = ap2a(j1 + 5e3, d3, a, v);
    if (r0 > r2 === a) {
      return [j0, r0];
    }
    return [j2, r2];
  }
};
var ap2a = function(j1, d3, a, v, cb) {
  let j0 = j1 - d3;
  let j2 = j1 + d3;
  const rr = new Array(3);
  rr[1] = v.position2000(j1).range;
  rr[0] = v.position2000(j0).range;
  rr[2] = v.position2000(j2).range;
  function end() {
    const l = new interpolation_default.Len3(j0, j2, rr);
    const [jde, r] = l.extremum();
    return [jde, r];
  }
  function run() {
    if (a) {
      if (rr[1] > rr[0] && rr[1] > rr[2]) {
        cb && cb(end());
        return true;
      }
    } else {
      if (rr[1] < rr[0] && rr[1] < rr[2]) {
        cb && cb(end());
        return true;
      }
    }
    if (rr[0] < rr[2] === a) {
      j0 = j1;
      j1 = j2;
      j2 += d3;
      rr[0] = rr[1];
      rr[1] = rr[2];
      rr[2] = v.position2000(j2).range;
    } else {
      j2 = j1;
      j1 = j0;
      j0 -= d3;
      rr[2] = rr[1];
      rr[1] = rr[0];
      rr[0] = v.position2000(j0).range;
    }
    if (cb) {
      setImmediate(run, 0);
    }
  }
  if (cb) {
    run();
  } else {
    for (; ; ) {
      if (run()) {
        return end();
      }
    }
  }
};
var perihelion_default = {
  mercury: mercury3,
  venus: venus3,
  earth: earth2,
  mars: mars3,
  jupiter: jupiter3,
  saturn: saturn3,
  uranus: uranus3,
  neptune: neptune3,
  embary,
  perihelion: perihelion2,
  aphelion,
  perihelion2: perihelion22,
  aphelion2
};

// node_modules/astronomia/src/planetary.js
function mean5(y, a) {
  const k3 = Math.floor((365.2425 * y + 1721060 - a.A) / a.B + 0.5);
  const J2 = a.A + k3 * a.B;
  const M = base_default.pmod(a.M0 + k3 * a.M1, 360) * Math.PI / 180;
  const T = base_default.J2000Century(J2);
  return [J2, M, T];
}
function sum3(T, M, c3) {
  let j = base_default.horner(T, c3[0]);
  let mm = 0;
  for (let i = 1; i < c3.length; i++) {
    mm += M;
    const [smm, cmm] = base_default.sincos(mm);
    j += smm * base_default.horner(T, c3[i]);
    i++;
    j += cmm * base_default.horner(T, c3[i]);
  }
  return j;
}
function ms(y, a, c3) {
  const [J2, M, T] = mean5(y, a);
  return J2 + sum3(T, M, c3);
}
function mercuryInfConj(y) {
  return ms(y, micA, micB);
}
function mercurySupConj(y) {
  return ms(y, mscA, mscB);
}
function venusInfConj(y) {
  return ms(y, vicA, vicB);
}
function marsOpp(y) {
  return ms(y, moA, moB);
}
function sumA(T, M, c3, aa) {
  let i = c3.length - 2 * aa.length;
  let j = sum3(T, M, c3.slice(0, i));
  for (let k3 = 0; k3 < aa.length; k3++) {
    const [saa2, caa] = base_default.sincos((aa[k3].c + aa[k3].f * T) * Math.PI / 180);
    j += saa2 * base_default.horner(T, c3[i]);
    i++;
    j += caa * base_default.horner(T, c3[i]);
    i++;
  }
  return j;
}
function msa(y, a, c3, aa) {
  const [J2, M, T] = mean5(y, a);
  return J2 + sumA(T, M, c3, aa);
}
function jupiterOpp(y) {
  return msa(y, joA, joB, jaa);
}
function saturnOpp(y) {
  return msa(y, soA, soB, saa);
}
function saturnConj(y) {
  return msa(y, scA, scB, saa);
}
function uranusOpp(y) {
  return msa(y, uoA, uoB, uaa);
}
function neptuneOpp(y) {
  return msa(y, noA, noB, naa);
}
function el2(y, a, t, e2) {
  const [J2, M, T] = mean5(y, micA);
  return [J2 + sum3(T, M, t), sum3(T, M, e2) * Math.PI / 180];
}
function mercuryEastElongation(y) {
  return el2(y, micA, met, mee);
}
function mercuryWestElongation(y) {
  return el2(y, micA, mwt, mwe);
}
function marsStation2(y) {
  const [J2, M, T] = mean5(y, moA);
  return J2 + sum3(T, M, ms2);
}
function Ca(A, B, M0, M1) {
  this.A = A;
  this.B = B;
  this.M0 = M0;
  this.M1 = M1;
}
var micA = new Ca(2451612023e-3, 115.8774771, 63.5867, 114.2088742);
var mscA = new Ca(2451554084e-3, 115.8774771, 6.4822, 114.2088742);
var vicA = new Ca(2451996706e-3, 583.921361, 82.7311, 215.513058);
var moA = new Ca(2452097382e-3, 779.936104, 181.9573, 48.705244);
var joA = new Ca(2451870628e-3, 398.884046, 318.4681, 33.140229);
var soA = new Ca(245187017e-2, 378.091904, 318.0172, 12.647487);
var scA = new Ca(2451681124e-3, 378.091904, 131.6934, 12.647487);
var uoA = new Ca(2451764317e-3, 369.656035, 213.6884, 4.333093);
var noA = new Ca(2451753122e-3, 367.486703, 202.6544, 2.194998);
function Caa(c3, f) {
  this.c = c3;
  this.f = f;
}
var jaa = [
  new Caa(82.74, 40.76)
];
var saa = [
  new Caa(82.74, 40.76),
  new Caa(29.86, 1181.36),
  new Caa(14.13, 590.68),
  new Caa(220.02, 1262.87)
];
var uaa = [
  new Caa(207.83, 8.51),
  new Caa(108.84, 419.96)
];
var naa = [
  new Caa(207.83, 8.51),
  new Caa(276.74, 209.98)
];
var micB = [
  [0.0545, 2e-4],
  [-6.2008, 74e-4, 3e-5],
  [-3.275, -0.0197, 1e-5],
  [0.4737, -52e-4, -1e-5],
  [0.8111, 33e-4, -2e-5],
  [37e-4, 18e-4],
  [-0.1768, 0, 1e-5],
  [-0.0211, -4e-4],
  [0.0326, -3e-4],
  [83e-4, 1e-4],
  [-4e-3, 1e-4]
];
var mscB = [
  [-0.0548, -2e-4],
  [7.3894, -0.01, -3e-5],
  [3.22, 0.0197, -1e-5],
  [0.8383, -64e-4, -1e-5],
  [0.9666, 39e-4, -3e-5],
  [0.077, -26e-4],
  [0.2758, 2e-4, -2e-5],
  [-0.0128, -8e-4],
  [0.0734, -4e-4, -1e-5],
  [-0.0122, -2e-4],
  [0.0173, -2e-4]
];
var vicB = [
  [-96e-4, 2e-4, -1e-5],
  [2.0009, -33e-4, -1e-5],
  [0.598, -0.0104, 1e-5],
  [0.0967, -18e-4, -3e-5],
  [0.0913, 9e-4, -2e-5],
  [46e-4, -2e-4],
  [79e-4, 1e-4]
];
var moB = [
  [-0.3088, 0, 2e-5],
  [-17.6965, 0.0363, 5e-5],
  [18.3131, 0.0467, -6e-5],
  [-0.2162, -0.0198, -1e-5],
  [-4.5028, -19e-4, 7e-5],
  [0.8987, 58e-4, -2e-5],
  [0.7666, -5e-3, -3e-5],
  [-0.3636, -1e-4, 2e-5],
  [0.0402, 32e-4],
  [0.0737, -8e-4],
  [-0.098, -11e-4]
];
var joB = [
  [-0.1029, 0, -9e-5],
  [-1.9658, -56e-4, 7e-5],
  [6.1537, 0.021, -6e-5],
  [-0.2081, -13e-4],
  [-0.1116, -1e-3],
  [74e-4, 1e-4],
  [-97e-4, -1e-4],
  [0, 0.0144, -8e-5],
  [0.3642, -19e-4, -29e-5]
];
var soB = [
  [-0.0209, 6e-4, 23e-5],
  [4.5795, -0.0312, -17e-5],
  [1.1462, -0.0351, 11e-5],
  [0.0985, -15e-4],
  [0.0733, -31e-4, 1e-5],
  [25e-4, -1e-4],
  [5e-3, -2e-4],
  [0, -0.0337, 18e-5],
  [-0.851, 44e-4, 68e-5],
  [0, -64e-4, 4e-5],
  [0.2397, -12e-4, -8e-5],
  [0, -1e-3],
  [0.1245, 6e-4],
  [0, 24e-4, -3e-5],
  [0.0477, -5e-4, -6e-5]
];
var scB = [
  [0.0172, -6e-4, 23e-5],
  [-8.5885, 0.0411, 2e-4],
  [-1.147, 0.0352, -11e-5],
  [0.3331, -34e-4, -1e-5],
  [0.1145, -45e-4, 2e-5],
  [-0.0169, 2e-4],
  [-0.0109, 4e-4],
  [0, -0.0337, 18e-5],
  [-0.851, 44e-4, 68e-5],
  [0, -64e-4, 4e-5],
  [0.2397, -12e-4, -8e-5],
  [0, -1e-3],
  [0.1245, 6e-4],
  [0, 24e-4, -3e-5],
  [0.0477, -5e-4, -6e-5]
];
var uoB = [
  [0.0844, -6e-4],
  [-0.1048, 0.0246],
  [-5.1221, 0.0104, 3e-5],
  [-0.1428, 5e-4],
  [-0.0148, -13e-4],
  [0],
  [55e-4],
  [0],
  [0.885],
  [0],
  [0.2153]
];
var noB = [
  [-0.014, 0, 1e-5],
  [-1.3486, 1e-3, 1e-5],
  [0.8597, 37e-4],
  [-82e-4, -2e-4, 1e-5],
  [37e-4, -3e-4],
  [0],
  [-0.5964],
  [0],
  [0.0728]
];
var met = [
  [-21.6106, 2e-4],
  [-1.9803, -6e-3, 1e-5],
  [1.4151, -72e-4, -1e-5],
  [0.5528, -5e-4, -1e-5],
  [0.2905, 34e-4, 1e-5],
  [-0.1121, -1e-4, 1e-5],
  [-98e-4, -15e-4],
  [0.0192],
  [0.0111, 4e-4],
  [-61e-4],
  [-32e-4, -1e-4]
];
var mee = [
  [22.4697],
  [-4.2666, 54e-4, 2e-5],
  [-1.8537, -0.0137],
  [0.3598, 8e-4, -1e-5],
  [-0.068, 26e-4],
  [-0.0524, -3e-4],
  [52e-4, -6e-4],
  [0.0107, 1e-4],
  [-13e-4, 1e-4],
  [-21e-4],
  [3e-4]
];
var mwt = [
  [21.6249, -2e-4],
  [0.1306, 65e-4],
  [-2.7661, -11e-4, 1e-5],
  [0.2438, -24e-4, -1e-5],
  [0.5767, 23e-4],
  [0.1041],
  [-0.0184, 7e-4],
  [-51e-4, -1e-4],
  [48e-4, 1e-4],
  [26e-4],
  [37e-4]
];
var mwe = [
  [22.4143, -1e-4],
  [4.3651, -48e-4, -2e-5],
  [2.3787, 0.0121, -1e-5],
  [0.2674, 22e-4],
  [-0.3873, 8e-4, 1e-5],
  [-0.0369, -1e-4],
  [17e-4, -1e-4],
  [59e-4],
  [61e-4, 1e-4],
  [7e-4],
  [-11e-4]
];
var ms2 = [
  [36.7191, 16e-4, 3e-5],
  [-12.6163, 0.0417, -1e-5],
  [20.1218, 0.0379, -6e-5],
  [-1.636, -0.019],
  [-3.9657, 45e-4, 7e-5],
  [1.1546, 29e-4, -3e-5],
  [0.2888, -73e-4, -2e-5],
  [-0.3128, 17e-4, 2e-5],
  [0.2513, 26e-4, -2e-5],
  [-21e-4, -16e-4],
  [-0.1497, -6e-4]
];
var planetary_default = {
  mean: mean5,
  sum: sum3,
  ms,
  mercuryInfConj,
  mercurySupConj,
  venusInfConj,
  marsOpp,
  sumA,
  msa,
  jupiterOpp,
  saturnOpp,
  saturnConj,
  uranusOpp,
  neptuneOpp,
  el: el2,
  mercuryEastElongation,
  mercuryWestElongation,
  marsStation2
};

// node_modules/astronomia/src/pluto.js
function heliocentric(jde) {
  let l = 0;
  let b = 0;
  let r = 0;
  const T = base_default.J2000Century(jde);
  const J2 = 34.35 + 3034.9057 * T;
  const S2 = 50.08 + 1222.1138 * T;
  const P = 238.96 + 144.96 * T;
  for (const i in t37) {
    const t = t37[i];
    const [sα, cα] = base_default.sincos((t.i * J2 + t.j * S2 + t.k * P) * Math.PI / 180);
    l += t.lA * sα + t.lB * cα;
    b += t.bA * sα + t.bB * cα;
    r += t.rA * sα + t.rB * cα;
  }
  l = (l + 238.958116 + 144.96 * T) * Math.PI / 180;
  b = (b - 3.908239) * Math.PI / 180;
  r += 40.7241346;
  return { lon: l, lat: b, range: r };
}
function astrometric(jde, earth3) {
  const sε = base_default.SOblJ2000;
  const cε = base_default.COblJ2000;
  const f = function(jde2) {
    const { lon, lat, range } = heliocentric(jde2);
    const [sl, cl2] = base_default.sincos(lon);
    const [sb, cb] = base_default.sincos(lat);
    const x = range * cl2 * cb;
    const y = range * (sl * cb * cε - sb * sε);
    const z = range * (sl * cb * sε + sb * cε);
    return { x, y, z };
  };
  const c3 = elliptic_default.astrometricJ2000(f, jde, earth3);
  return new base_default.Coord(c3.ra, c3.dec);
}
function Pt(i, j, k3, lA, lB, bA, bB, rA, rB) {
  this.i = i;
  this.j = j;
  this.k = k3;
  this.lA = lA;
  this.lB = lB;
  this.bA = bA;
  this.bB = bB;
  this.rA = rA;
  this.rB = rB;
}
var t37 = [
  new Pt(0, 0, 1, -19.799805, 19.850055, -5.452852, -14.974862, 6.6865439, 6.8951812),
  new Pt(0, 0, 2, 0.897144, -4.954829, 3.527812, 1.67279, -1.1827535, -0.0332538),
  new Pt(0, 0, 3, 0.611149, 1.211027, -1.050748, 0.327647, 0.1593179, -0.143889),
  new Pt(0, 0, 4, -0.341243, -0.189585, 0.17869, -0.292153, -18444e-7, 0.048322),
  new Pt(0, 0, 5, 0.129287, -0.034992, 0.01865, 0.10034, -65977e-7, -85431e-7),
  new Pt(0, 0, 6, -0.038164, 0.030893, -0.030697, -0.025823, 31174e-7, -6032e-7),
  new Pt(0, 1, -1, 0.020442, -9987e-6, 4878e-6, 0.011248, -5794e-7, 22161e-7),
  new Pt(0, 1, 0, -4063e-6, -5071e-6, 226e-6, -64e-6, 4601e-7, 4032e-7),
  new Pt(0, 1, 1, -6016e-6, -3336e-6, 203e-5, -836e-6, -1729e-7, 234e-7),
  new Pt(0, 1, 2, -3956e-6, 3039e-6, 69e-6, -604e-6, -415e-7, 702e-7),
  new Pt(0, 1, 3, -667e-6, 3572e-6, -247e-6, -567e-6, 239e-7, 723e-7),
  new Pt(0, 2, -2, 1276e-6, 501e-6, -57e-6, 1e-6, 67e-7, -67e-7),
  new Pt(0, 2, -1, 1152e-6, -917e-6, -122e-6, 175e-6, 1034e-7, -451e-7),
  new Pt(0, 2, 0, 63e-5, -1277e-6, -49e-6, -164e-6, -129e-7, 504e-7),
  new Pt(1, -1, 0, 2571e-6, -459e-6, -197e-6, 199e-6, 48e-6, -231e-7),
  new Pt(1, -1, 1, 899e-6, -1449e-6, -25e-6, 217e-6, 2e-7, -441e-7),
  new Pt(1, 0, -3, -1016e-6, 1043e-6, 589e-6, -248e-6, -3359e-7, 265e-7),
  new Pt(1, 0, -2, -2343e-6, -1012e-6, -269e-6, 711e-6, 7856e-7, -7832e-7),
  new Pt(1, 0, -1, 7042e-6, 788e-6, 185e-6, 193e-6, 36e-7, 45763e-7),
  new Pt(1, 0, 0, 1199e-6, -338e-6, 315e-6, 807e-6, 8663e-7, 8547e-7),
  new Pt(1, 0, 1, 418e-6, -67e-6, -13e-5, -43e-6, -809e-7, -769e-7),
  new Pt(1, 0, 2, 12e-5, -274e-6, 5e-6, 3e-6, 263e-7, -144e-7),
  new Pt(1, 0, 3, -6e-5, -159e-6, 2e-6, 17e-6, -126e-7, 32e-7),
  new Pt(1, 0, 4, -82e-6, -29e-6, 2e-6, 5e-6, -35e-7, -16e-7),
  new Pt(1, 1, -3, -36e-6, -29e-6, 2e-6, 3e-6, -19e-7, -4e-7),
  new Pt(1, 1, -2, -4e-5, 7e-6, 3e-6, 1e-6, -15e-7, 8e-7),
  new Pt(1, 1, -1, -14e-6, 22e-6, 2e-6, -1e-6, -4e-7, 12e-7),
  new Pt(1, 1, 0, 4e-6, 13e-6, 1e-6, -1e-6, 5e-7, 6e-7),
  new Pt(1, 1, 1, 5e-6, 2e-6, 0, -1e-6, 3e-7, 1e-7),
  new Pt(1, 1, 3, -1e-6, 0, 0, 0, 6e-7, -2e-7),
  new Pt(2, 0, -6, 2e-6, 0, 0, -2e-6, 2e-7, 2e-7),
  new Pt(2, 0, -5, -4e-6, 5e-6, 2e-6, 2e-6, -2e-7, -2e-7),
  new Pt(2, 0, -4, 4e-6, -7e-6, -7e-6, 0, 14e-7, 13e-7),
  new Pt(2, 0, -3, 14e-6, 24e-6, 1e-5, -8e-6, -63e-7, 13e-7),
  new Pt(2, 0, -2, -49e-6, -34e-6, -3e-6, 2e-5, 136e-7, -236e-7),
  new Pt(2, 0, -1, 163e-6, -48e-6, 6e-6, 5e-6, 273e-7, 1065e-7),
  new Pt(2, 0, 0, 9e-6, -24e-6, 14e-6, 17e-6, 251e-7, 149e-7),
  new Pt(2, 0, 1, -4e-6, 1e-6, -2e-6, 0, -25e-7, -9e-7),
  new Pt(2, 0, 2, -3e-6, 1e-6, 0, 0, 9e-7, -2e-7),
  new Pt(2, 0, 3, 1e-6, 3e-6, 0, 0, -8e-7, 7e-7),
  new Pt(3, 0, -2, -3e-6, -1e-6, 0, 1e-6, 2e-7, -1e-6),
  new Pt(3, 0, -1, 5e-6, -3e-6, 0, 0, 19e-7, 35e-7),
  new Pt(3, 0, 0, 0, 0, 1e-6, 0, 1e-6, 3e-7)
];
var pluto_default = {
  heliocentric,
  astrometric
};

// node_modules/astronomia/src/refraction.js
var { sin: sin7, tan: tan5 } = Math;
var D2R7 = Math.PI / 180;
var gt15true1 = new sexagesimal_default.Angle(false, 0, 0, 58.294).rad();
var gt15true2 = new sexagesimal_default.Angle(false, 0, 0, 0.0668).rad();
var gt15app1 = new sexagesimal_default.Angle(false, 0, 0, 58.276).rad();
var gt15app2 = new sexagesimal_default.Angle(false, 0, 0, 0.0824).rad();
function gt15True(h0) {
  const t = tan5(Math.PI / 2 - h0);
  return gt15true1 * t - gt15true2 * t * t * t;
}
function gt15Apparent(h) {
  const t = tan5(Math.PI / 2 - h);
  return gt15app1 * t - gt15app2 * t * t * t;
}
function bennett(h0) {
  const c1 = D2R7 / 60;
  const c731 = 7.31 * D2R7 * D2R7;
  const c44 = 4.4 * D2R7;
  return c1 / tan5(h0 + c731 / (h0 + c44));
}
function bennett2(h0) {
  const cMin = 60 / D2R7;
  const c06 = 0.06 / cMin;
  const c147 = 14.7 * cMin * D2R7;
  const c13 = 13 * D2R7;
  const R = bennett(h0);
  return R - c06 * sin7(c147 * R + c13);
}
function saemundsson(h) {
  const c102 = 1.02 * D2R7 / 60;
  const c103 = 10.3 * D2R7 * D2R7;
  const c511 = 5.11 * D2R7;
  return c102 / tan5(h + c103 / (h + c511));
}
var refraction_default = {
  gt15True,
  gt15Apparent,
  bennett,
  bennett2,
  saemundsson
};

// node_modules/astronomia/src/rise.js
var { acos: acos2, asin: asin4, cos: cos8, sin: sin8 } = Math;
var SECS_PER_DEGREE = 240;
var SECS_PER_DAY = 86400;
var D2R8 = Math.PI / 180;
var errorAboveHorizon = base_default.errorCode("always above horizon", -1);
var errorBelowHorizon = base_default.errorCode("always below horizon", 1);
var meanRefraction = new sexagesimal_default.Angle(false, 0, 34, 0).rad();
var stdh0 = {
  stellar: -meanRefraction,
  solar: new sexagesimal_default.Angle(true, 0, 50, 0).rad(),
  // not containing meanRefraction
  lunar: sexagesimal_default.angleFromDeg(0.7275),
  lunarMean: sexagesimal_default.angleFromDeg(0.125)
};
function refraction(h0, corr) {
  if (!corr) {
    return h0;
  } else {
    return h0 - meanRefraction - corr;
  }
}
var stdh0Stellar = (_refraction) => refraction(stdh0.stellar, _refraction);
var Stdh0Stellar = stdh0Stellar();
var stdh0Solar = (_refraction) => refraction(stdh0.solar, _refraction);
var Stdh0Solar = stdh0Solar();
var stdh0LunarMean = (_refraction) => {
  return stdh0.lunarMean - refraction(_refraction);
};
var Stdh0LunarMean = stdh0LunarMean();
var stdh0Lunar = (π, refraction2) => {
  return stdh0.lunar * π - (refraction2 || meanRefraction);
};
var Stdh0Lunar = stdh0Lunar;
function hourAngle(lat, h0, δ) {
  const cosH = (sin8(h0) - sin8(lat) * sin8(δ)) / (cos8(lat) * cos8(δ));
  if (cosH < -1) {
    throw errorAboveHorizon;
  } else if (cosH > 1) {
    throw errorBelowHorizon;
  }
  const H = acos2(cosH);
  return H;
}
function _mt(lon, α, th0) {
  const mt = (lon + α) * SECS_PER_DEGREE * 180 / Math.PI - th0;
  return mt;
}
function _th0(Th0, m3) {
  const th0 = base_default.pmod(Th0 + m3 * 360.985647 / 360, SECS_PER_DAY);
  return th0;
}
function _compatibility(rs) {
  const _rs = [rs.rise, rs.transit, rs.set];
  _rs.rise = rs.rise;
  _rs.transit = rs.transit;
  _rs.set = rs.set;
  return _rs;
}
function approxTimes(p2, h0, Th0, α, δ) {
  const H0 = hourAngle(p2.lat, h0, δ) * SECS_PER_DEGREE * 180 / Math.PI;
  const mt = _mt(p2.lon, α, Th0);
  const rs = {};
  rs.transit = base_default.pmod(mt, SECS_PER_DAY);
  rs.rise = base_default.pmod(mt - H0, SECS_PER_DAY);
  rs.set = base_default.pmod(mt + H0, SECS_PER_DAY);
  return _compatibility(rs);
}
function times(p2, ΔT, h0, Th0, α3, δ3) {
  const rs = approxTimes(p2, h0, Th0, α3[1], δ3[1]);
  const d3α = new interpolation_default.Len3(-SECS_PER_DAY, SECS_PER_DAY, α3);
  const d3δ = new interpolation_default.Len3(-SECS_PER_DAY, SECS_PER_DAY, δ3);
  const ut = rs.transit + ΔT;
  const α = d3α.interpolateX(ut);
  const th0 = _th0(Th0, rs.transit);
  const H = -1 * _mt(p2.lon, α, th0);
  rs.transit -= H;
  const [sLat, cLat] = base_default.sincos(p2.lat);
  const adjustRS = function(m3) {
    const ut2 = m3 + ΔT;
    const α2 = d3α.interpolateX(ut2);
    const δ = d3δ.interpolateX(ut2);
    const th02 = _th0(Th0, m3);
    const H2 = -1 * _mt(p2.lon, α2, th02);
    const Hrad = H2 / SECS_PER_DEGREE * D2R8;
    const h = asin4(sLat * sin8(δ) + cLat * cos8(δ) * cos8(Hrad));
    const Δm = SECS_PER_DAY * (h - h0) / (cos8(δ) * cLat * sin8(Hrad) * 2 * Math.PI);
    return m3 + Δm;
  };
  rs.rise = adjustRS(rs.rise);
  rs.set = adjustRS(rs.set);
  return _compatibility(rs);
}
var PlanetRise = class {
  /**
   * @param {number|Date} jd - Julian Day starting at midnight or Date object
   * @param {number} lat - geographic latitude of the observerin degrees
   * @param {number} lon - geographic longitude of the observer in degrees (measured positively westward)
   * @param {Planet} earth - VSOP87 Planet object for Earth
   * @param {Planet} planet - VSOP87 Planet object of observed body
   * @param {object} [opts]
   * @param {boolean} [opts.date] - return times as Date objects
   * @param {number} [opts.refraction] - use different refraction than `stdh0Stellar`
   */
  constructor(jd, lat, lon, earth3, planet, opts) {
    this.opts = opts || {};
    this.refraction = this.opts.refraction || stdh0Stellar();
    if (jd instanceof Date) {
      jd = new julian_default.Calendar().fromDate(jd).toJD();
    }
    this.jd = Math.floor(jd - 0.5) + 0.5;
    this.lat = lat * D2R8;
    this.lon = lon * D2R8;
    const cal = new julian_default.Calendar().fromJD(this.jd);
    this.jde = cal.toJDE();
    this.ΔT = deltat_default2.deltaT(cal.toYear());
    this.earth = earth3;
    this.planet = planet;
  }
  approxTimes() {
    const body = elliptic_default.position(this.planet, this.earth, this.jde);
    const Th0 = sidereal_default.apparent0UT(this.jd);
    const rs = approxTimes(
      { lat: this.lat, lon: this.lon },
      this.refraction,
      Th0,
      body.ra,
      body.dec
    );
    return this._rsToJD(rs);
  }
  times() {
    const body = [
      elliptic_default.position(this.planet, this.earth, this.jde - 1),
      elliptic_default.position(this.planet, this.earth, this.jde),
      elliptic_default.position(this.planet, this.earth, this.jde + 1)
    ];
    const Th0 = sidereal_default.apparent0UT(this.jd);
    const rs = times(
      { lat: this.lat, lon: this.lon },
      this.ΔT,
      this.refraction,
      Th0,
      this._toArr(body, "ra"),
      this._toArr(body, "dec")
    );
    return this._rsToJD(rs);
  }
  /** @private */
  _toArr(body, p2) {
    return body.map((item) => {
      return item[p2];
    });
  }
  /** @private */
  _rsToJD(rs) {
    return {
      rise: this._toJD(rs.rise),
      transit: this._toJD(rs.transit),
      set: this._toJD(rs.set)
    };
  }
  /** @private */
  _toJD(secs) {
    const jd = this.jd + secs / 86400;
    if (this.opts.date) {
      return new julian_default.Calendar().fromJD(jd).toDate();
    } else {
      return jd;
    }
  }
};
var rise_default = {
  errorAboveHorizon,
  errorBelowHorizon,
  meanRefraction,
  stdh0,
  refraction,
  stdh0Stellar,
  Stdh0Stellar,
  stdh0Solar,
  Stdh0Solar,
  stdh0LunarMean,
  Stdh0LunarMean,
  stdh0Lunar,
  Stdh0Lunar,
  hourAngle,
  approxTimes,
  times,
  PlanetRise
};

// node_modules/astronomia/src/saturnmoons.js
var mimas = 0;
var enceladus = 1;
var tethys = 2;
var dione = 3;
var rhea = 4;
var titan = 5;
var hyperion = 6;
var iapetus = 7;
function XY2(x, y) {
  this.x = x;
  this.y = y;
}
var d2 = Math.PI / 180;
function positions2(jde, earth3, saturn4) {
  const sol = solar_default.trueVSOP87(earth3, jde);
  const [s2, β, R] = [sol.lon, sol.lat, sol.range];
  const [ss, cs] = base_default.sincos(s2);
  const sβ = Math.sin(β);
  let Δ = 9;
  let x;
  let y;
  let z = 0;
  let _jde;
  const f = function() {
    const τ = base_default.lightTime(Δ);
    _jde = jde - τ;
    const { lon, lat, range } = saturn4.position(_jde);
    const fk5 = planetposition_default.toFK5(lon, lat, _jde);
    const [l, b] = [fk5.lon, fk5.lat];
    const [sl, cl2] = base_default.sincos(l);
    const [sb, cb] = base_default.sincos(b);
    x = range * cb * cl2 + R * cs;
    y = range * cb * sl + R * ss;
    z = range * sb + R * sβ;
    Δ = Math.sqrt(x * x + y * y + z * z);
  };
  f();
  f();
  let λ0 = Math.atan2(y, x);
  let β0 = Math.atan(z / Math.hypot(x, y));
  let ecl = new coord_default.Ecliptic(λ0, β0);
  ecl = precess_default.eclipticPosition(ecl, base_default.JDEToJulianYear(jde), base_default.JDEToJulianYear(base_default.B1950));
  λ0 = ecl.lon;
  β0 = ecl.lat;
  const q = new Qs(_jde);
  const s4 = [
    new R4(),
    // 0 unused
    q.mimas(),
    q.enceladus(),
    q.tethys(),
    q.dione(),
    q.rhea(),
    q.titan(),
    q.hyperion(),
    q.iapetus()
  ];
  const X = new Array(9).fill(0);
  const Y = new Array(9).fill(0);
  const Z = new Array(9).fill(0);
  for (let j = 1; j <= 8; j++) {
    const u = s4[j].λ - s4[j].Ω;
    const w = s4[j].Ω - 168.8112 * d2;
    const [su, cu] = base_default.sincos(u);
    const [sw, cw] = base_default.sincos(w);
    const [sγ, cγ] = base_default.sincos(s4[j].γ);
    const r = s4[j].r;
    X[j] = r * (cu * cw - su * cγ * sw);
    Y[j] = r * (su * cw * cγ + cu * sw);
    Z[j] = r * su * sγ;
  }
  Z[0] = 1;
  const [sλ0, cλ0] = base_default.sincos(λ0);
  const [sβ0, cβ0] = base_default.sincos(β0);
  const A = new Array(9).fill(0);
  const B = new Array(9).fill(0);
  const C2 = new Array(9).fill(0);
  for (const j in X) {
    let a = X[j];
    let b = q.c1 * Y[j] - q.s1 * Z[j];
    const c3 = q.s1 * Y[j] + q.c1 * Z[j];
    const a0 = q.c2 * a - q.s2 * b;
    b = q.s2 * a + q.c2 * b;
    a = a0;
    A[j] = a * sλ0 - b * cλ0;
    b = a * cλ0 + b * sλ0;
    B[j] = b * cβ0 + c3 * sβ0;
    C2[j] = c3 * cβ0 - b * sβ0;
  }
  const pos = new Array(9);
  const D = Math.atan2(A[0], C2[0]);
  const [sD, cD] = base_default.sincos(D);
  for (let j = 1; j <= 8; j++) {
    X[j] = A[j] * cD - C2[j] * sD;
    Y[j] = A[j] * sD + C2[j] * cD;
    Z[j] = B[j];
    const d3 = X[j] / s4[j].r;
    X[j] += Math.abs(Z[j]) / k2[j] * Math.sqrt(1 - d3 * d3);
    const W = Δ / (Δ + Z[j] / 2475);
    pos[j - 1] = new XY2(X[j] * W, Y[j] * W);
  }
  return pos;
}
var k2 = [0, 20947, 23715, 26382, 29876, 35313, 53800, 59222, 91820];
function R4(λ, r, γ, Ω) {
  this.λ = λ || 0;
  this.r = r || 0;
  this.γ = γ || 0;
  this.Ω = Ω || 0;
}
function Qs(jde) {
  this.t1 = jde - 2411093;
  this.t2 = this.t1 / 365.25;
  this.t3 = (jde - 2433282423e-3) / 365.25 + 1950;
  this.t4 = jde - 2411368;
  this.t5 = this.t4 / 365.25;
  this.t6 = jde - 2415020;
  this.t7 = this.t6 / 36525;
  this.t8 = this.t6 / 365.25;
  this.t9 = (jde - 24420005e-1) / 365.25;
  this.t10 = jde - 2409786;
  this.t11 = this.t10 / 36525;
  this.W0 = 5.095 * d2 * (this.t3 - 1866.39);
  this.W1 = 74.4 * d2 + 32.39 * d2 * this.t2;
  this.W2 = 134.3 * d2 + 92.62 * d2 * this.t2;
  this.W3 = 42 * d2 - 0.5118 * d2 * this.t5;
  this.W4 = 276.59 * d2 + 0.5118 * d2 * this.t5;
  this.W5 = 267.2635 * d2 + 1222.1136 * d2 * this.t7;
  this.W6 = 175.4762 * d2 + 1221.5515 * d2 * this.t7;
  this.W7 = 2.4891 * d2 + 2435e-6 * d2 * this.t7;
  this.W8 = 113.35 * d2 - 0.2597 * d2 * this.t7;
  this.s1 = Math.sin(28.0817 * d2);
  this.c1 = Math.cos(28.0817 * d2);
  this.s2 = Math.sin(168.8112 * d2);
  this.c2 = Math.cos(168.8112 * d2);
  this.e1 = 0.05589 - 346e-6 * this.t7;
  this.sW0 = Math.sin(this.W0);
  this.s3W0 = Math.sin(3 * this.W0);
  this.s5W0 = Math.sin(5 * this.W0);
  this.sW1 = Math.sin(this.W1);
  this.sW2 = Math.sin(this.W2);
  this.sW3 = Math.sin(this.W3);
  this.cW3 = Math.cos(this.W3);
  this.sW4 = Math.sin(this.W4);
  this.cW4 = Math.cos(this.W4);
  this.sW7 = Math.sin(this.W7);
  this.cW7 = Math.cos(this.W7);
  return this;
}
Qs.prototype.mimas = function() {
  const r = new R4();
  const L2 = 127.64 * d2 + 381.994497 * d2 * this.t1 - 43.57 * d2 * this.sW0 - 0.72 * d2 * this.s3W0 - 0.02144 * d2 * this.s5W0;
  const p2 = 106.1 * d2 + 365.549 * d2 * this.t2;
  const M = L2 - p2;
  const C2 = 2.18287 * d2 * Math.sin(M) + 0.025988 * d2 * Math.sin(2 * M) + 43e-5 * d2 * Math.sin(3 * M);
  r.λ = L2 + C2;
  r.r = 3.06879 / (1 + 0.01905 * Math.cos(M + C2));
  r.γ = 1.563 * d2;
  r.Ω = 54.5 * d2 - 365.072 * d2 * this.t2;
  return r;
};
Qs.prototype.enceladus = function() {
  const r = new R4();
  const L2 = 200.317 * d2 + 262.7319002 * d2 * this.t1 + 0.25667 * d2 * this.sW1 + 0.20883 * d2 * this.sW2;
  const p2 = 309.107 * d2 + 123.44121 * d2 * this.t2;
  const M = L2 - p2;
  const C2 = 0.55577 * d2 * Math.sin(M) + 168e-5 * d2 * Math.sin(2 * M);
  r.λ = L2 + C2;
  r.r = 3.94118 / (1 + 485e-5 * Math.cos(M + C2));
  r.γ = 0.0262 * d2;
  r.Ω = 348 * d2 - 151.95 * d2 * this.t2;
  return r;
};
Qs.prototype.tethys = function() {
  const r = new R4();
  r.λ = 285.306 * d2 + 190.69791226 * d2 * this.t1 + 2.063 * d2 * this.sW0 + 0.03409 * d2 * this.s3W0 + 1015e-6 * d2 * this.s5W0;
  r.r = 4.880998;
  r.γ = 1.0976 * d2;
  r.Ω = 111.33 * d2 - 72.2441 * d2 * this.t2;
  return r;
};
Qs.prototype.dione = function() {
  const r = new R4();
  const L2 = 254.712 * d2 + 131.53493193 * d2 * this.t1 - 0.0215 * d2 * this.sW1 - 0.01733 * d2 * this.sW2;
  const p2 = 174.8 * d2 + 30.82 * d2 * this.t2;
  const M = L2 - p2;
  const C2 = 0.24717 * d2 * Math.sin(M) + 33e-5 * d2 * Math.sin(2 * M);
  r.λ = L2 + C2;
  r.r = 6.24871 / (1 + 2157e-6 * Math.cos(M + C2));
  r.γ = 0.0139 * d2;
  r.Ω = 232 * d2 - 30.27 * d2 * this.t2;
  return r;
};
Qs.prototype.rhea = function() {
  const pʹ = 342.7 * d2 + 10.057 * d2 * this.t2;
  const [spʹ, cpʹ] = base_default.sincos(pʹ);
  const a1 = 265e-6 * spʹ + 1e-3 * this.sW4;
  const a2 = 265e-6 * cpʹ + 1e-3 * this.cW4;
  const e2 = Math.hypot(a1, a2);
  const p2 = Math.atan2(a1, a2);
  const N = 345 * d2 - 10.057 * d2 * this.t2;
  const [sN, cN] = base_default.sincos(N);
  const λʹ = 359.244 * d2 + 79.6900472 * d2 * this.t1 + 0.086754 * d2 * sN;
  const i = 28.0362 * d2 + 0.346898 * d2 * cN + 0.0193 * d2 * this.cW3;
  const Ω = 168.8034 * d2 + 0.736936 * d2 * sN + 0.041 * d2 * this.sW3;
  const a = 8.725924;
  return this.subr(λʹ, p2, e2, a, Ω, i);
};
Qs.prototype.subr = function(λʹ, p2, e2, a, Ω, i) {
  const r = new R4();
  const M = λʹ - p2;
  const e22 = e2 * e2;
  const e3 = e22 * e2;
  const e4 = e22 * e22;
  const e52 = e3 * e22;
  const C2 = (2 * e2 - 0.25 * e3 + 0.0520833333 * e52) * Math.sin(M) + (1.25 * e22 - 0.458333333 * e4) * Math.sin(2 * M) + (1.083333333 * e3 - 0.671875 * e52) * Math.sin(3 * M) + 1.072917 * e4 * Math.sin(4 * M) + 1.142708 * e52 * Math.sin(5 * M);
  r.r = a * (1 - e22) / (1 + e2 * Math.cos(M + C2));
  const g2 = Ω - 168.8112 * d2;
  const [si, ci] = base_default.sincos(i);
  const [sg, cg] = base_default.sincos(g2);
  const a1 = si * sg;
  const a2 = this.c1 * si * cg - this.s1 * ci;
  r.γ = Math.asin(Math.hypot(a1, a2));
  const u = Math.atan2(a1, a2);
  r.Ω = 168.8112 * d2 + u;
  const h = this.c1 * si - this.s1 * ci * cg;
  const ψ = Math.atan2(this.s1 * sg, h);
  r.λ = λʹ + C2 + u - g2 - ψ;
  return r;
};
Qs.prototype.titan = function() {
  const L2 = 261.1582 * d2 + 22.57697855 * d2 * this.t4 + 0.074025 * d2 * this.sW3;
  const iʹ = 27.45141 * d2 + 0.295999 * d2 * this.cW3;
  const Ωʹ = 168.66925 * d2 + 0.628808 * d2 * this.sW3;
  const [siʹ, ciʹ] = base_default.sincos(iʹ);
  const [sΩʹW8, cΩʹW8] = base_default.sincos(Ωʹ - this.W8);
  const a1 = this.sW7 * sΩʹW8;
  const a2 = this.cW7 * siʹ - this.sW7 * ciʹ * cΩʹW8;
  const g0 = 102.8623 * d2;
  const ψ = Math.atan2(a1, a2);
  const s2 = Math.hypot(a1, a2);
  let g2 = this.W4 - Ωʹ - ψ;
  let ϖ = 0;
  const [s2g0, c2g0] = base_default.sincos(2 * g0);
  const f = () => {
    ϖ = this.W4 + 0.37515 * d2 * (Math.sin(2 * g2) - s2g0);
    g2 = ϖ - Ωʹ - ψ;
  };
  f();
  f();
  f();
  const eʹ = 0.029092 + 19048e-8 * (Math.cos(2 * g2) - c2g0);
  const qq = 2 * (this.W5 - ϖ);
  const b1 = siʹ * sΩʹW8;
  const b2 = this.cW7 * siʹ * cΩʹW8 - this.sW7 * ciʹ;
  const θ = Math.atan2(b1, b2) + this.W8;
  const [sq, cq] = base_default.sincos(qq);
  const e2 = eʹ + 2778797e-9 * eʹ * cq;
  const p2 = ϖ + 0.159215 * d2 * sq;
  const u = 2 * this.W5 - 2 * θ + ψ;
  const [su, cu] = base_default.sincos(u);
  const h = 0.9375 * eʹ * eʹ * sq + 0.1875 * s2 * s2 * Math.sin(2 * (this.W5 - θ));
  const λʹ = L2 - 0.254744 * d2 * (this.e1 * Math.sin(this.W6) + 0.75 * this.e1 * this.e1 * Math.sin(2 * this.W6) + h);
  const i = iʹ + 0.031843 * d2 * s2 * cu;
  const Ω = Ωʹ + 0.031843 * d2 * s2 * su / siʹ;
  const a = 20.216193;
  return this.subr(λʹ, p2, e2, a, Ω, i);
};
Qs.prototype.hyperion = function() {
  const η = 92.39 * d2 + 0.5621071 * d2 * this.t6;
  const ζ = 148.19 * d2 - 19.18 * d2 * this.t8;
  const θ = 184.8 * d2 - 35.41 * d2 * this.t9;
  const θʹ = θ - 7.5 * d2;
  const as = 176 * d2 + 12.22 * d2 * this.t8;
  const bs = 8 * d2 + 24.44 * d2 * this.t8;
  const cs = bs + 5 * d2;
  const ϖ = 69.898 * d2 - 18.67088 * d2 * this.t8;
  const φ = 2 * (ϖ - this.W5);
  const χ = 94.9 * d2 - 2.292 * d2 * this.t8;
  const [sη, cη] = base_default.sincos(η);
  const [sζ, cζ] = base_default.sincos(ζ);
  const [s2ζ, c2ζ] = base_default.sincos(2 * ζ);
  const [s3ζ, c3ζ] = base_default.sincos(3 * ζ);
  const [sζpη, cζpη] = base_default.sincos(ζ + η);
  const [sζmη, cζmη] = base_default.sincos(ζ - η);
  const [sφ, cφ] = base_default.sincos(φ);
  const [sχ, cχ] = base_default.sincos(χ);
  const [scs, ccs] = base_default.sincos(cs);
  const a = 24.50601 - 0.08686 * cη - 166e-5 * cζpη + 175e-5 * cζmη;
  const e2 = 0.103458 - 4099e-6 * cη - 167e-6 * cζpη + 235e-6 * cζmη + 0.02303 * cζ - 212e-5 * c2ζ + 151e-6 * c3ζ + 13e-5 * cφ;
  const p2 = ϖ + 0.15648 * d2 * sχ - 0.4457 * d2 * sη - 0.2657 * d2 * sζpη - 0.3573 * d2 * sζmη - 12.872 * d2 * sζ + 1.668 * d2 * s2ζ - 0.2419 * d2 * s3ζ - 0.07 * d2 * sφ;
  const λʹ = 177.047 * d2 + 16.91993829 * d2 * this.t6 + 0.15648 * d2 * sχ + 9.142 * d2 * sη + 7e-3 * d2 * Math.sin(2 * η) - 0.014 * d2 * Math.sin(3 * η) + 0.2275 * d2 * sζpη + 0.2112 * d2 * sζmη - 0.26 * d2 * sζ - 98e-4 * d2 * s2ζ - 0.013 * d2 * Math.sin(as) + 0.017 * d2 * Math.sin(bs) - 0.0303 * d2 * sφ;
  const i = 27.3347 * d2 + 0.6434886 * d2 * cχ + 0.315 * d2 * this.cW3 + 0.018 * d2 * Math.cos(θ) - 0.018 * d2 * ccs;
  const Ω = 168.6812 * d2 + 1.40136 * d2 * cχ + 0.68599 * d2 * this.sW3 - 0.0392 * d2 * scs + 0.0366 * d2 * Math.sin(θʹ);
  return this.subr(λʹ, p2, e2, a, Ω, i);
};
Qs.prototype.iapetus = function() {
  const L2 = 261.1582 * d2 + 22.57697855 * d2 * this.t4;
  const ϖʹ = 91.796 * d2 + 0.562 * d2 * this.t7;
  const ψ = 4.367 * d2 - 0.195 * d2 * this.t7;
  const θ = 146.819 * d2 - 3.198 * d2 * this.t7;
  const φ = 60.47 * d2 + 1.521 * d2 * this.t7;
  const Φ = 205.055 * d2 - 2.091 * d2 * this.t7;
  const eʹ = 0.028298 + 1156e-6 * this.t11;
  const ϖ0 = 352.91 * d2 + 11.71 * d2 * this.t11;
  const μ = 76.3852 * d2 + 4.53795125 * d2 * this.t10;
  const iʹ = base_default.horner(this.t11, 18.4602 * d2, -0.9518 * d2, -0.072 * d2, 54e-4 * d2);
  const Ωʹ = base_default.horner(this.t11, 143.198 * d2, -3.919 * d2, 0.116 * d2, 8e-3 * d2);
  const l = μ - ϖ0;
  const g2 = ϖ0 - Ωʹ - ψ;
  const g1 = ϖ0 - Ωʹ - φ;
  const ls = this.W5 - ϖʹ;
  const gs = ϖʹ - θ;
  const lT = L2 - this.W4;
  const gT = this.W4 - Φ;
  const u1 = 2 * (l + g2 - ls - gs);
  const u2 = l + g1 - lT - gT;
  const u3 = l + 2 * (g2 - ls - gs);
  const u4 = lT + gT - g1;
  const u5 = 2 * (ls + gs);
  const [sl, cl2] = base_default.sincos(l);
  const [su1, cu1] = base_default.sincos(u1);
  const [su2, cu2] = base_default.sincos(u2);
  const [su3, cu3] = base_default.sincos(u3);
  const [su4, cu4] = base_default.sincos(u4);
  const [slu2, clu2] = base_default.sincos(l + u2);
  const [sg1gT, cg1gT] = base_default.sincos(g1 - gT);
  const [su52g, cu52g] = base_default.sincos(u5 - 2 * g2);
  const [su5ψ, cu5ψ] = base_default.sincos(u5 + ψ);
  const [su2φ, cu2φ] = base_default.sincos(u2 + φ);
  const [s5, c5] = base_default.sincos(l + g1 + lT + gT + φ);
  const a = 58.935028 + 4638e-6 * cu1 + 0.058222 * cu2;
  const e2 = eʹ - 14097e-7 * cg1gT + 3733e-7 * cu52g + 118e-6 * cu3 + 2408e-7 * cl2 + 2849e-7 * clu2 + 619e-6 * cu4;
  const w = 0.08077 * d2 * sg1gT + 0.02139 * d2 * su52g - 676e-5 * d2 * su3 + 0.0138 * d2 * sl + 0.01632 * d2 * slu2 + 0.03547 * d2 * su4;
  const p2 = ϖ0 + w / eʹ;
  const λʹ = μ - 0.04299 * d2 * su2 - 789e-5 * d2 * su1 - 0.06312 * d2 * Math.sin(ls) - 295e-5 * d2 * Math.sin(2 * ls) - 0.02231 * d2 * Math.sin(u5) + 65e-4 * d2 * su5ψ;
  const i = iʹ + 0.04204 * d2 * cu5ψ + 235e-5 * d2 * c5 + 36e-4 * d2 * cu2φ;
  const wʹ = 0.04204 * d2 * su5ψ + 235e-5 * d2 * s5 + 358e-5 * d2 * su2φ;
  const Ω = Ωʹ + wʹ / Math.sin(iʹ);
  return this.subr(λʹ, p2, e2, a, Ω, i);
};
var saturnmoons_default = {
  mimas,
  enceladus,
  tethys,
  dione,
  rhea,
  titan,
  hyperion,
  iapetus,
  positions: positions2,
  Qs
};

// node_modules/astronomia/src/saturnring.js
function ring(jde, earth3, saturn4) {
  const [f1, f2] = cl(jde, earth3, saturn4);
  const [ΔU, B] = f1();
  const [Bʹ, P, aEdge, bEdge] = f2();
  return [B, Bʹ, ΔU, P, aEdge, bEdge];
}
function ub(jde, earth3, saturn4) {
  const [f1, f2] = cl(jde, earth3, saturn4);
  return f1();
}
function cl(jde, earth3, saturn4) {
  const p2 = Math.PI / 180;
  let i, Ω;
  let l02, b0, R;
  let Δ = 9;
  let λ, β;
  let si, ci, sβ, cβ, sB;
  let sbʹ, cbʹ, slʹΩ, clʹΩ;
  const f1 = function() {
    const T = base_default.J2000Century(jde);
    i = base_default.horner(T, 28.075216 * p2, -0.012998 * p2, 4e-6 * p2);
    Ω = base_default.horner(T, 169.50847 * p2, 1.394681 * p2, 412e-6 * p2);
    const earthPos = earth3.position(jde);
    R = earthPos.range;
    const fk5 = planetposition_default.toFK5(earthPos.lon, earthPos.lat, jde);
    l02 = fk5.lon;
    b0 = fk5.lat;
    const [sl0, cl0] = base_default.sincos(l02);
    const sb0 = Math.sin(b0);
    let l = 0;
    let b = 0;
    let r = 0;
    let x = 0;
    let y = 0;
    let z = 0;
    const f = function() {
      const τ = base_default.lightTime(Δ);
      const saturnPos = saturn4.position(jde - τ);
      r = saturnPos.range;
      const fk52 = planetposition_default.toFK5(saturnPos.lon, saturnPos.lat, jde);
      l = fk52.lon;
      b = fk52.lat;
      const [sl, cl2] = base_default.sincos(l);
      const [sb, cb] = base_default.sincos(b);
      x = r * cb * cl2 - R * cl0;
      y = r * cb * sl - R * sl0;
      z = r * sb - R * sb0;
      Δ = Math.sqrt(x * x + y * y + z * z);
    };
    f();
    f();
    λ = Math.atan2(y, x);
    β = Math.atan(z / Math.hypot(x, y));
    si = Math.sin(i);
    ci = Math.cos(i);
    sβ = Math.sin(β);
    cβ = Math.cos(β);
    sB = si * cβ * Math.sin(λ - Ω) - ci * sβ;
    const B = Math.asin(sB);
    const N = 113.6655 * p2 + 0.8771 * p2 * T;
    const lʹ = l - 0.01759 * p2 / r;
    const bʹ = b - 764e-6 * p2 * Math.cos(l - N) / r;
    sbʹ = Math.sin(bʹ);
    cbʹ = Math.cos(bʹ);
    slʹΩ = Math.sin(lʹ - Ω);
    clʹΩ = Math.cos(lʹ - Ω);
    const [sλΩ, cλΩ] = base_default.sincos(λ - Ω);
    const U1 = Math.atan2(si * sbʹ + ci * cbʹ * slʹΩ, cbʹ * clʹΩ);
    const U2 = Math.atan2(si * sβ + ci * cβ * sλΩ, cβ * cλΩ);
    const ΔU = Math.abs(U1 - U2);
    return [ΔU, B];
  };
  const f2 = function() {
    const aEdge = 375.35 / 3600 * p2 / Δ;
    const bEdge = aEdge * Math.abs(sB);
    const sBʹ = si * cbʹ * slʹΩ - ci * sbʹ;
    const Bʹ = Math.asin(sBʹ);
    const [Δψ, Δε] = nutation_default.nutation(jde);
    const ε = nutation_default.meanObliquity(jde) + Δε;
    let λ0 = Ω - Math.PI / 2;
    const β0 = Math.PI / 2 - i;
    const [sl0λ, cl0λ] = base_default.sincos(l02 - λ);
    λ += 5693e-6 * p2 * cl0λ / cβ;
    β += 5693e-6 * p2 * sl0λ * sβ;
    λ0 += Δψ;
    λ += Δψ;
    let eq3 = new coord_default.Ecliptic(λ0, β0).toEquatorial(ε);
    const [α0, δ0] = [eq3.ra, eq3.dec];
    eq3 = new coord_default.Ecliptic(λ, β).toEquatorial(ε);
    const [α, δ] = [eq3.ra, eq3.dec];
    const [sδ0, cδ0] = base_default.sincos(δ0);
    const [sδ, cδ] = base_default.sincos(δ);
    const [sα0α, cα0α] = base_default.sincos(α0 - α);
    const P = Math.atan2(cδ0 * sα0α, sδ0 * cδ - cδ0 * sδ * cα0α);
    return [Bʹ, P, aEdge, bEdge];
  };
  return [f1, f2];
}
var saturnring_default = {
  ring,
  ub
};

// node_modules/astronomia/src/solardisk.js
function ephemeris(jd, earth3) {
  const θ = (jd - 2398220) * 2 * Math.PI / 25.38;
  const I = 7.25 * Math.PI / 180;
  const K2 = 73.6667 * Math.PI / 180 + 1.3958333 * Math.PI / 180 * (jd - 2396758) / base_default.JulianCentury;
  const solarPos = solar_default.trueVSOP87(earth3, jd);
  const L2 = solarPos.lon;
  const R = solarPos.range;
  const [Δψ, Δε] = nutation_default.nutation(jd);
  const ε0 = nutation_default.meanObliquity(jd);
  const ε = ε0 + Δε;
  const λ = L2 - 20.4898 / 3600 * Math.PI / 180 / R;
  const λp = λ + Δψ;
  const [sλK, cλK] = base_default.sincos(λ - K2);
  const [sI2, cI2] = base_default.sincos(I);
  const tx = -Math.cos(λp) * Math.tan(ε);
  const ty = -cλK * Math.tan(I);
  const P = Math.atan(tx) + Math.atan(ty);
  const B0 = Math.asin(sλK * sI2);
  const η = Math.atan2(-sλK * cI2, -cλK);
  const L0 = base_default.pmod(η - θ, 2 * Math.PI);
  return [P, B0, L0];
}
function cycle(c3) {
  const jde = 2398140227e-3 + 27.2752316 * c3;
  const m3 = 281.96 * Math.PI / 180 + 26.882476 * Math.PI / 180 * c3;
  const [s2m, c2m] = base_default.sincos(2 * m3);
  return jde + 0.1454 * Math.sin(m3) - 85e-4 * s2m - 0.0141 * c2m;
}
var solardisk_default = {
  ephemeris,
  cycle
};

// node_modules/astronomia/src/solstice.js
var { abs: abs2, cos: cos9, sin: sin9 } = Math;
var D2R9 = Math.PI / 180;
var mc0 = [172113929189e-5, 365242.1374, 0.06134, 111e-5, -71e-5];
var jc0 = [172123325401e-5, 365241.72562, -0.05323, 907e-5, 25e-5];
var sc0 = [172132570455e-5, 365242.49558, -0.11677, -297e-5, 74e-5];
var dc0 = [172141439987e-5, 365242.88257, -769e-5, -933e-5, -6e-5];
var mc2 = [245162380984e-5, 365242.37404, 0.05169, -411e-5, -57e-5];
var jc2 = [245171656767e-5, 365241.62603, 325e-5, 888e-5, -3e-4];
var sc2 = [245181021715e-5, 365242.01767, -0.11575, 337e-5, 78e-5];
var dc2 = [245190005952e-5, 365242.74049, -0.06223, -823e-5, 32e-5];
var terms = function() {
  const term = [
    [485, 324.96, 1934.136],
    [203, 337.23, 32964.467],
    [199, 342.08, 20.186],
    [182, 27.85, 445267.112],
    [156, 73.14, 45036.886],
    [136, 171.52, 22518.443],
    [77, 222.54, 65928.934],
    [74, 296.72, 3034.906],
    [70, 243.58, 9037.513],
    [58, 119.81, 33718.147],
    [52, 297.17, 150.678],
    [50, 21.02, 2281.226],
    [45, 247.54, 29929.562],
    [44, 325.15, 31555.956],
    [29, 60.93, 4443.417],
    [18, 155.12, 67555.328],
    [17, 288.79, 4562.452],
    [16, 198.04, 62894.029],
    [14, 199.76, 31436.921],
    [12, 95.39, 14577.848],
    [12, 287.11, 31931.756],
    [12, 320.81, 34777.259],
    [9, 227.73, 1222.114],
    [8, 15.45, 16859.074]
  ];
  return term.map((t) => {
    return {
      a: t[0],
      b: t[1],
      c: t[2]
    };
  });
}();
function march(y) {
  if (y < 1e3) {
    return eq(y, mc0);
  }
  return eq(y - 2e3, mc2);
}
function june(y) {
  if (y < 1e3) {
    return eq(y, jc0);
  }
  return eq(y - 2e3, jc2);
}
function september(y) {
  if (y < 1e3) {
    return eq(y, sc0);
  }
  return eq(y - 2e3, sc2);
}
function december(y) {
  if (y < 1e3) {
    return eq(y, dc0);
  }
  return eq(y - 2e3, dc2);
}
function eq(y, c3) {
  const J0 = base_default.horner(y * 1e-3, c3);
  const T = base_default.J2000Century(J0);
  const W = 35999.373 * D2R9 * T - 2.47 * D2R9;
  const Δλ = 1 + 0.0334 * cos9(W) + 7e-4 * cos9(2 * W);
  let S2 = 0;
  for (let i = terms.length - 1; i >= 0; i--) {
    const t = terms[i];
    S2 += t.a * cos9((t.b + t.c * T) * D2R9);
  }
  return J0 + 1e-5 * S2 / Δλ;
}
function march2(year, planet) {
  return longitude(year, planet, 0);
}
function june2(year, planet) {
  return longitude(year, planet, Math.PI / 2);
}
function september2(year, planet) {
  return longitude(year, planet, Math.PI);
}
function december2(year, planet) {
  return longitude(year, planet, Math.PI * 3 / 2);
}
function longitude(year, planet, lon) {
  let c3;
  let ct;
  if (year < 1e3) {
    ct = [mc0, jc0, sc0, dc0];
  } else {
    ct = [mc2, jc2, sc2, dc2];
    year -= 2e3;
  }
  lon = lon % (Math.PI * 2);
  if (lon < Math.PI / 2) {
    c3 = ct[0];
  } else if (lon < Math.PI) {
    c3 = ct[1];
  } else if (lon < Math.PI * 3 / 2) {
    c3 = ct[2];
  } else {
    c3 = ct[3];
  }
  return eq2(year, planet, lon, c3);
}
function eq2(year, planet, lon, c3) {
  let J0 = base_default.horner(year * 1e-3, c3);
  for (; ; ) {
    const a = solar_default.apparentVSOP87(planet, J0);
    const c4 = 58 * sin9(lon - a.lon);
    J0 += c4;
    if (abs2(c4) < 5e-6) {
      break;
    }
  }
  return J0;
}
var solstice_default = {
  march,
  june,
  september,
  december,
  march2,
  june2,
  september2,
  december2,
  longitude
};

// node_modules/astronomia/src/stellar.js
function sum4(m1, m22) {
  const x = 0.4 * (m22 - m1);
  return m22 - 2.5 * Math.log10(Math.pow(10, x) + 1);
}
function sumN(m3) {
  let s2 = 0;
  for (const mi of m3) {
    s2 += Math.pow(10, -0.4 * mi);
  }
  return -2.5 * Math.log10(s2);
}
function ratio(m1, m22) {
  const x = 0.4 * (m22 - m1);
  return Math.pow(10, x);
}
function difference(ratio2) {
  return 2.5 * Math.log10(ratio2);
}
function absoluteByParallax(m3, π) {
  return m3 + 5 + 5 * Math.log10(π);
}
function absoluteByDistance(m3, d3) {
  return m3 + 5 - 5 * Math.log10(d3);
}
var stellar_default = {
  sum: sum4,
  sumN,
  ratio,
  difference,
  absoluteByParallax,
  absoluteByDistance
};

// node_modules/astronomia/src/sundial.js
function Point(x, y) {
  this.x = x || 0;
  this.y = y || 0;
}
function Line(hour, points) {
  this.hour = hour;
  this.points = points || [];
}
var m2 = [-23.44, -20.15, -11.47, 0, 11.47, 20.15, 23.44];
function general(φ, D, a, z) {
  const [sφ, cφ] = base_default.sincos(φ);
  const tφ = sφ / cφ;
  const [sD, cD] = base_default.sincos(D);
  const [sz, cz] = base_default.sincos(z);
  const P = sφ * cz - cφ * sz * cD;
  const lines = [];
  for (let i = 0; i < 24; i++) {
    const l = new Line(i);
    const H = (i - 12) * 15 * Math.PI / 180;
    const aH = Math.abs(H);
    const [sH, cH] = base_default.sincos(H);
    for (const d3 of m2) {
      const tδ = Math.tan(d3 * Math.PI / 180);
      const H0 = Math.acos(-tφ * tδ);
      if (aH > H0) {
        continue;
      }
      const Q = sD * sz * sH + (cφ * cz + sφ * sz * cD) * cH + P * tδ;
      if (Q < 0) {
        continue;
      }
      const Nx = cD * sH - sD * (sφ * cH - cφ * tδ);
      const Ny = cz * sD * sH - (cφ * sz - sφ * cz * cD) * cH - (sφ * sz + cφ * cz * cD) * tδ;
      l.points.push(new Point(a * Nx / Q, a * Ny / Q));
    }
    if (l.points.length > 0) {
      lines.push(l);
    }
  }
  const center = new Point();
  center.x = a / P * cφ * sD;
  center.y = -a / P * (sφ * sz + cφ * cz * cD);
  const aP = Math.abs(P);
  const u = a / aP;
  const ψ = Math.asin(aP);
  return {
    lines,
    center,
    length: u,
    angle: ψ
  };
}
function equatorial(φ, a) {
  const tφ = Math.tan(φ);
  const n = [];
  const s2 = [];
  for (let i = 0; i < 24; i++) {
    const nl = new Line(i);
    const sl = new Line(i);
    const H = (i - 12) * 15 * Math.PI / 180;
    const aH = Math.abs(H);
    const [sH, cH] = base_default.sincos(H);
    for (const d3 of m2) {
      const tδ = Math.tan(d3 * Math.PI / 180);
      const H0 = Math.acos(-tφ * tδ);
      if (aH > H0) {
        continue;
      }
      const x = -a * sH / tδ;
      const yy = a * cH / tδ;
      if (tδ < 0) {
        sl.points.push(new Point(x, yy));
      } else {
        nl.points.push(new Point(x, -yy));
      }
    }
    if (nl.points.length > 0) {
      n.push(nl);
    }
    if (sl.points.length > 0) {
      s2.push(sl);
    }
  }
  return {
    north: n,
    south: s2
  };
}
function horizontal2(φ, a) {
  const [sφ, cφ] = base_default.sincos(φ);
  const tφ = sφ / cφ;
  const lines = [];
  for (let i = 0; i < 24; i++) {
    const l = new Line(i);
    const H = (i - 12) * 15 * Math.PI / 180;
    const aH = Math.abs(H);
    const [sH, cH] = base_default.sincos(H);
    for (const d3 of m2) {
      const tδ = Math.tan(d3 * Math.PI / 180);
      const H0 = Math.acos(-tφ * tδ);
      if (aH > H0) {
        continue;
      }
      const Q = cφ * cH + sφ * tδ;
      const x = a * sH / Q;
      const y = a * (sφ * cH - cφ * tδ) / Q;
      l.points.push(new Point(x, y));
    }
    if (l.points.length > 0) {
      lines.push(l);
    }
  }
  const center = new Point(0, -a / tφ);
  const u = a / Math.abs(sφ);
  return {
    lines,
    center,
    length: u
  };
}
function vertical(φ, D, a) {
  const [sφ, cφ] = base_default.sincos(φ);
  const tφ = sφ / cφ;
  const [sD, cD] = base_default.sincos(D);
  const lines = [];
  for (let i = 0; i < 24; i++) {
    const l = new Line(i);
    const H = (i - 12) * 15 * Math.PI / 180;
    const aH = Math.abs(H);
    const [sH, cH] = base_default.sincos(H);
    for (const d3 of m2) {
      const tδ = Math.tan(d3 * Math.PI / 180);
      const H0 = Math.acos(-tφ * tδ);
      if (aH > H0) {
        continue;
      }
      const Q = sD * sH + sφ * cD * cH - cφ * cD * tδ;
      if (Q < 0) {
        continue;
      }
      const x = a * (cD * sH - sφ * sD * cH + cφ * sD * tδ) / Q;
      const y = -a * (cφ * cH + sφ * tδ) / Q;
      l.points.push(new Point(x, y));
    }
    if (l.points.length > 0) {
      lines.push(l);
    }
  }
  const center = new Point();
  center.x = -a * sD / cD;
  center.y = a * tφ / cD;
  const u = a / Math.abs(cφ * cD);
  return {
    lines,
    center,
    length: u
  };
}
var sundial_default = {
  general,
  equatorial,
  horizontal: horizontal2,
  vertical
};

// node_modules/astronomia/src/sunrise.js
var stdh02 = {
  sunrise: new sexagesimal_default.Angle(true, 0, 50, 0).rad(),
  sunriseEnd: new sexagesimal_default.Angle(true, 0, 18, 0).rad(),
  twilight: new sexagesimal_default.Angle(true, 6, 0, 0).rad(),
  nauticalTwilight: new sexagesimal_default.Angle(true, 12, 0, 0).rad(),
  night: new sexagesimal_default.Angle(true, 18, 0, 0).rad(),
  goldenHour: new sexagesimal_default.Angle(false, 6, 0, 0).rad()
};
var stdh0Sunrise = (refraction2) => rise_default.refraction(stdh02.sunrise, refraction2);
var stdh0SunriseEnd = (refraction2) => rise_default.refraction(stdh02.sunriseEnd, refraction2);
var stdh0Twilight = (refraction2) => rise_default.refraction(stdh02.twilight, refraction2);
var stdh0NauticalTwilight = (refraction2) => rise_default.refraction(stdh02.nauticalTwilight, refraction2);
var stdh0Night = (refraction2) => rise_default.refraction(stdh02.night, refraction2);
var stdh0GoldenHour = (refraction2) => rise_default.refraction(stdh02.goldenHour, refraction2);
var Sunrise = class {
  /**
   * Computes time of sunrise, sunset for a given day `date` of an observer on earth given by latitude and longitude.
   * Methods may return `undefined` instead of `julian.Calendar` for latitudes very near the poles.
   * @param {julian.Calendar} date - calendar date
   * @param {number} lat - latitude of observer in the range of (-89.6, 89.6)
   * @param {number} lon - longitude of observer (measured positively westwards, New York = 40.7° lat, 74° lon)
   * @param {number} [refraction] - optional refraction
   */
  constructor(date, lat, lon, refraction2) {
    this.date = date;
    this.jde = date.midnight().toJDE();
    this.lat = sexagesimal_default.angleFromDeg(lat);
    this.lon = sexagesimal_default.angleFromDeg(lon);
    this.refraction = refraction2;
  }
  _calcNoon(jde) {
    const etime = sexagesimal_default.secFromHourAngle(eqtime_default.eSmart(jde));
    const delta = sexagesimal_default.secFromHourAngle(this.lon);
    const time2 = 43200 + delta - etime;
    return base_default.pmod(time2 / 86400, 86400);
  }
  _calcRiseOrSet(jde, h0, isSet) {
    const etime = sexagesimal_default.secFromHourAngle(eqtime_default.eSmart(jde));
    const solarDec = solar_default.apparentEquatorial(jde).dec;
    let ha = rise_default.hourAngle(this.lat, h0, solarDec);
    if (isSet) ha = -ha;
    const delta = sexagesimal_default.secFromHourAngle(ha - this.lon);
    const time2 = 43200 - delta - etime;
    return time2 / 86400;
  }
  _calcPolarDayNight(h0, isSet, step) {
    let jde = this.jde;
    let t;
    let failCnt = 0;
    while (failCnt < 190) {
      jde += step;
      try {
        t = this._calcRiseOrSet(jde, h0, isSet);
        t = this._calcRiseOrSet(jde + t, h0, isSet);
        break;
      } catch (e2) {
        t = void 0;
        failCnt++;
      }
    }
    if (t === void 0) {
      return;
    }
    return new julian_default.Calendar().fromJDE(jde + t);
  }
  _calc(h0, isSet) {
    let t;
    const jde = this.jde;
    try {
      t = this._calcRiseOrSet(jde, h0, isSet);
      t = this._calcRiseOrSet(jde + t, h0, isSet);
      return new julian_default.Calendar().fromJDE(jde + t);
    } catch (e2) {
      let step = isSet ? -1 : 1;
      const doy = this.date.dayOfYear();
      if (
        // overlap with march, september equinoxes
        this.lat > 0 && (doy > 76 && doy < 267) || // northern hemisphere
        this.lat < 0 && (doy < 83 || doy > 262)
      ) {
        step = -step;
      }
      return this._calcPolarDayNight(h0, isSet, step);
    }
  }
  /**
   * time of solar transit
   * @return {julian.Calendar} time of noon
   */
  noon() {
    const jde = this.jde;
    let t = this._calcNoon(jde + this.lon / (2 * Math.PI));
    t = this._calcNoon(jde + t);
    return new julian_default.Calendar().fromJDE(jde + t);
  }
  /**
   * Solar limb appears over the easter horizon in the morning
   * @return {julian.Calendar} time of sunrise
   */
  rise() {
    return this._calc(stdh0Sunrise(this.refraction), false);
  }
  /**
   * @return {julian.Calendar} time of sunset
   * Solar limb disappears on the western horizon in the evening
   */
  set() {
    return this._calc(stdh0Sunrise(this.refraction), true);
  }
  /**
   * Solar limb is fully visible at the easter horizon
   * @return {julian.Calendar} time of sunrise end
   */
  riseEnd() {
    return this._calc(stdh0SunriseEnd(this.refraction), false);
  }
  /**
   * Solar limb starts disappearing on the western horizon in the evening
   * @return {julian.Calendar} time of sunset start
   */
  setStart() {
    return this._calc(stdh0SunriseEnd(this.refraction), true);
  }
  /**
   * Dawn, there is still enough light for objects to be distinguishable,
   * @return {julian.Calendar} time of dawn
   */
  dawn() {
    return this._calc(stdh0Twilight(this.refraction), false);
  }
  /**
   * Dusk, there is still enough light for objects to be distinguishable
   * Bright stars and planets are visible by naked eye
   * @return {julian.Calendar} time of dusk
   */
  dusk() {
    return this._calc(stdh0Twilight(this.refraction), true);
  }
  /**
   * nautical dawn - Horizon gets visible by naked eye
   * @return {julian.Calendar} time of nautical dawn
   */
  nauticalDawn() {
    return this._calc(stdh0NauticalTwilight(this.refraction), false);
  }
  /**
   * nautical dusk - Horizon is no longer visible by naked eye
   * @return {julian.Calendar} time of nautical dusk
   */
  nauticalDusk() {
    return this._calc(stdh0NauticalTwilight(this.refraction), true);
  }
  /**
   * night starts - No sunlight illumination of the sky, such no intereferance
   * with astronomical observations.
   * @return {julian.Calendar} time of start of night
   */
  nightStart() {
    return this._calc(stdh0Night(this.refraction), true);
  }
  /**
   * night end - Sunlight starts illumination of the sky and interferes
   * with astronomical observations.
   * @return {julian.Calendar} time of end of night
   */
  nightEnd() {
    return this._calc(stdh0Night(this.refraction), false);
  }
  /**
   * Start of "golden hour" before sunset
   * @return {julian.Calendar} time of start of golden hour
   */
  goldenHourStart() {
    return this._calc(stdh0GoldenHour(this.refraction), true);
  }
  /**
   * End of "golden hour" after sunrise
   * @return {julian.Calendar} time of end of golden hour
   */
  goldenHourEnd() {
    return this._calc(stdh0GoldenHour(this.refraction), false);
  }
};
var sunrise_default = {
  Sunrise
};
export {
  angle_default as angle,
  apparent_default as apparent,
  apsis_default as apsis,
  base_default as base,
  binary_default as binary,
  circle_default as circle,
  conjunction_default as conjunction,
  coord_default as coord,
  deltat_default2 as deltat,
  eclipse_default as eclipse,
  elementequinox_default as elementequinox,
  elliptic_default as elliptic,
  elp_default as elp,
  eqtime_default as eqtime,
  fit_default as fit,
  globe_default as globe,
  illum_default as illum,
  interpolation_default as interpolation,
  iterate_default as iterate,
  jm_default as jm,
  julian_default as julian,
  jupiter_default as jupiter,
  jupitermoons_default as jupitermoons,
  kepler_default as kepler,
  line_default as line,
  mars_default as mars,
  moon_default as moon,
  moonillum_default as moonillum,
  moonmaxdec_default as moonmaxdec,
  moonnode_default as moonnode,
  moonphase_default as moonphase,
  moonposition_default as moonposition,
  nearparabolic_default as nearparabolic,
  node_default as node,
  nutation_default as nutation,
  parabolic_default as parabolic,
  parallactic_default as parallactic,
  parallax_default as parallax,
  perihelion_default as perihelion,
  planetary_default as planetary,
  planetelements_default as planetelements,
  planetposition_default as planetposition,
  pluto_default as pluto,
  precess_default as precess,
  refraction_default as refraction,
  rise_default as rise,
  saturnmoons_default as saturnmoons,
  saturnring_default as saturnring,
  sexagesimal_default as sexagesimal,
  sidereal_default as sidereal,
  solar_default as solar,
  solardisk_default as solardisk,
  solarxyz_default as solarxyz,
  solstice_default as solstice,
  stellar_default as stellar,
  sundial_default as sundial,
  sunrise_default as sunrise
};
/*! Bundled license information:

astronomia/src/base.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module base
   *)

astronomia/src/interpolation.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module interpolation
   *)

astronomia/src/angle.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module angle
   *)

astronomia/src/sexagesimal.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module sexagesimal
   *)

astronomia/src/globe.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module globe
   *)

astronomia/src/coord.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module coord
   *)

astronomia/src/nutation.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module nutation
   *)

astronomia/src/elementequinox.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module elementequinox
   *)

astronomia/src/precess.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module precess
   *)

astronomia/src/planetposition.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module planetposition
   *)

astronomia/src/solar.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module solar
   *)

astronomia/src/apparent.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module apparent
   *)

astronomia/src/apsis.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module apsis
   *)

astronomia/src/binary.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module binary
   *)

astronomia/src/conjunction.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module conjunction
   *)

astronomia/src/circle.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module circle
   *)

astronomia/src/deltat.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module deltat
   *)

astronomia/src/iterate.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module iterate
   *)

astronomia/src/kepler.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module kepler
   *)

astronomia/src/solarxyz.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module solarxyz
   *)

astronomia/src/elliptic.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module elliptic
   *)

astronomia/src/moonphase.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module moonphase
   *)

astronomia/src/eclipse.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module eclipse
   *)

astronomia/src/elp.js:
  (**
   * @copyright 2020 mdmunir
   * @copyright 2020 commenthol
   * @license MIT
   * @module elp
   *)

astronomia/src/eqtime.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module eqtime
   *)

astronomia/src/fit.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module fit
   *)

astronomia/src/illum.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module illum
   *)

astronomia/src/julian.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module julian
   *)

astronomia/src/jm.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module jm
   *)

astronomia/src/jupiter.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module jupiter
   *)

astronomia/src/planetelements.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module planetelements
   *)

astronomia/src/jupitermoons.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module jupitermoons
   *)

astronomia/src/line.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module line
   *)

astronomia/src/nearparabolic.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module nearparabolic
   *)

astronomia/src/node.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module node
   *)

astronomia/src/mars.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module mars
   *)

astronomia/src/moonposition.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module moonposition
   *)

astronomia/src/moon.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module moon
   *)

astronomia/src/moonillum.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module moonillum
   *)

astronomia/src/moonmaxdec.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module moonmaxdec
   *)

astronomia/src/moonnode.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module moonnode
   *)

astronomia/src/parabolic.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module parabolic
   *)

astronomia/src/sidereal.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module sidereal
   *)

astronomia/src/parallax.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module parallax
   *)

astronomia/src/parallactic.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module parallactic
   *)

astronomia/src/perihelion.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module perihelion
   *)

astronomia/src/planetary.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module planetary
   *)

astronomia/src/pluto.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module pluto
   *)

astronomia/src/refraction.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module refraction
   *)

astronomia/src/rise.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module rise
   *)

astronomia/src/saturnmoons.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module saturnmoons
   *)

astronomia/src/saturnring.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module saturnring
   *)

astronomia/src/solardisk.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module solardisk
   *)

astronomia/src/solstice.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module solstice
   *)

astronomia/src/stellar.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module stellar
   *)

astronomia/src/sundial.js:
  (**
   * @copyright 2013 Sonia Keys
   * @copyright 2016 commenthol
   * @license MIT
   * @module sundial
   *)

astronomia/src/sunrise.js:
  (**
   * @copyright 2016 commenthol
   * @license MIT
   * @module sunrise
   *)
*/
//# sourceMappingURL=astronomia.js.map
